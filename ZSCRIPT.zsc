version "4.5"

#include "ZScript/FollowerHandler.zsc"
#include "ZScript/CommandMenu.zsc"
#include "ZScript/Management.zsc"
#include "ZScript/Recruitment.zsc"
#include "ZScript/Data.zsc"
#include "ZScript/States.zsc"
#include "ZScript/Resurrection.zsc"
#include "ZScript/Armor.zsc"
#include "ZScript/Medical.zsc"
#include "ZScript/Weapons.zsc"
#include "ZScript/AI.zsc"
#include "ZScript/Goals.zsc"
#include "ZScript/Orders.zsc"
#include "ZScript/Targeting.zsc"
#include "ZScript/Brass.zsc"
#include "ZScript/Loadout.zsc"
#include "ZScript/Messages.zsc"

#include "ZScript/Followers/Freylis.zsc"
#include "ZScript/Followers/Balthazar.zsc"
#include "ZScript/Followers/Valnos.zsc"
#include "ZScript/Followers/Daina.zsc"
#include "ZScript/Followers/Sewie.zsc"
#include "ZScript/Followers/Nari.zsc"

// [Ace] Needs to be last or else it messes with the Enabled check in the creation loop in FollowerHandler::WorldLoaded().
#include "ZScript/Followers/RecruitedMarine.zsc"

class HDFollower : HDMobMan abstract
{
	enum PrintMessageType
	{
		PMType_Forced,
		PMType_Critical,
		PMType_Important,
		PMType_General
	}

	// --------------------------------------------------
	// NEVER GONNA TOUCH THESE PROBABLY
	// --------------------------------------------------

	private HDBleedingWound GetBleedThinker()
	{
		ThinkerIterator it = ThinkerIterator.Create("HDBleedingWound", STAT_DEFAULT);
		HDBleedingWound BleedThinker;
		while ((BleedThinker = HDBleedingWound(it.Next())))
		{
			if (BleedThinker.bleeder == self)
			{
				return BleedThinker;
			}
		}
		return BleedThinker;
	}

	bool IsDeadOrMissing()
	{
		bool FollowerDead = Health <= 0;
		bool TooFar = self.Distance2D(LinkedPlayer) > 42 * 15;

		return TooFar || FollowerDead;
	}

	clearscope bool CanInteractWith(bool validIfDead = true)
	{
		return Health > 0 && bFRIENDLY || Health <= 0 && validIfDead;
	}

	void WarpToPlayer()
	{
		Warp(LinkedPlayer, 16, flags: WARPF_NOCHECKPOSITION);
	}

	private clearscope bool PlayerIsCrouching()
	{
		return LinkedPlayer.player.crouchfactor < 1.0;
	}

	private bool IsFacedByPlayer()
	{
		double PAngle = LinkedPlayer.angle;
		double PAngleTo = self.AngleTo(LinkedPlayer) + 180; // [Ace] Add 180 to invert direction, otherwise you need to face away from the follower.
		return AbsAngle(PAngle, PAngleTo) <= MaxFaceAngle;
	}

	clearscope string GetPronoun(bool upper)
	{
		// [Ace] Personal pronouns, objective case, third person singular.
		switch (Gender)
		{
			case GENDER_MALE: return upper ? "Him" : "him";
			case GENDER_FEMALE: return upper ? "Her" : "her";
			case GENDER_NEUTRAL: return upper ? "It" : "it";
			case GENDER_OTHER: return upper ? "Them" : "them";
		}

		return "??????";
	}

	clearscope string GetDisplayName()
	{
		return DisplayName != "" ? DisplayName : GetTag();
	}

	void ChangeLinkedPlayer(HDPlayerPawn plr)
	{
		LinkedPlayer = plr;
		master = plr; // [Ace] War Trophies compatibility.
	}

	// --------------------------------------------------
	// OTHER STUFF
	// --------------------------------------------------

	virtual void Dismiss()
	{
		DropAllAmmo();
		DropAllSupplies();
		let WornArmor = FindInventory("HDArmourWorn");
		if (WornArmor)
		{
			A_DropInventory(WornArmor.GetClass());
		}
		for (int i = 0; i < 64; ++i)
		{
			vector3 POff = ((random() - 128) * Radius / 128, (random() - 128) * Radius / 128, random() * Height / 256);
			vector3 PVel = ((1.0 / 4096) * (random() - 128), (1.0 / 4096) * (random() - 128), (1.0 / 4096) * (random() - 128));
			vector3 PAcc = ((1.0 / 16384) * (random() - 128), (1.0 / 16384) * (random() - 128), (1.0 / 16384) * (random() - 128));
			A_SpawnParticle(random(0, 1) ? Color(154, 49, 49) : Color(125, 24, 24), 0, TICRATE * 2, 4, 0, POff.x, POff.y, POff.z, PVel.x, PVel.y, PVel.z, PAcc.x, PAcc.y, PAcc.z);
		}
		if (!random[dismissrand](0, 10))
		{
			Console.Printf("%s disconnected.", DisplayName);
		}
		Handler.RemoveFollower(self, true);
	}

	// --------------------------------------------------
	// TICKER
	// --------------------------------------------------

	override void Tick()
	{
		Super.Tick();

		if (!LinkedPlayer) // [Ace] If this ever goes null, something is horribly wrong.
		{
			return;
		}

		if (!OhanaMode) { OhanaMode = CVar.GetCVar('hdf_ohana'); }

		CanSeePlayer = CheckSight(LinkedPlayer, SF_SEEPASTSHOOTABLELINES);
		DistanceToPlayer = Distance3D(LinkedPlayer);

		if (OhanaMode.GetBool() && (CanSeePlayer && DistanceToPlayer > 840 || !CanSeePlayer && DistanceToPlayer > 210))
		{
			OhanaTicker++;
			if (OhanaTicker >= OhanaDeathTime && Health > 0)
			{
				A_Die();
				BodyDamage = 10000;
				BloodReviveTicker = 10000;
			}
			else if (OhanaTicker >= OhanaDisappearTime)
			{
				Handler.RemoveFollower(self, true);
				return;
			}
		}
		else
		{
			OhanaTicker = 0;
		}

		if (bFRIENDLY && Health > 0 && LinkedPlayer.Health <= 0)
		{
			return;
		}

		// [Ace] Only tick timer if idling.
		if (!Moving)
		{
			IdleTimer--;
			CommentTimer--;
		}

		if (Health > 0)
		{
			if (Status == FStatus_WaitingForArmor)
			{
				if (Distance3D(LinkedPlayer) > 512)
				{
					PrintMessage(GetResponse("ARMORGIVE_RANAWAY"), "ArmorGive/RanAway", PMType_Critical);
					Status = FStatus_None;
				}
				else if (level.time % 35 == 0)
				{
					A_Face(LinkedPlayer);
					LookForArmor();
				}
			}

			if (level.time % 3 == 0 && Status != FStatus_InactiveOrDead && !InStateSequence(CurState, FindState("Spawn")))
			{
				AiThink();
			}

			if (level.time % 35 * 2 == 0)
			{
				if (Bloodloss > 0)
				{
					Bloodloss--;
				}
			}
		}
	}

	override string GetObituary(Actor victim, Actor inflictor, Name mod, bool playerattack)
	{
		return String.Format("%s suffered friendly fire from %s, but friendly fire, isn't.", HDPlayerPawn(victim).player.GetUserName(), inflictor.target ? inflictor.target.GetTag() : inflictor.GetTag());
	}

	// --------------------------------------------------
	// INITIALIZATION
	// --------------------------------------------------

	override void BeginPlay()
	{
		Handler = FollowerHandler(EventHandler.Find('FollowerHandler'));

		Super.BeginPlay();
	}

	override void PostBeginPlay()
	{
		ResetIdleTimer();
		ResetCommentTimer();

		Super.PostBeginPlay();

		// [Ace] I gotta defer setting these until after Super.PostBeginPlay() is called or else picking up the incapped follower and placing them again heals them partially.
		Bloodloss = NewBloodloss;
		BodyDamage = NewBodyDamage;
		Stunned = NewStunned;

		// [Ace] Same as above. For some reason HDMagicShield gets nuked if given while unpacking the follower.
		if (Shields > 0)
		{
			let ShieldInv = GiveInventoryType('HDMagicShield');
			ShieldInv.Amount = Shields;
			ShieldInv.MaxAmount = MaxShields;
			ShieldInv.bQUICKTORETALIATE = NoShieldsDegeneration;
			ShieldInv.bSTANDSTILL = RegenerateShields;
		}
	}

	const MaxInventoryDistance = 48;
	const MaxFaceAngle = 20;

	private transient CVar OhanaMode;
	private int OhanaTicker;
	const OhanaDeathTime = 35 * 60 * 5;
	const OhanaDisappearTime = 35 * 60 * 15;

	FollowerHandler Handler;

	protected double MovementSpeed, MaxMovementSpeed;
	property MovementSpeed: MovementSpeed, MaxMovementSpeed;

	meta int ResurrectType;
	property ResurrectType: ResurrectType;

	string DisplayName;

	meta uint Index;
	int Gender;
	meta class<FollowerBody> DataClass;
	meta class<LeftBehindFollower> MissingClass; // [Ace] If this is null, assume follower is non-essential. Like marines.
	property FollowerInfo: Index, Gender, DataClass, MissingClass;

	private int BehaviourFlags;
	flagdef Silent: BehaviourFlags, 0;
	flagdef CanDismiss: BehaviourFlags, 1;

	Default
	{
		Health 200;
		Radius 12;
		Height 52;
		HDFollower.MovementSpeed 3, 8;
		PainChance 192;
		MaxStepHeight 80;
		MaxDropOffHeight 128;
		MaxTargetRange 2520;
		+ROLLCENTER
		+ROLLSPRITE
		+FRIENDLY
		+NODAMAGETHRUST
		+SLIDESONWALLS
		+NODROPOFF
		+NOBLOCKMONST
		+NOTELESTOMP
		+NOTELEFRAG // [Ace] Because starting levels can telefrag the followers in multiplayer if there isn't enough space.
		+BLOCKASPLAYER
		+NOTRIGGER
		+SEEINVISIBLE
		+BOSSDEATH
		+NOFEAR
		+THRUSPECIES
		HDMobBase.DownedFrame 16;
		HDMobBase.MaxBloodLoss 400;
		Species 'HDFollower';
		HDFollower.ResurrectType RESF_BLUES | RESF_BLOOD;
	}
}

class LeftBehindFollower : Inventory abstract { Default { +INVENTORY.UNDROPPABLE } }