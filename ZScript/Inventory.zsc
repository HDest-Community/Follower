class InventorySlot
{
	class<HDPickup> ItemClass;
	string Icon;
	int Amount;
	bool Multipickup;

	static clearscope bool IsRealMag(class<HDPickup> mag)
	{
		return mag is 'HDMagAmmo' && GetDefaultByType((class<HDMagAmmo>)(mag)).MaxPerUnit > 0;
	}
}

extend class HDFollower
{
	enum FollowerInventoryFlags
	{
		FIF_FORCE = 1,
		FIF_REVERSEDIRECTION = 2,
		FIF_REMOVE = 4, // [Ace] TakeInvItem only.
	}

	// --------------------------------------------------
	// VIRTUALS
	// --------------------------------------------------

	virtual clearscope bool IsValidItem(class<HDPickup> cls, bool ignoreWeaponValidity = false)
	{
		return cls && ((cls is 'HDAmmo' && AmmoIsUsed((class<HDAmmo>)(cls)) || ignoreWeaponValidity) || cls == 'PortableMedikit' || cls == 'PortableStimpack' || cls == 'BluePotion');
	}

	// --------------------------------------------------
	// ACTIONS
	// --------------------------------------------------

	// [Ace] Anything that's not a mag. Including loose ammo.
	bool AddItem(HDPickup item, int amt = 1, int maxAmt = MaxLooseAmmoAmount, int slot = -1, int flags = 0)
	{
		if (!(flags & FIF_FORCE))
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return false;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return false;
			}
		}

		while (amt > 0 && item.Amount > 0)
		{
			// [Ace] Always fill partials first.
			int index = GetPartialItemIndex(item.GetClass(), maxAmt: maxAmt);
			if (index == -1)
			{
				if (flags & FIF_REVERSEDIRECTION)
				{
					index = GetLastEmptySlotIndex(slot == -1 ? SlotCount - 1 : slot);
				}
				else
				{
					index = GetFirstEmptySlotIndex(slot == -1 ? 0 : slot);
				}

				if (index == -1)
				{
					return false;
				}
			}

			if (!Slots[index])
			{
				Slots[index] = new('InventorySlot');
			}
			Slots[index].ItemClass = item.GetClass();
			Slots[index].Icon = TexMan.GetName(item.Icon);
			Slots[index].Multipickup = item.bMULTIPICKUP;
			int leftInSlot = maxAmt - Slots[index].Amount;
			int toAdd = min(leftInSlot, amt, item.Amount);
			item.Amount -= toAdd;
			Slots[index].Amount += toAdd;
			amt -= toAdd;
			if (item.Amount == 0)
			{
				item.Destroy();
				break;
			}
			if (hdf_debug & FDebug_Inventory)
			{
				Console.Printf("[%s, %s], slot %i: added ITEM %s with an amount of %i.", level.TimeFormatted(), GetTag(), index, Slots[index].ItemClass.GetClassName(), Slots[index].Amount);
			}
		}

		return true;
	}

	// [Ace] Used for mags.
	bool AddMag(HDMagAmmo mag, int magIndex = -1, int slot = -1, int flags = 0)
	{
		if (!(flags & FIF_FORCE))
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return false;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return false;
			}
		}

		int index = -1;
		if (flags & FIF_REVERSEDIRECTION)
		{
			index = GetLastEmptySlotIndex(slot == -1 ? SlotCount - 1 : slot);
		}
		else
		{
			index = GetFirstEmptySlotIndex(slot == -1 ? 0 : slot);
		}
		if (index == -1)
		{
			return false;
		}

		Slots[index] = new('InventorySlot');
		Slots[index].ItemClass = mag.GetClass();
		Slots[index].Icon = AceCore.GetIcon(mag);
		Slots[index].Multipickup = false;
		if (magIndex == -1)
		{
			magIndex = mag.Mags.Size() - 1;
		}
		int magAmt = mag.Mags[magIndex];
		Slots[index].Icon = AceCore.GetIcon(mag, magAmt);
		Slots[index].Amount = magAmt;
		mag.Mags.Delete(magIndex);
		mag.Amount--;
		if (mag.Amount == 0)
		{
			mag.Destroy();
		}
		if (hdf_debug & FDebug_Inventory)
		{
			Console.Printf("[%s, %s], slot %i: added MAG %s with an amount of %i.", level.TimeFormatted(), GetTag(), index, Slots[index].ItemClass.GetClassName(), Slots[index].Amount);
		}

		return true;
	}

	override void ClearInventory()
	{
		for (int i = 0; i < SlotCount; ++i)
		{
			if (Slots[i])
			{
				Slots[i].Destroy();
			}
		}
		Super.ClearInventory();
	}

	void DropInvItem(InventorySlot slot, int flags = 0)
	{
		if (!slot || !CanInteractWith())
		{
			return;
		}

		if (!(flags & FIF_FORCE) && Health <= 0)
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return;
			}
		}

		if (hdf_debug & FDebug_Inventory)
		{
			for (int i = 0; i < SlotCount; ++i)
			{
				if (Slots[i] == slot)
				{
					Console.Printf("[%s, %s], slot %i: dropped %s with an amount of %i.", level.TimeFormatted(), GetTag(), i, slot.ItemClass.GetClassName(), slot.Amount);
					break;
				}
			}
		}

		// [Ace] HMMMMMM THIS CODE LOOKS FAMILIAR.
		Inventory Spawned = Inventory(Actor.Spawn(slot.ItemClass, pos));
		HDPickup newitem = HDPickup(Spawned);
		if (slot.ItemClass is 'HDMagAmmo')
		{
			HDMagAmmo(newitem).Mags.Push(slot.Amount);
		}
		else
		{
			newitem.Amount = slot.Amount;
		}
		newitem.angle = angle;
		newitem.A_ChangeVelocity(1.5, 0, 1, CVF_RELATIVE);
		newitem.vel += vel;
		slot.Destroy();
	}

	void TakeInvItem(InventorySlot slot, int flags = 0)
	{
		if (!slot || !CanInteractWith())
		{
			return;
		}

		if (!(flags & FIF_FORCE))
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return;
			}
		}

		if (hdf_debug & FDebug_Inventory)
		{
			for (int i = 0; i < SlotCount; ++i)
			{
				if (Slots[i] == slot)
				{
					Console.Printf("[%s, %s], slot %i: %s %s with an amount of %i.", level.TimeFormatted(), GetTag(), i, flags & FIF_REMOVE ? "removed" : "took", slot.ItemClass.GetClassName(), slot.Amount);
					break;
				}
			}
		}

		if (flags & FIF_REMOVE)
		{
			slot.Destroy();
			return;
		}

		if (slot.ItemClass is 'HDMagAmmo')
		{
			HDMagAmmo.GiveMag(LinkedPlayer, slot.ItemClass, slot.Amount);
			slot.Destroy();
		}
		else
		{
			int diff = GetDefaultByType(slot.ItemClass).MaxAmount - LinkedPlayer.CountInv(slot.ItemClass);
			int maxAdd = min(diff, slot.Amount);
			if (maxAdd == 0)
			{
				ThinkMessage(LinkedPlayer, "$NOSPACE_PLR");
				return;
			}
			HDF.Give(LinkedPlayer, slot.ItemClass, maxAdd);
			slot.Amount -= maxAdd;
			if (slot.Amount == 0)
			{
				slot.Destroy();
			}
		}
	}

	// --------------------------------------------------
	// INFORMATION
	// --------------------------------------------------

	clearscope InventorySlot Find(class<HDPickup> cls, int flags = 0)
	{
		InventorySlot slot = null;
		if (flags & FIF_REVERSEDIRECTION)
		{
			for (int i = SlotCount - 1; i >= 0; --i)
			{
				if (Slots[i] && Slots[i].ItemClass == cls)
				{
					return Slots[i];
				}
			}
		}
		else
		{
			for (int i = 0; i < SlotCount; ++i)
			{
				if (Slots[i] && Slots[i].ItemClass == cls)
				{
					return Slots[i];
				}
			}
		}
		return null;
	}

	clearscope InventorySlot FindHighestAmount(class<HDPickup> cls)
	{
		int maxFound = 0;
		InventorySlot slot = null;
		for (int i = 0; i < SlotCount; ++i)
		{
			if (!Slots[i])
			{
				continue;
			}

			// [Ace] HMMMMMM THIS CODE LOOKS FAMILIAR.
			if (Slots[i].ItemClass == cls)
			{
				if (Slots[i].Amount >= maxFound)
				{
					maxFound = Slots[i].Amount;
					slot = Slots[i];
				}
			}
		}
		return slot;
	}

	clearscope InventorySlot FindLowestAmount(class<HDPickup> cls)
	{
		int minFound = int.MAX;
		InventorySlot slot = null;
		for (int i = SlotCount - 1; i >= 0; --i)
		{
			if (!Slots[i])
			{
				continue;
			}

			if (Slots[i].ItemClass == cls)
			{
				if (Slots[i].Amount < minFound)
				{
					minFound = Slots[i].Amount;
					slot = Slots[i];
				}
			}
		}
		return slot;
	}

	clearscope int GetAmount(class<HDPickup> cls)
	{
		int Total = 0;
		for (int i = 0; i < SlotCount; ++i)
		{
			if (Slots[i] && Slots[i].ItemClass == cls)
			{
				Total += Slots[i].Amount;
			}
		}
		return Total;
	}

	clearscope int GetFirstEmptySlotIndex(int startIndex)
	{
		for (int i = startIndex; i < SlotCount; ++i)
		{
			if (!Slots[i])
			{
				return i;
			}
		}
		return -1;
	}

	clearscope int GetLastEmptySlotIndex(int startIndex)
	{
		for (int i = startIndex; i >= 0; --i)
		{
			if (!Slots[i])
			{
				return i;
			}
		}
		return -1;
	}

	clearscope int GetPartialItemIndex(class<HDPickup> cls, int startIndex = 0, int maxAmt = MaxLooseAmmoAmount)
	{
		for (int i = startIndex; i < SlotCount; ++i)
		{
			if (Slots[i] && Slots[i].ItemClass == cls && Slots[i].Amount < maxAmt)
			{
				return i;
			}
		}
		return -1;
	}


	// --------------------------------------------------
	// CONSTANTS/VARIABLES
	// --------------------------------------------------

	const SlotCount = 30;
	const MaxInventoryDistance = HDCONST_ONEMETRE * 1.25;
	const MaxLooseAmmoAmount = 50;
	InventorySlot Slots[SlotCount];
}
