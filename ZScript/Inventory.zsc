class InventorySlot
{
	class<HDPickup> ItemClass;
	string Icon;
	int Amount;
	bool Multipickup;

	static clearscope bool IsRealMag(class<HDPickup> mag)
	{
		return mag is 'HDMagAmmo' && GetDefaultByType((class<HDMagAmmo>)(mag)).MaxPerUnit > 0;
	}
}

extend class HDFollower
{
	enum FollowerInventoryFlags
	{
		FIF_FORCE = 1
	}

	// --------------------------------------------------
	// VIRTUALS
	// --------------------------------------------------

	virtual clearscope bool IsValidItem(class<HDPickup> cls, bool ignoreWeaponValidity = false)
	{
		return cls && ((cls is 'HDAmmo' && AmmoIsUsed((class<HDAmmo>)(cls)) || ignoreWeaponValidity) || cls == 'PortableMedikit' || cls == 'PortableStimpack');
	}

	// --------------------------------------------------
	// ACTIONS
	// --------------------------------------------------

	// [Ace] Anything that's not a mag. Including loose ammo.
	bool AddItem(HDPickup item, int amt = 1, int maxAmt = MaxLooseAmmoAmount, int slot = -1, int flags = 0)
	{
		if (!(flags & FIF_FORCE))
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return false;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return false;
			}
		}

		while (amt > 0 && item.Amount > 0)
		{
			// [Ace] Always fill partials first.
			int index = GetPartialItemIndex(item.GetClass(), maxAmt: maxAmt);
			if (index == -1)
			{
				index = GetFirstEmptySlotIndex(slot == -1 ? 0 : slot);
				if (index == -1)
				{
					return false;
				}
			}

			if (!Slots[index])
			{
				Slots[index] = new('InventorySlot');
			}
			Slots[index].ItemClass = item.GetClass();
			Slots[index].Icon = TexMan.GetName(item.Icon);
			Slots[index].Multipickup = item.bMULTIPICKUP;
			int LeftInSlot = maxAmt - Slots[index].Amount;
			int ToAdd = min(LeftInSlot, amt, item.Amount);
			item.Amount -= ToAdd;
			Slots[index].Amount += ToAdd;
			amt -= ToAdd;
			if (item.Amount == 0)
			{
				item.Destroy();
				break;
			}
		}

		return true;
	}

	// [Ace] Used for mags.
	bool AddMag(HDMagAmmo mag, int magIndex = -1, int slot = -1, int flags = 0)
	{
		if (!(flags & FIF_FORCE))
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return false;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return false;
			}
		}

		int index = GetFirstEmptySlotIndex(slot == -1 ? 0 : slot);
		if (index == -1)
		{
			return false;
		}

		Slots[index] = new('InventorySlot');
		Slots[index].ItemClass = mag.GetClass();
		Slots[index].Icon = AceCore.GetIcon(mag);
		Slots[index].Multipickup = false;
		if (magIndex == -1)
		{
			magIndex = mag.Mags.Size() - 1;
		}
		int magAmt = mag.Mags[magIndex];
		Slots[index].Icon = AceCore.GetIcon(mag, magAmt);
		Slots[index].Amount = max(1, magAmt);
		mag.Mags.Delete(magIndex);
		mag.Amount--;
		if (mag.Amount == 0)
		{
			mag.Destroy();
		}

		return true;
	}

	void DropInvItem(InventorySlot slot, bool force = false)
	{
		if (!slot || !CanInteractWith())
		{
			return;
		}

		if (!force && Health <= 0)
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return;
			}
		}

		// [Ace] HMMMMMM THIS CODE LOOKS FAMILIAR.
		Inventory Spawned = Inventory(Actor.Spawn(slot.ItemClass, pos));
		HDPickup newitem = HDPickup(Spawned);
		if (slot.ItemClass is 'HDMagAmmo')
		{
			HDMagAmmo(newitem).Mags.Push(slot.Amount);
		}
		else
		{
			newitem.Amount = slot.Amount;
		}
		newitem.angle = angle;
		newitem.A_ChangeVelocity(1.5, 0, 1, CVF_RELATIVE);
		newitem.vel += vel;
		slot.Destroy();
	}

	void TakeInvItem(InventorySlot slot)
	{
		if (!slot || !CanInteractWith())
		{
			return;
		}

		switch (CanReach(MaxInventoryDistance))
		{
			case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return;
			case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return;
		}

		if (slot.ItemClass is 'HDMagAmmo')
		{
			HDMagAmmo.GiveMag(LinkedPlayer, slot.ItemClass, slot.Amount);
			slot.Destroy();
		}
		else
		{
			int diff = GetDefaultByType(slot.ItemClass).MaxAmount - LinkedPlayer.CountInv(slot.ItemClass);
			int maxAdd = min(diff, slot.Amount);
			if (maxAdd == 0)
			{
				ThinkMessage(LinkedPlayer, "$NOSPACE_PLR");
				return;
			}
			HDF.Give(LinkedPlayer, slot.ItemClass, maxAdd);
			slot.Amount -= maxAdd;
			if (slot.Amount == 0)
			{
				slot.Destroy();
			}
		}
	}

	// --------------------------------------------------
	// INFORMATION
	// --------------------------------------------------

	clearscope InventorySlot Find(class<HDPickup> cls)
	{
		InventorySlot slot = null;
		for (int i = 0; i < SlotCount; ++i)
		{
			if (!Slots[i])
			{
				continue;
			}

			if (Slots[i].ItemClass == cls)
			{
				slot = Slots[i];
			}
		}
		return slot;
	}

	clearscope InventorySlot FindHighestAmount(class<HDPickup> cls)
	{
		int maxFound = 0;
		InventorySlot slot = null;
		for (int i = 0; i < SlotCount; ++i)
		{
			if (!Slots[i])
			{
				continue;
			}

			// [Ace] HMMMMMM THIS CODE LOOKS FAMILIAR.
			if (Slots[i].ItemClass == cls)
			{
				if (Slots[i].Amount >= maxFound)
				{
					maxFound = Slots[i].Amount;
					slot = Slots[i];
				}
			}
		}
		return slot;
	}

	clearscope InventorySlot FindLowestAmount(class<HDPickup> cls)
	{
		int minFound = int.MAX;
		InventorySlot slot = null;
		for (int i = SlotCount - 1; i >= 0; --i)
		{
			if (!Slots[i])
			{
				continue;
			}

			if (Slots[i].ItemClass == cls)
			{
				if (Slots[i].Amount < minFound)
				{
					minFound = Slots[i].Amount;
					slot = Slots[i];
				}
			}
		}
		return slot;
	}

	clearscope int GetAmount(class<HDPickup> cls)
	{
		int Total = 0;
		for (int i = 0; i < SlotCount; ++i)
		{
			if (Slots[i] && Slots[i].ItemClass == cls)
			{
				Total += Slots[i].Amount;
			}
		}
		return Total;
	}

	clearscope int GetFirstEmptySlotIndex(int startIndex = 0)
	{
		for (int i = startIndex; i < SlotCount; ++i)
		{
			if (!Slots[i])
			{
				return i;
			}
		}
		return -1;
	}

	clearscope int GetPartialItemIndex(class<HDPickup> cls, int startIndex = 0, int maxAmt = MaxLooseAmmoAmount)
	{
		for (int i = startIndex; i < SlotCount; ++i)
		{
			if (Slots[i] && Slots[i].ItemClass == cls && Slots[i].Amount < maxAmt)
			{
				return i;
			}
		}
		return -1;
	}


	// --------------------------------------------------
	// CONSTANTS/VARIABLES
	// --------------------------------------------------

	const SlotCount = 30;
	const MaxInventoryDistance = 48;
	const MaxFaceAngle = 35;
	const MaxLooseAmmoAmount = 50;
	InventorySlot Slots[SlotCount];
}
