class FollowerCommand ui
{
	string EventName;
	int Args[3];
}

class FollowerHandler : EventHandler
{
	enum FollowerMenus
	{
		FMenu_Closed,
		FMenu_Followers,
		FMenu_Main,
		FMenu_Orders,
		FMenu_Weapons,
		FMenu_Supplies,
		FMenu_Miscellaneous
	}

	// ----------------------------------------------------------
	// CORE
	// ----------------------------------------------------------

	const InternalFollowers = 6;

	Array<HDFollower> Followers;

	private transient int FollowerMenuLevel[MAXPLAYERS];
	private transient HDFollower SelFollower[MAXPLAYERS];
	private transient Array<FollowerBody> FollowersInInv;

	private transient bool CanExitNow;
	private transient int WarningResetTimer;

	private transient ui HUDFont MainFont;

	void InsertFollower(HDFollower flw)
	{
		int InsIndex = 0;
		int FollowerCount = Followers.Size();
		if (FollowerCount > 0)
		{
			for (int i = 0; i < FollowerCount; ++i)
			{
				if (flw.Index >= Followers[i].Index)
				{
					InsIndex = i + 1;
				}
				else
				{
					InsIndex = i;
					break;
				}
			}
		}
		Followers.Insert(InsIndex, flw);
	}

	void RemoveFollower(HDFollower flw, bool permanent = false)
	{
		int Index = Followers.Find(flw);
		if (Index != Followers.Size())
		{
			if (permanent && players[Net_Arbitrator].mo)
			{
				players[Net_Arbitrator].mo.A_GiveInventory(flw.MissingClass);
			}
			flw.Destroy();
			Followers.Delete(Index);
		}
	}

	private void CreateFollower(class<HDFollower> flw, int playerNum)
	{
		let plr = players[playerNum].mo;
		if (plr)
		{
			let FollowerDef = GetDefaultByType(flw);

			// [Ace] New map who dis? Spawn a new follower.
			if (!plr.CheckInventory(FollowerDef.MissingClass, 1))
			{
				Actor a; bool success;
				[success, a] = plr.A_SpawnItemEx(flw, random(16, 48), 0, random(0, 32), angle: random(0, 359), flags: SXF_NOCHECKPOSITION);
				if (success)
				{
					let Follower = HDFollower(a);
					InsertFollower(Follower);
					
					Follower.ChangeLinkedPlayer(HDPlayerPawn(plr));

					// [Ace] These are here so that they are only called once when the follower is created.
					Follower.GiveStartingItems();
					Follower.InitWeapons();
				}
			}
		}
	}

	override void PlayerEntered(PlayerEvent e)
	{
		let plr = players[e.PlayerNumber].mo;
		if (plr)
		{
			Inventory Next = plr.Inv;
			while (Next)
			{
				if (Next is 'FollowerBody')
				{
					FollowersInInv.Push(FollowerBody(Next));
				}
				Next = Next.Inv;
			}
		}
	}

	override void WorldLoaded(WorldEvent e)
	{
		if (GameState == GS_TITLELEVEL)
		{
			return;
		}

		let Arbitrator = players[Net_Arbitrator].mo;
		if (!Arbitrator)
		{
			return;
		}

		Array<class<HDFollower> > FollowerClasses;
		for (int i = 0; i < AllActorClasses.Size(); ++i)
		{
			if (AllActorClasses[i] is 'HDFollower' && AllActorClasses[i].GetClassName() != 'HDFollower')
			{
				FollowerClasses.Push((class<HDFollower>)(AllActorClasses[i]));
			}
		}

		int FollowerSpawns = hdf_followers;
		for (int i = 0; i < FollowerClasses.Size(); ++i)
		{
			// [Ace] FollowerSpawns only affects built-in followers.
			if (FollowerSpawns & (1 << i) || i > InternalFollowers - 1)
			{
				int Index = -1;
				for (int j = 0; j < FollowersInInv.Size(); ++j)
				{
					if (FollowersInInv[j].FollowerClass == FollowerClasses[i])
					{
						Index = j;
						break;
					}
				}
				
				// [Ace] Only attempt to spawn a follower if they haven't been picked up by any of the other players.
				if (Index == -1)
				{
					CreateFollower(FollowerClasses[i], Net_Arbitrator);
				}
				else if (CVar.GetCVar('hdf_droponstart', FollowersInInv[Index].owner.player).GetBool())
				{
					FollowersInInv[Index].owner.UseInventory(FollowersInInv[Index]);
					FollowersInInv.Delete(Index);
				}
			}
		}
	}

	override void WorldUnloaded(WorldEvent e)
	{
		while (Followers.Size() > 0)
		{
			HDFollower flw = Followers[0];
			if (flw.IsDeadOrMissing())
			{
				RemoveFollower(flw, true);
			}
			else
			{
				flw.PackFollower(true);
			}
		}
	}

	override void WorldLinePreActivated(WorldEvent e)
	{
		// [Ace] This only prints the warning. Tokens are given when you actually exit the level.
		if (e.Thing is "PlayerPawn" && (e.ActivatedLine.special == 74 || e.ActivatedLine.special == 243 || e.ActivatedLine.special == 244) && !CanExitNow)
		{
			Array<HDFollower> MissingFollowers;
			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].IsDeadOrMissing())
				{
					MissingFollowers.Push(Followers[i]);
				}
			}
			
			int MSize = MissingFollowers.Size();
			if (MSize > 0)
			{
				// [Ace] Gotta have that proper grammar.
				string FNames = "";
				for (int i = 0; i < MSize; ++i)
				{
					FNames = FNames..MissingFollowers[i].GetTag();

					if (i + 2 == MSize)
					{
						FNames = FNames..(MSize > 2 ? "," : "").." and ";
					}
					else if (i + 2 < MSize)
					{
						FNames = FNames..", ";
					}
				}

				e.Thing.A_Print("\c[White]You shouldn't leave "..FNames.." behind.\c-\n\n\c[White]Activate the exit again within two seconds to exit the level and leave "..(MSize > 1 ? "them" : MissingFollowers[0].GetPronoun(false)).." to the monsters.\c-", 4);
				e.ShouldActivate = false;
				CanExitNow = true;
				WarningResetTimer = 70;
			}	
		}
	}

	override void WorldTick()
	{
		if (CanExitNow && --WarningResetTimer <= 0)
		{
			CanExitNow = false;
		}
	}

	// ----------------------------------------------------------
	// UI
	// ----------------------------------------------------------

	override void RenderOverlay(RenderEvent e)
	{
		MainFont = HUDFont.Create("CONFONT");

		int OriginalWidth = StatusBar.HorizontalResolution;
		int OriginalHeight = StatusBar.VerticalResolution;

		StatusBar.BeginHUD(1.0, true);
		StatusBar.SetSize(StatusBar.RelTop, 640, 480);

		if (FollowerMenuLevel[consoleplayer] > 0 && Followers.Size() > 0 && !AutomapActive && GameState == GS_LEVEL)
		{
			DrawCommandMenu(StatusBar, (0, 40), StatusBar.DI_SCREEN_LEFT | StatusBar.DI_SCREEN_VCENTER | StatusBar.DI_TEXT_ALIGN_LEFT);
		}

		// --------------- PRETEND WE WERE NEVER HERE ---------------

		StatusBar.BeginHUD(1.0, false);
		StatusBar.SetSize(StatusBar.RelTop, OriginalWidth, OriginalHeight);
	}

	private ui void DrawCommandMenu(BaseStatusBar sb, vector2 pos, int flags)
	{
		vector2 OriginalPos = pos;
		int RectangleHeight = MainFont.mFont.GetHeight() + 4;
		int Spacing = 1;

		// [Ace] Up here because it's used by several menus.
		string BrassString;
		if (SelFollower[consoleplayer])
		{
			int Brass = SelFollower[consoleplayer].GetTotalBrass();
			int MaxBrass = SelFollower[consoleplayer].GetMaxBrass();
			BrassString = (Brass > 0 ? "" : "\c[Red]").."Collect brass\c- ".."("..Brass.."/"..MaxBrass..")";
		}

		switch (FollowerMenuLevel[consoleplayer])
		{
			case FMenu_Followers:
				if (Followers.Size() == 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				int FollowerBlockSize = RectangleHeight * 2 - 2;
				int FSize = Followers.Size();
				for (int i = 0; i < FSize; ++i)
				{
					DrawFollowerRectangle(sb, pos, (150, FollowerBlockSize), MainFont, i + 1, Followers[i], flags); pos.y += FollowerBlockSize + Spacing;
				}
				//DrawTextRectangle(sb, pos, (250, RectangleHeight), MainFont, FSize..") Select all", flags);
				break;

			case FMenu_Main:
				if (!SelFollower[consoleplayer])
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				if (SelFollower[consoleplayer].Health <= 0)
				{
					int RequiredSips = SelFollower[consoleplayer].GetRequiredSips();
					int RequiredBlood = SelFollower[consoleplayer].GetRequiredBlood();
					string BloodDanger;
					if (RequiredBlood < 10)
					{
						BloodDanger = "\c[FLW_BloodGreen](Safe)\c-";
					}
					else if (RequiredBlood < 20)
					{
						BloodDanger = "\c[FLW_BloodPoison](Risky)\c-";
					}
					else if (RequiredBlood < 30)
					{
						BloodDanger = "\c[FLW_BloodYellow](Dangerous)\c-";
					}
					else if (RequiredBlood < 40)
					{
						BloodDanger = "\c[FLW_BloodOrange](Extremely Risky)\c-";
					}
					else if (RequiredBlood < 50)
					{
						BloodDanger = "\c[FLW_BloodRed](Almost Deadly)\c-";
					}
					else
					{
						BloodDanger = "\c[FLW_BloodBlack](Certain Death)\c-";
					}

					Array<string> Commands;
					Commands.Push("Carry follower");
					if (SelFollower[consoleplayer].ResurrectType & HDFollower.RESF_BLUES)
					{
						Commands.Push((sb.CheckInventory("BluePotion", 1) ? "" : "\c[Red]").."Give blue potion\c- ".."\c[Blue]("..RequiredSips.."/12)\c-");
					}
					if (SelFollower[consoleplayer].ResurrectType & HDFollower.RESF_BLOOD)
					{
						Commands.Push("Feed blood "..BloodDanger);
					}
					Commands.Push(BrassString);
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					DrawTextRectangle(sb, pos, (250, RectangleHeight), MainFont, SelFollower[consoleplayer].GetTag(), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += RectangleHeight + Spacing;

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawTextRectangle(sb, pos, (250, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += RectangleHeight + Spacing;
					}
				}
				else if (SelFollower[consoleplayer].bFRIENDLY)
				{
					int Durability = 0;
					bool Mega = false;
					bool Waiting = SelFollower[consoleplayer].Status == FStatus_WaitingForArmor;
					let Armor = HDArmourWorn(SelFollower[consoleplayer].FindInventory("HDArmourWorn"));
					if (Armor)
					{
						Durability = Armor.Durability;
						Mega = Armor.Mega;
					}

					Array<string> Commands;
					Commands.Push("Orders");
					Commands.Push("Carry follower");
					Commands.Push("Give ammo");
					Commands.Push("Give supplies");
					Commands.Push((Waiting ? "Confirm/Cancel?" : "Use/drop armor"..(Durability > 0 ? (Mega ? "\c[Blue]" : "\c[DarkGreen]").." ("..Durability..")": "")).."\c-");
					Commands.Push("Misc commands");
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					int RectangleWidth = 150;
					if (!Waiting && Durability > 0)
					{
						RectangleWidth += 40;
					}

					DrawTextRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, SelFollower[consoleplayer].GetTag(), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += RectangleHeight + Spacing;
					
					if (Followers.Size() == 1 && Followers[0].CanInteractWith())
					{
						vector3 Diff = level.Vec3Diff(Followers[0].pos, Followers[0].LinkedPlayer.pos);
						DrawTextRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, String.Format("%i, %i, %i", abs(diff.x), abs(diff.y), abs(diff.z)), flags, Font.CR_DARKGRAY);
						pos.y += RectangleHeight + Spacing;
					}

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawTextRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += RectangleHeight + Spacing;
					}
				}
				break;

			case FMenu_Orders:
				if (!SelFollower[consoleplayer])
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				static const string Orders[] = { "Follow", "Follow and ignore hostiles", "Stay and provide cover", "Go there and provide cover", "Come and help me" };

				DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, SelFollower[consoleplayer].GetTag(), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;
				for (int i = 0; i < Orders.Size(); ++i)
				{
					DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, (i + 1)..") "..(SelFollower[consoleplayer].Order == i ? "\c[Green]" : "")..Orders[i].."\c-", flags);
					pos.y += RectangleHeight + Spacing;
				}
				DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, (Orders.Size() + 1)..") Back...", flags);
				break;

			case FMenu_Weapons:
				if (!SelFollower[consoleplayer])
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				int WeaponSize = SelFollower[consoleplayer].Weapons.Size();
				int WeaponBlockSize = RectangleHeight * 3 - 5;
				if (WeaponSize > 4)
				{
					pos.y -= WeaponBlockSize * (WeaponSize - 4);
				}

				DrawTextRectangle(sb, pos, (160, RectangleHeight), MainFont, SelFollower[consoleplayer].GetTag(), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;
				for (int i = 0; i < WeaponSize; ++i)
				{
					DrawWeaponRectangle(sb, pos, (160, WeaponBlockSize), MainFont, i + 1, SelFollower[consoleplayer], flags);
					pos.y += WeaponBlockSize + Spacing;
				}
				DrawTextRectangle(sb, pos, (160, RectangleHeight), MainFont, ((WeaponSize + 1 % 10))..") Back...", flags);
				break;

			case FMenu_Supplies:
				if (!SelFollower[consoleplayer])
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, SelFollower[consoleplayer].GetTag(), flags, Font.FindFontColor('FLW_NameBlue')); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, "1) "..(sb.CheckInventory("PortableMedikit") ? "" : "\c[Red]").."Give Medikit\c- ".."("..SelFollower[consoleplayer].SuturesLeft..", "..SelFollower[consoleplayer].Medikits.."/"..SelFollower[consoleplayer].MaxMedikits..")", flags); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, "2) "..(sb.CheckInventory("PortableStimpack") ? "" : "\c[Red]").."Give Stimpack\c- ".."("..SelFollower[consoleplayer].Stimpacks.."/"..SelFollower[consoleplayer].MaxStimpacks..")", flags); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, "3) Back...", flags);
				break;

			case FMenu_Miscellaneous:
				if (!SelFollower[consoleplayer])
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				DrawTextRectangle(sb, pos, (235, RectangleHeight), MainFont, SelFollower[consoleplayer].GetTag(), flags, Font.FindFontColor('FLW_NameBlue')); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (235, RectangleHeight), MainFont, "1) "..BrassString, flags); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (235, RectangleHeight), MainFont, "2) Back...", flags);
				break;
		}
	}

	private ui void DrawFollowerRectangle(BaseStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int index, HDFollower flw, int flags)
	{
		bool Valid = flw.CanInteractWith();

		sb.Fill(Valid ? Color(64, 128, 192, 255) : Color(64, 255, 16, 16), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		pos += (2, 2);
		int FontHeight = fnt.mFont.GetHeight();
		sb.DrawString(fnt, index..") "..flw.GetTag(), pos, flags, Font.FindFontColor('FLW_NameBlue')); pos.y += FontHeight + 1;

		if (Valid)
		{
			vector3 Diff = level.Vec3Diff(flw.pos, flw.LinkedPlayer.pos);
			sb.DrawString(fnt, String.Format("%i, %i, %i", abs(diff.x), abs(diff.y), abs(diff.z)), pos, flags, Font.CR_DARKGRAY); pos.y += FontHeight + 1;
		}
	}

	private ui void DrawTextRectangle(BaseStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, string command, int flags, int col = Font.CR_WHITE)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);
		sb.DrawString(fnt, command, (pos.x + 2, pos.y + (size.y - fnt.mFont.GetHeight()) / 2), flags, col); 
	}

	private ui void DrawWeaponRectangle(BaseStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int index, HDFollower flw, int flags)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		FollowerWeapon wpn = flw.GetWeaponByIndex(index - 1);

		pos += (2, 2);
		int FontHeight = fnt.mFont.GetHeight();
		sb.DrawString(fnt, index..") "..wpn.GetName(), pos, flags, Font.FindFontColor('FLW_WeaponBlue')); pos.y += FontHeight + 1;
		sb.DrawString(fnt, (wpn.IsFullyLoaded() ? "\c[DarkGreen]" : "")..wpn.GetLoadedRounds().."\c-, "..wpn.SpareAmmo.."/"..wpn.GetMaxSpare(), pos, flags, Font.CR_WHITE); pos.y += FontHeight + 1;

		int MaxGiveAmount = flw.GetMaxGiveAmount(wpn);
		string AmmoString = (MaxGiveAmount > 0 ? "\c[Green]" : "\c[Red]").."+"..MaxGiveAmount.." "..wpn.GetAmmoName().."\c-";
		sb.DrawString(fnt, AmmoString, pos, flags, Font.CR_WHITE);
	}

	// ----------------------------------------------------------
	// INPUT
	// ----------------------------------------------------------

	override bool InputProcess(InputEvent e)
	{
		if (FollowerMenuLevel[consoleplayer] > 0 && e.Type == InputEvent.Type_KeyDown)
		{
			int NumKey = e.KeyChar - 48;
			if (NumKey == 0)
			{
				NumKey = 10;
			}

			switch (FollowerMenuLevel[consoleplayer])
			{
				case FMenu_Followers:
					if (NumKey > 0 && NumKey - 1 < Followers.Size())
					{
						SendNetworkEvent("HDF_SelectFollower", NumKey - 1);
					}
					break;

				case FMenu_Main:
					if (SelFollower[consoleplayer].Health <= 0)
					{
						Array<FollowerCommand> Commands;
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						if (SelFollower[consoleplayer].ResurrectType & HDFollower.RESF_BLUES)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 0));
						}
						if (SelFollower[consoleplayer].ResurrectType & HDFollower.RESF_BLOOD)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 1));
						}
						Commands.Push(CreateCommand("HDF_CollectBrass"));
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}

						if (NumKey > 0 && NumKey - 1 < Commands.Size())
						{
							FollowerCommand cmd = Commands[NumKey - 1];
							SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
						}
					}
					else if (SelFollower[consoleplayer].bFRIENDLY)
					{
						Array<FollowerCommand> Commands;
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Orders));
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Weapons));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Supplies));
						Commands.Push(CreateCommand("HDF_TryArmor"));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Miscellaneous));
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}
						
						if (NumKey > 0 && NumKey - 1 < Commands.Size())
						{
							FollowerCommand cmd = Commands[NumKey - 1];
							SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
						}
					}
					break;
					
				case FMenu_Orders:
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_ChangeOrders", FOrder_Follow); break;
						case 2: SendNetworkEvent("HDF_ChangeOrders", FOrder_FollowIgnore); break;
						case 3: SendNetworkEvent("HDF_ChangeOrders", FOrder_Cover); break;
						case 4: SendNetworkEvent("HDF_ChangeOrders", FOrder_GoAndCover); break;
						case 5: SendNetworkEvent("HDF_ChangeOrders", FOrder_ComeAndHelp); break;
						case 6: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main); break;
					}
					break;

				case FMenu_Weapons:
					if (NumKey == (SelFollower[consoleplayer].Weapons.Size() + 1) % 10)
					{
						SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main);
					}
					else
					{
						SendNetworkEvent("HDF_GiveAmmo", NumKey - 1);
					}
					break;

				case FMenu_Supplies:
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_GiveSupplies", 0); break;
						case 2: SendNetworkEvent("HDF_GiveSupplies", 1); break;
						case 3: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main); break;
					}
					break;

				case FMenu_Miscellaneous:
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_CollectBrass"); break;
						case 2: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main); break;
					}
					break;
			}

			// [Ace] Block 0-9 keys from affecting the world.
			if (NumKey >= 0 && NumKey <= 9)
			{
				return true;
			}

			// [Ace] Exit.
			int Key1, Key2;
			[Key1, Key2] = Bindings.GetKeysForCommand("HDF_OpenMenu");
			if (e.KeyScan == Key1 || e.KeyScan == Key2)
			{
				SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
				return true;
			}
		}
		return false;
	}

	// [Ace] The only reason this is used is to allow dynamic menus with a variable number of options. That's literally the only reason.
	ui FollowerCommand CreateCommand(string evName, int arg1 = 0, int arg2 = 0, int arg3 = 0)
	{
		let Command = new('FollowerCommand');
		Command.EventName = evName;
		Command.Args[0] = arg1;
		Command.Args[1] = arg2;
		Command.Args[2] = arg3;
		return Command;
	}

	// ----------------------------------------------------------
	// COMMANDS
	// ----------------------------------------------------------

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "HDF_ResetFollower" && e.Args[0] > 0)
		{
			Array<class<HDFollower> > FollowerClasses;

			// [Ace] Find all follower classes first.
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				if (AllActorClasses[i] is 'HDFollower' && AllActorClasses[i].GetClassName() != 'HDFollower')
				{
					FollowerClasses.Push((class<HDFollower>)(AllActorClasses[i]));
				}
			}

			int FollowerIndex = e.Args[0];

			// [Ace; 23.03.2021]
			// The problem with FollowerIndex, in hindsight, is that if two followers shame the same index, only the first one would get deleted.
			// I should have used class name for filtering. Unfortunately, it's too late. Not without breaking all of the existing follower sub-addons. Ah well.

			// [Ace] Destroy the class that is being reset, if applicable, then recreate it.
			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].Index == FollowerIndex)
				{
					RemoveFollower(Followers[i]);
					break;
				}
			}
			for (int i = 0; i < FollowerClasses.Size(); ++i)
			{
				if (GetDefaultByType(FollowerClasses[i]).Index == FollowerIndex)
				{
					CreateFollower(FollowerClasses[i], e.Player);
					break;
				}
			}
			return;
		}

		if (Followers.Size() == 0)
		{
			return;
		}

		// [Ace] This is an obvious cheat, so don't use it unless you absolutely HAVE to.
		if (e.Name ~== "HDF_WarpToPlayer")
		{
			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].Index == e.Args[0])
				{
					Followers[i].WarpToPlayer();
					break;
				}
			}
			return;
		}

		// [Ace] Always allow to open the follower menu to the first page or close it.
		if (e.Name ~== "HDF_SetFollowerMenu")
		{
			if (e.Args[0] == FMenu_Closed)
			{
				FollowerMenuLevel[e.Player] = FMenu_Closed;
				return;
			}
			else if (e.Args[0] == FMenu_Followers)
			{
				let plr = HDPlayerPawn(players[e.Player].mo);
				let AimedFollower = HDFollower(plr.AimTarget());
				if (AimedFollower && e.IsManual)
				{
					SelFollower[e.Player] = AimedFollower;
					FollowerMenuLevel[e.Player] = FMenu_Main;
					AimedFollower.ChangeLinkedPlayer(plr);
				}
				else if (Followers.Size() == 1 && Followers[0].CanInteractWith())
				{
					SelFollower[e.Player] = Followers[0];
					FollowerMenuLevel[e.Player] = FMenu_Main;
					SelFollower[e.Player].ChangeLinkedPlayer(plr);
				}
				else
				{
					FollowerMenuLevel[e.Player] = FMenu_Followers;
				}
			}
			else if (SelFollower[e.Player])
			{
				FollowerMenuLevel[e.Player] = e.Args[0];
			}
			return;
		}

		if (e.Name ~== "HDF_SelectFollower")
		{
			SelFollower[e.Player] = Followers[e.Args[0]];
			if (SelFollower[e.Player].CanInteractWith())
			{
				FollowerMenuLevel[e.Player] = FMenu_Main;
				SelFollower[e.Player].ChangeLinkedPlayer(HDPlayerPawn(players[e.Player].mo));
			}
			return;
		}

		if (!SelFollower[e.Player] || !SelFollower[e.Player].CanInteractWith())
		{
			return;
		}

		// [Ace] These commands cannot be used if alive and hostile.
		if (e.Name ~== "HDF_CarryFollower")
		{
			if (SelFollower[e.Player].PackFollower())
			{
				FollowerMenuLevel[e.Player] = FMenu_Closed;
			}
			return;
		}

		if (e.Name ~== "HDF_TryRevive")
		{
			if (SelFollower[e.Player].TryRevive(e.Args[0]))
			{
				FollowerMenuLevel[e.Player] = FMenu_Closed;
			}
			return;
		}

		if (e.Name ~== "HDF_CollectBrass")
		{
			if (SelFollower[e.Player].TryCollectBrass())
			{
				FollowerMenuLevel[e.Player] = FMenu_Closed;
			}
			return;
		}

		if (e.Name ~== "HDF_GiveAmmo")
		{
			SelFollower[e.Player].TryGiveAmmo(e.Args[0]);
			return;
		}

		if (e.Name ~== "HDF_TryArmor")
		{
			SelFollower[e.Player].TryUseArmor();
			FollowerMenuLevel[e.Player] = FMenu_Closed;
			return;
		}

		if (e.Name ~== "HDF_GiveSupplies")
		{
			switch (e.Args[0])
			{
				case 0: SelFollower[e.Player].TryGiveMedikit(); break;
				case 1: SelFollower[e.Player].TryGiveStimpack(); break;
			}
			return;
		}

		if (e.Name ~== "HDF_ChangeOrders")
		{
			if (SelFollower[e.Player].ChangeOrders(e.Args[0]))
			{
				FollowerMenuLevel[e.Player] = FMenu_Closed;
			}
			return;
		}
	}

	// ----------------------------------------------------------
	// INFORMATION
	// ----------------------------------------------------------

	int FollowingFollowersCount()
	{
		int Total = 0;
		for (int i = 0; i < Followers.Size(); ++i)
		{
			if (Followers[i].Health > 0 && (Followers[i].Order == FOrder_Follow || Followers[i].Order == FOrder_FollowIgnore))
			{
				Total++;
			}
		}
		return Total;
	}
}