class FollowerData play
{
	class<HDFollower> FollowerClass;
	uint Index;
	uint Squad;

	string Tag;
	int Gender;
	string Sounds[3];
	int SpriteTranslation;

	int Health;

	// Bleeding thinker stuff.
	bool IsBleeding;
	int BleedPoints;
	int BleedRate;
	Actor Source;

	int BodyDamage;
	bool Incapped;
	int Bloodloss;
	int Stunned;
	int BloodReviveTicker;

	Array<FollowerWeapon> Weapons;
	InventorySlot Slots[HDFollower.SlotCount];

	int SuturesLeft;
	int Order;

	int ArmorDurability;
	bool ArmorMega;

	class<HDMagicShield> ShieldClass;
	int Shields;
	int MaxShields;
	int ShieldStrength;
	bool RegenerateShields;
	bool NoShieldsDegeneration;

	double ExtraBulk;
}

extend class HDFollower
{
	bool PackFollower(bool force = false)
	{
		if (LinkedPlayer.CountInv(DataClass) == GetDefaultByType(DataClass).MaxAmount)
		{
			ThinkMessage(LinkedPlayer, "$CARRY_TOOMANY_PLR");
			return false;
		}

		if (!force)
		{
			switch (CanReach(PlayerIsProne() && max(0, LinkedPlayer.pos.z - pos.z) > 0 ? height + HDCONST_ONEMETRE * 1.4 : radius + HDCONST_ONEMETRE * 0.75))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return false;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return false;
			}

			PrintMessage(GetResponse("CARRY_SUCCESS"), "Carry/Success", PMType_General);
		}

		let Handler = FollowerHandler(EventHandler.Find("FollowerHandler"));
		Handler.Followers.Delete(Handler.Followers.Find(self));

		let data = new('FollowerData');
		LinkedPlayer.A_GiveInventory(DataClass);
		let FBody = FollowerBody(LinkedPlayer.FindInventory(DataClass));

		data.FollowerClass = GetClass();
		data.Index = Index;
		data.Squad = Squad;

		data.Tag = GetTag();
		data.Gender = Gender;
		data.Sounds[0] = SeeSound;
		data.Sounds[1] = PainSound;
		data.Sounds[2] = DeathSound;
		data.SpriteTranslation = self.Translation;

		for (int i = 0; i < Weapons.Size(); ++i)
		{
			data.Weapons.Push(Weapons[i]);
		}

		for (int i = 0; i < SlotCount; ++i)
		{
			data.Slots[i] = Slots[i];
		}

		if (!force)
		{
			data.Health = Health;
			data.Bloodloss = Bloodloss;
			data.Stunned = Stunned;
			data.BodyDamage = BodyDamage;
			data.BloodReviveTicker = BloodReviveTicker;
			data.Incapped = InStateSequence(CurState, FindState('Falldown'));

			HDBleedingWound BleedThinker = GetBleedThinker();
			if (BleedThinker)
			{
				data.IsBleeding = true;
				data.BleedPoints = BleedThinker.BleedPoints;
				data.BleedRate = BleedThinker.BleedRate;
				data.Source = BleedThinker.Source;
			}
		}
		else // [Ace] If it's forced, it means it's level end. In that case heal everything. This also only works if they're alive because you have to pick them up manually if they're dead.
		{
			FBody.NoExitDrop = true;
			data.Health = default.Health;
			data.Bloodloss = 0;
			data.Stunned = 0;
			data.BodyDamage = 0;
			data.Incapped = false;
		}

		data.SuturesLeft = SuturesLeft;
		data.Order = Order;

		let Armor = HDArmourWorn(FindInventory("HDArmourWorn"));
		if (Armor)
		{
			data.ArmorDurability = Armor.Durability;
			data.ArmorMega = Armor.Mega;
		}

		let sld = FindInventory('HDMagicShield', true);
		if (sld)
		{
			data.ShieldClass = (class<HDMagicShield>)(sld.GetClass());
			data.Shields = sld.Amount;
			data.MaxShields = sld.MaxAmount;
			data.ShieldStrength = sld.Stamina;
			data.RegenerateShields = sld.bQUICKTORETALIATE;
			data.NoShieldsDegeneration = sld.bSTANDSTILL;
		}

		let bpack = Find('HDBackpack');
		if (bpack)
		{
			data.ExtraBulk += bpack.Storage.TotalBulk * 0.70;
		}

		FBody.Data.Push(data);
		Destroy();
		return true;
	}

	// [Ace] These are still here because they don't get restored immediately.
	// Restoration happens in HDFollower::PostBeginPlay();
	int NewBloodloss;
	int NewStunned;
	int NewBodyDamage;

	class<HDMagicShield> ShieldClass;
	int Shields;
	int MaxShields; // [Ace] Intentional hiding of HDMobBase variable.
	int ShieldStrength;
	bool RegenerateShields;
	bool NoShieldsDegeneration;
}

// [Ace] This is perhaps the only useful use of an inventory item.
// Can't use a variable in EventHandler because it gets reset on map start, and can't use a variable in StaticEventHandler because it's not saved to save games.
// Could use a static Thinker, but then the follower would be weightless.
class FollowerBody : HDPickup abstract
{
	override void DoEffect()
	{
		if (!owner)
		{
			Destroy();
			return;
		}
		
		let plr = HDPlayerPawn(owner);
		if (plr && plr.incapacitated > 0 && !NoExitDrop && !AlreadyTried)
		{
			FromIncap = true;
			plr.UseInventory(self);
		}
		Super.DoEffect();
	}

	override double GetBulk()
	{
		double total = 0;
		for (int i = 0; i < Data.Size(); ++i)
		{
			total += default.Bulk + Data[i].ExtraBulk;
		}
		return total;
	}

	Array<FollowerData> Data;
	bool NoExitDrop; // [Ace] Don't drop if level is exited in incap.
	bool FromIncap;
	bool AlreadyTried;

	Default
	{
		-HDPICKUP.DROPTRANSLATION
		-HDPICKUP.FITSINBACKPACK
		+HDPICKUP.CHEATNOGIVE
		+HDPICKUP.NOTINPOCKETS
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
		HDPickup.Bulk 500;
		Inventory.MaxAmount 1;
	}

	States
	{
		Use:
			TNT1 A 0
			{
				FollowerData data = invoker.Data[invoker.Data.Size() - 1];

				bool ReturnValue = false;
				for (int i = 0; i < 100; ++i)
				{
					Actor a; bool success;

					int Distance = random(20, 48);
					int RandAngle = invoker.FromIncap || level.time < 2 ? random(0, 359) : 0;
					vector3 dest = Vec3Angle(Distance, angle + RandAngle);
					Sector sec = level.PointInSector(dest.xy);
					if (sec && pos.z - sec.NextLowestFloorAt(dest.x, dest.y, dest.z) > GetDefaultByType(data.FollowerClass).MaxStepHeight || !level.IsPointInLevel(dest))
					{
						if (invoker.FromIncap || level.time < 2)
						{
							continue;
						}
						else
						{
							break;
						}
					}

					[success, a] = A_SpawnItemEx(data.FollowerClass, Distance, 0, random(8, 16), angle: RandAngle);

					if (success)
					{
						let Follower = HDFollower(a);
						Follower.Index = data.Index;
						
						let Handler = FollowerHandler(EventHandler.Find("FollowerHandler"));
						Handler.InsertFollower(Follower);

						Follower.ChangeLinkedPlayer(HDPlayerPawn(self));

						Follower.Squad = data.Squad;
						Follower.SetTag(data.Tag);
						Follower.Gender = data.Gender;
						Follower.SeeSound = data.Sounds[0];
						Follower.PainSound = data.Sounds[1];
						Follower.DeathSound = data.Sounds[2];
						Follower.Translation = data.SpriteTranslation;

						Follower.Health = data.Health;
						Follower.Order = data.Order;

						// [Ace] These aren't even transferred properly because the monsters' PostBeginPlay() calls ResetDamageCounters().
						// This is needed so that they are.
						Follower.NewBloodloss = data.Bloodloss;
						Follower.NewStunned = data.Stunned;
						Follower.NewBodyDamage = data.BodyDamage;

						Follower.ShieldClass = data.ShieldClass;
						Follower.Shields = data.Shields;
						Follower.MaxShields = data.MaxShields;
						Follower.ShieldStrength = data.ShieldStrength;
						Follower.RegenerateShields = data.RegenerateShields;
						Follower.NoShieldsDegeneration = data.NoShieldsDegeneration;

						Follower.Weapons.Move(data.Weapons);
						for (int i = 0; i < Follower.Weapons.Size(); ++i)
						{
							Follower.Weapons[i].Owner = Follower;
						}
						for (int i = 0; i < HDFollower.SlotCount; ++i)
						{
							Follower.Slots[i] = data.Slots[i];
						}
						
						Follower.SuturesLeft = data.SuturesLeft;

						if (data.ArmorDurability > 0)
						{
							let Armor = HDArmourWorn(Follower.GiveInventoryType('HDArmourWorn'));
							Armor.Durability = data.ArmorDurability;
							Armor.Mega = data.ArmorMega;
						}

						if (data.IsBleeding)
						{
							HDBleedingWound.Inflict(Follower, data.BleedPoints, data.BleedRate, false, data.Source);
						}

						if (data.Incapped)
						{
							Follower.SetStateLabel('Falldown');
						}

						if (data.Health <= 0)
						{
							Follower.bPUSHABLE = false;
							Follower.DeathSound = "";
							Follower.SetStateLabel('Death');
							Follower.bCORPSE = true;
							Follower.Status = FStatus_InactiveOrDead;
						}

						Follower.BloodReviveTicker = data.BloodReviveTicker;

						invoker.Data.Pop();
						ReturnValue = true;
						break;
					}
				}

				if (!ReturnValue)
				{
					HDFollower.ThinkMessage(self, "$CARRY_CANTDROP_PLR");
					if (invoker.FromIncap)
					{
						invoker.AlreadyTried = true;
					}
				}
				
				return ReturnValue;
			}
			Stop;
	}
}