class FollowerData play
{
	class<HDFollower> FollowerClass;
	uint Index;

	string Tag;
	int Gender;
	string Sounds[3];
	int SpriteTranslation;

	int Health;

	// Bleeding thinker stuff.
	bool IsBleeding;
	int BleedPoints;
	int BleedRate;
	Actor Source;

	int BodyDamage;
	bool Incapped;
	int Bloodloss;
	int Stunned;
	int BloodReviveTicker;

	Array<FollowerWeapon> Weapons;
	InventorySlot Slots[HDFollower.SlotCount];

	int SuturesLeft;
	int Order;

	int ArmorDurability;
	bool ArmorMega;

	class<HDMagicShield> ShieldClass;
	int Shields;
	int MaxShields;
	int ShieldStrength;
	bool RegenerateShields;
	bool NoShieldsDegeneration;
}

extend class HDFollower
{
	bool PackFollower(bool force = false)
	{
		if (LinkedPlayer.CountInv(DataClass) == GetDefaultByType(DataClass).MaxAmount)
		{
			ThinkMessage(LinkedPlayer, "$CARRY_TOOMANY_PLR");
			return false;
		}

		if (!force)
		{
			switch (CanReach(PlayerIsProne() && max(0, LinkedPlayer.pos.z - pos.z) > 0 ? height + HDCONST_ONEMETRE * 1.4 : radius + HDCONST_ONEMETRE * 0.75))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return false;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return false;
			}

			PrintMessage(GetResponse("CARRY_SUCCESS"), "Carry/Success", PMType_General);
		}

		let Handler = FollowerHandler(EventHandler.Find("FollowerHandler"));
		Handler.Followers.Delete(Handler.Followers.Find(self));

		let FData = new('FollowerData');
		LinkedPlayer.A_GiveInventory(DataClass);
		let FBody = FollowerBody(LinkedPlayer.FindInventory(DataClass));

		FData.FollowerClass = GetClass();
		FData.Index = Index;

		FData.Tag = GetTag();
		FData.Gender = Gender;
		FData.Sounds[0] = SeeSound;
		FData.Sounds[1] = PainSound;
		FData.Sounds[2] = DeathSound;
		FData.SpriteTranslation = self.Translation;

		for (int i = 0; i < Weapons.Size(); ++i)
		{
			FData.Weapons.Push(Weapons[i]);
		}

		for (int i = 0; i < SlotCount; ++i)
		{
			FData.Slots[i] = Slots[i];
		}

		if (!force)
		{
			FData.Health = Health;
			FData.Bloodloss = Bloodloss;
			FData.Stunned = Stunned;
			FData.BodyDamage = BodyDamage;
			FData.BloodReviveTicker = BloodReviveTicker;
			FData.Incapped = InStateSequence(CurState, FindState('Falldown'));

			HDBleedingWound BleedThinker = GetBleedThinker();
			if (BleedThinker)
			{
				FData.IsBleeding = true;
				FData.BleedPoints = BleedThinker.BleedPoints;
				FData.BleedRate = BleedThinker.BleedRate;
				FData.Source = BleedThinker.Source;
			}
		}
		else // [Ace] If it's forced, it means it's level end. In that case heal everything. This also only works if they're alive because you have to pick them up manually if they're dead.
		{
			FBody.NoExitDrop = true;
			FData.Health = default.Health;
			FData.Bloodloss = 0;
			FData.Stunned = 0;
			FData.BodyDamage = 0;
			FData.Incapped = false;
		}

		FData.SuturesLeft = SuturesLeft;
		FData.Order = Order;

		let Armor = HDArmourWorn(FindInventory("HDArmourWorn"));
		if (Armor)
		{
			FData.ArmorDurability = Armor.Durability;
			FData.ArmorMega = Armor.Mega;
		}

		let Shields = FindInventory('HDMagicShield', true);
		if (Shields)
		{
			FData.ShieldClass = (class<HDMagicShield>)(Shields.GetClass());
			FData.Shields = Shields.Amount;
			FData.MaxShields = Shields.MaxAmount;
			FData.ShieldStrength = Shields.Stamina;
			FData.RegenerateShields = Shields.bQUICKTORETALIATE;
			FData.NoShieldsDegeneration = Shields.bSTANDSTILL;
		}

		FBody.Data.Push(FData);
		Destroy();
		return true;
	}

	// [Ace] These are still here because they don't get restored immediately.
	// Restoration happens in HDFollower::PostBeginPlay();
	int NewBloodloss;
	int NewStunned;
	int NewBodyDamage;

	class<HDMagicShield> ShieldClass;
	int Shields;
	int ShieldStrength;
	bool RegenerateShields;
	bool NoShieldsDegeneration;
}

// [Ace] This is perhaps the only useful use of an inventory item.
// Can't use a variable in EventHandler because it gets reset on map start, and can't use a variable in StaticEventHandler because it's not saved to save games.
// Could use a static Thinker, but then the follower would be weightless.
class FollowerBody : HDPickup abstract
{
	override void DoEffect()
	{
		if (!owner)
		{
			Destroy();
			return;
		}
		
		let plr = HDPlayerPawn(owner);
		if (plr && plr.incapacitated > 0 && !NoExitDrop && !AlreadyTried)
		{
			FromIncap = true;
			plr.UseInventory(self);
		}
		Super.DoEffect();
	}

	Array<FollowerData> Data;
	bool NoExitDrop; // [Ace] Don't drop if level is exited in incap.
	bool FromIncap;
	bool AlreadyTried;

	Default
	{
		-HDPICKUP.DROPTRANSLATION
		-HDPICKUP.FITSINBACKPACK
		+HDPICKUP.CHEATNOGIVE
		+HDPICKUP.NOTINPOCKETS
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
		HDPickup.Bulk 500;
		Inventory.MaxAmount 1;
	}

	States
	{
		Use:
			TNT1 A 0
			{
				FollowerData FData = invoker.Data[invoker.Data.Size() - 1];

				bool ReturnValue = false;
				for (int i = 0; i < 100; ++i)
				{
					Actor a; bool success;

					int Distance = random(20, 48);
					int RandAngle = invoker.FromIncap || level.time < 2 ? random(0, 359) : 0;
					vector3 dest = Vec3Angle(Distance, angle + RandAngle);
					Sector sec = level.PointInSector(dest.xy);
					if (sec && pos.z - sec.NextLowestFloorAt(dest.x, dest.y, dest.z) > GetDefaultByType(FData.FollowerClass).MaxStepHeight || !level.IsPointInLevel(dest))
					{
						if (invoker.FromIncap || level.time < 2)
						{
							continue;
						}
						else
						{
							break;
						}
					}

					[success, a] = A_SpawnItemEx(FData.FollowerClass, Distance, 0, random(8, 16), angle: RandAngle);

					if (success)
					{
						let Follower = HDFollower(a);
						Follower.Index = FData.Index;
						
						let Handler = FollowerHandler(EventHandler.Find("FollowerHandler"));
						Handler.InsertFollower(Follower);

						Follower.ChangeLinkedPlayer(HDPlayerPawn(self));

						Follower.SetTag(FData.Tag);
						Follower.Gender = FData.Gender;
						Follower.SeeSound = FData.Sounds[0];
						Follower.PainSound = FData.Sounds[1];
						Follower.DeathSound = FData.Sounds[2];
						Follower.Translation = FData.SpriteTranslation;

						Follower.Health = FData.Health;
						Follower.Order = FData.Order;

						// [Ace] These aren't even transferred properly because the monsters' PostBeginPlay() calls ResetDamageCounters().
						// This is needed so that they are.
						Follower.NewBloodloss = FData.Bloodloss;
						Follower.NewStunned = FData.Stunned;
						Follower.NewBodyDamage = FData.BodyDamage;

						Follower.ShieldClass = FData.ShieldClass;
						Follower.Shields = FData.Shields;
						Follower.MaxShields = FData.MaxShields;
						Follower.ShieldStrength = FData.ShieldStrength;
						Follower.RegenerateShields = FData.RegenerateShields;
						Follower.NoShieldsDegeneration = FData.NoShieldsDegeneration;

						Follower.Weapons.Move(FData.Weapons);
						for (int i = 0; i < Follower.Weapons.Size(); ++i)
						{
							Follower.Weapons[i].Owner = Follower;
						}
						for (int i = 0; i < HDFollower.SlotCount; ++i)
						{
							Follower.Slots[i] = FData.Slots[i];
						}
						
						Follower.SuturesLeft = FData.SuturesLeft;

						if (FData.ArmorDurability > 0)
						{
							let Armor = HDArmourWorn(Follower.GiveInventoryType('HDArmourWorn'));
							Armor.Durability = FData.ArmorDurability;
							Armor.Mega = FData.ArmorMega;
						}

						if (FData.IsBleeding)
						{
							HDBleedingWound.Inflict(Follower, FData.BleedPoints, FData.BleedRate, false, FData.Source);
						}

						if (FData.Incapped)
						{
							Follower.SetStateLabel('Falldown');
						}

						if (FData.Health <= 0)
						{
							Follower.bPUSHABLE = false;
							Follower.DeathSound = "";
							Follower.SetStateLabel('Death');
							Follower.bCORPSE = true;
							Follower.Status = FStatus_InactiveOrDead;
						}

						Follower.BloodReviveTicker = FData.BloodReviveTicker;

						invoker.Data.Pop();
						ReturnValue = true;
						break;
					}
				}

				if (!ReturnValue)
				{
					HDFollower.ThinkMessage(self, "$CARRY_CANTDROP_PLR");
					if (invoker.FromIncap)
					{
						invoker.AlreadyTried = true;
					}
				}
				
				return ReturnValue;
			}
			Stop;
	}
}