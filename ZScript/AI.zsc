enum FStatus
{
	FStatus_None,
	FStatus_HealingSelf,
	FStatus_HealingPlayer,
	FStatus_WaitingForArmor,
	FStatus_WaitingForWeapon,
	FStatus_InactiveOrDead
}

extend class HDFollower
{
	enum BlockedSide
	{
		BSide_Left = 1,
		BSide_Right = 2
	}

	// --------------------------------------------------
	// ACTIONS
	// --------------------------------------------------

	protected void AiThink()
	{
		if (Status == FStatus_InactiveOrDead || InStateSequence(CurState, FindState("Spawn"))) // [Ace] I don't remember why the Spawn state check...
		{
			return;
		}

		int blockedSides = GetBlockedSides();

		Actor next = GetNextInChain();
		bool canSeeNext = CheckSight(next, SF_SEEPASTSHOOTABLELINES | SF_IGNOREVISIBILITY);
		if (!canSeeNext && (!TGoal || (blockedSides & (BSide_Left | BSide_Right))) && CanSeePlayer)
		{
			next = LinkedPlayer;
			canSeeNext = true;
		}

		// Console.Printf("%s (index %i) has %s out.\nCurrent status is %i.\nFollower is targeting %s. Follower following %s.\n--------------------",
		// 	GetTag(),
		// 	Index,
		// 	SelWeapon ? SelWeapon.GetName() : "no weapon",
		// 	Status, CTarget ? CTarget.GetTag() : "nothing",
		// 	next is 'HDFollower' ? HDFollower(next).GetTag() : (next ? next.GetTag() : "nothing"));
		
		pNeedsHelp = PlayerIsIncapped(); // [Ace] You're just incapped.
		pNeedsMedic = PlayerNeedsMedic(); // [Ace] You're bleeding and incapped.
		int ffcount = Handler.FollowingFollowersCount();
		int findex = Handler.Followers.Find(self);
		double distDiv = next != LinkedPlayer ? 1.0 + 0.13 * (min(8, ffcount - 1)) : 1.0;
		
		if (!SelWeapon)
		{
			if (Order == FOrder_HealSelf && !Moving && Status != FStatus_HealingSelf)
			{
				Status = FStatus_HealingSelf;
				SetStateLabel('StapleOwnAss');
			}

			if (Status >= FStatus_WaitingForArmor && Status <= FStatus_WaitingForWeapon)
			{
				if (Distance3D(LinkedPlayer) > MaxWaitRange)
				{
					switch (Status)
					{
						case FStatus_WaitingForArmor: PrintMessage(GetResponse("ARMORGIVE_RANAWAY"), "ArmorGive/RanAway", PMType_Critical); break;
						case FStatus_WaitingForWeapon: PrintMessage(GetResponse("WEAPONGIVE_RANAWAY"), "WeaponGive/RanAway", PMType_Critical); break;
					}
					Status = FStatus_None;
				}
				else
				{
					switch (Status)
					{
						case FStatus_WaitingForArmor: LookForArmor(); break;
						case FStatus_WaitingForWeapon: LookForWeapon(); break;
					}
					A_Face(LinkedPlayer, 15);
				}
			}
		}

		if (Status == FStatus_None)
		{
			if (!SelWeapon || SelWeapon.Status < FollowerWeapon.WStatus_Firing)
			{
				bNOPAIN = false;

				if (!Moving && !IsInIdleState())
				{
					SetStateLabel('Idle');
				}
				else if (Moving && !IsInMovingState())
				{
					SetStateLabel('Moving');
				}
			}

			if (Order == FOrder_ComeAndHelp && bFRIENDLY && DistanceToPlayer < 512 && CanSeePlayer)
			{
				if (DistanceToPlayer < MedicRange && Status != FStatus_HealingPlayer) // [Ace] Start stapling if close enough. Minimum distance is 22. Don't go any lower or follower will be stuck walking towards you.
				{
					if (pNeedsMedic)
					{
						Status = FStatus_HealingPlayer;
						SetStateLabel('StapleHumptyDumptyBackTogetherAgain');
					}
					else if (pNeedsHelp)
					{
						Status = FStatus_HealingPlayer;
						SetStateLabel('PullYouUp');
					}
					else
					{
						Order = FOrder_Follow;
					}
				}
				else
				{
					TGoal = LinkedPlayer;
				}
			}
			else if (Order < FOrder_Cover)
			{
				if (canSeeNext)
				{
					LastKnownPos = next.Pos;
				}

				// [Ace] Go to goal if it's too far away.
				// !bSTANDSTILL means the follower will only chase goals if its current goal isn't forced.
				double DistanceToNext = Distance3D(next);
				if (bFRIENDLY && DistanceToNext > MinFollowRange / distDiv && DistanceToNext < MaxFollowRange && (!TGoal || TGoal && !TGoal.bSTANDSTILL))
				{
					if (canSeeNext)
					{
						TGoal = next;
					}
					// [Ace] If following the goal and the goal is nearby but suddenly goes around a corner, try to go around the same corner.
					else if (LastKnownPos != (0, 0, 0) && (!TGoal || TGoal && TGoal.pos != LastKnownPos))
					{
						TrySetGoal(LastKnownPos, SGF_IGNOREVALID | SGF_LASTKNOWN);
					}
				}

				if (!Moving && IsSteppingOnSomeone())
				{
					// [Ace] Spawn a new idle spot.
					for (int i = 0; i < 100; ++i)
					{
						vector3 SpotPos = Vec3Angle(random(16, 96), random(0, 359));
						if (TrySetGoal(SpotPos))
						{
							break;
						}
					}
				}
			}
			else if (Order == FOrder_Cover && DistanceToPlayer < HDCONST_ONEMETRE * 5)
			{
				A_Face(LinkedPlayer, 15);
			}

			if (hdf_collectbrass)
			{
				VacuumBrass();
			}

			// [Ace] Using potions.
			if (Order <= FOrder_Cover && !Moving && CanHealSelf() && GetAmount('BluePotion') > 0 && GetAge() % 24 == 0)
			{
				let potion = FindLowestAmount('BluePotion');
				potion.Amount--;

				int toHeal = default.Health / 4;
				HealSelf(toHeal);
				A_StartSound("potion/chug", 5);

				if (potion.Amount == 0)
				{
					TakeInvItem(potion, FIF_FORCE | FIF_REMOVE);
					A_StartSound("potion/open", 6);
					
					Actor a = Spawn("SpentBottle", pos + (0, 0, height- 4), ALLOW_REPLACE);
					a.angle = angle + 2;
					a.vel = vel;
					a.A_ChangeVelocity(3, 1, 4, CVF_RELATIVE);
					
					a = Spawn("SpentCork", pos + (0, 0, height - 4) , ALLOW_REPLACE);
					a.angle = angle + 3;
					a.vel = vel;
					a.A_ChangeVelocity(5, 3, 4, CVF_RELATIVE);
				}
			}

			// [Ace] Walk away if you get too close.
			if (!Moving && DistanceToPlayer <= HDCONST_ONEMETRE / 2 + radius + LinkedPlayer.radius && GetPlayerMovementAngle() <= MaxMovementAngle && LinkedPlayer.vel.xy.length() > 1.5 && !(LinkedPlayer.player.ReadyWeapon is 'HDMedikitter') && !(LinkedPlayer.player.ReadyWeapon is 'SelfBandage'))
			{
				TrySetGoal(Vec3Angle(HDCONST_ONEMETRE * 1.5, AngleTo(LinkedPlayer) + 180), SGF_IGNOREVALID | SGF_MOVEAWAY);
			}

			// [Ace] Mutually put out any fires.
			for (int i = 0; i < Handler.Followers.Size(); ++i)
			{
				if (Handler.Followers[i] != self && self.Distance3D(Handler.Followers[i]) <= HDCONST_ONEMETRE)
				{
					A_GiveInventory('HDFireDouse', 3);
					Handler.Followers[i].A_GiveInventory('HDFireDouse', 3);
				}
			}
			if (DistanceToPlayer <= HDCONST_ONEMETRE)
			{
				A_GiveInventory('HDFireDouse', 3);
				LinkedPlayer.A_GiveInventory('HDFireDouse', 3);
			}
		}

		// [Ace] Enemy searching and weapon handling.
		if (Weapons.Size() > 0)
		{
			if (HasUsableWeapons() && (!SelWeapon || SelWeapon.Status == FollowerWeapon.WStatus_Idle) && (!bFRIENDLY || Order != FOrder_FollowIgnore && Order != FOrder_GoAndCover))
			{
				AcquireTargets();
			}

			if (SelWeapon && SelWeapon.Status == FollowerWeapon.WStatus_Reloading)
			{
				if (SelWeapon.DoReloadSequence(WeaponTicker))
				{
					IdleWeapon();
				}
				else
				{
					ClearTarget(); // [Ace] Allow others to target the enemy if currently reloading.
					WeaponTicker++;
				}
			}
			else if (CheckTarget())
			{
				if ((!SelWeapon || SelWeapon.Status == FollowerWeapon.WStatus_Idle) && ReactionTime-- <= 0)
				{
					SelectBestWeapon(FTarget.Actor);
					if (SelWeapon && SelWeapon.Status == FollowerWeapon.WStatus_Idle)
					{
						bNOPAIN = true;
						SelWeapon.Status = FollowerWeapon.WStatus_Firing;
						SetStateLabel('See');
					}
					else
					{
						ClearTarget(); // [Ace] Allow others to target the enemy if suddenly out of weapons.
					}
				}
			}
			else
			{
				ClearTarget();
				ReactionTime = default.ReactionTime;
				if (SelWeapon && SelWeapon.Status == FollowerWeapon.WStatus_Idle)
				{
					if (hdf_debug & FDebug_Weapons)
					{
						Console.Printf("[%s] %s's %s was nulled. Was idling.", GetTimestamp(), GetTag(), SelWeapon.GetName());
					}
					SelWeapon = null;
				}
			}
		}

		// [Ace] Crouching. One day I will implement proper sprites for this. Today is not that day.
		if (bFRIENDLY && Status == FStatus_None && Order <= FOrder_Cover && PlayerIsCrouching() && CanSeePlayer && DistanceToPlayer < HDCONST_ONEMETRE * 30)
		{
			CrouchFactor = min(CrouchFactor + 0.14, 0.5);
		}
		else if (CrouchFactor > 0)
		{
			CrouchFactor = max(CrouchFactor - 0.10, 0);
		}

		scale.y = default.scale.y * (1.0 - CrouchFactor);
		A_SetSize(-1, default.Height * (1.0 - CrouchFactor));

		double goalDist2 = TGoal ? Distance2D(TGoal) : 0;

		// [Ace] Movement. Always travel to goals if there are any.
		bool dedicatedGoal = TGoal is 'TargetGoal';
		if (Status == FStatus_None && (!SelWeapon || SelWeapon.Status != FollowerWeapon.WStatus_Firing) && TGoal && (TGoal is next.GetClass() && goalDist2 > (Order == FOrder_ComeAndHelp && (pNeedsMedic || pNeedsHelp) ? MedicRange : (MinFollowRangeStop / distDiv)) || dedicatedGoal && goalDist2 > 16) && goalDist2 < MaxGoalRange)
		{
			// [Ace] Don't slow down if player is bleeding out their ass or needs help getting up.
			if (TGoal is "PlayerPawn" && Order == FOrder_ComeAndHelp && (pNeedsMedic || pNeedsHelp))
			{
				if (tics == 2)
				{
					tics = 1;
				}
				MovementSpeed = MaxMovementSpeed;
			}
			else
			{
				if (goalDist2 < (dedicatedGoal ? GoalRangeStop : MinFollowRangeStop))
				{
					MovementSpeed = max(default.MovementSpeed * 0.25, MovementSpeed * 0.85);
				}
				else
				{
					// [Ace] The tics adjustment is purely visual.
					if (tics == 2)
					{
						tics = 1;
					}
					MovementSpeed = min(default.MovementSpeed + goalDist2 / (HDCONST_ONEMETRE - 2 * min(ffcount - 1, 6)), MaxMovementSpeed);
				}
			}

			// [Ace] Same as the corner thing from above but does it if the follower is moving.
			A_Face(TGoal, 0, 0);

			int sideVel = 0;
			if (!(blockedSides & BSide_Left) && blockedSides & BSide_Right)
			{
				sideVel = 1;
			}
			if (blockedSides & BSide_Left && !(blockedSides & BSide_Right))
			{
				sideVel = -1;
			}
			A_ChangeVelocity(MovementSpeed, MovementSpeed * sideVel, vel.z, CVF_RELATIVE | CVF_REPLACE);
			Moving = true;

			// [Ace] Ascend/descend ladders.
			bool nearLadder = CheckProximity('hdladdertop', radius + 32) || CheckProximity('hdladderbottom', radius + 32);
			MaxDropOffHeight = default.MaxDropOffHeight + (NearLadder ? LADDER_MAX : 0);
			bFLOORHUGGER = nearLadder;

			// [Ace] There is a gap that can be crossed. If the player can do it, so can the follower.
			bNODROPOFF = !(goalDist2 < HDCONST_ONEMETRE * 10 && (pos.z > floorz || abs(TGoal.floorz - floorz) < default.MaxDropOffHeight) && abs(TGoal.pos.z - pos.z) < default.MaxDropOffHeight);

			// [Ace] Stop trying to reach goal shortly after losing LOS.
			if (!CheckSight(TGoal, SF_SEEPASTSHOOTABLELINES | SF_IGNOREVISIBILITY) && ++NoSightTics == 50)
			{
				NoSightTics = 0;
				ClearGoal();
			}

			// [Ace] Only play idle comments if moving.
			if (CommentTimer <= 0)
			{
				PlayIdleComment();
			}
		}
		else // [Ace] Deceleration.
		{
			vel.xy *= 0.98;

			if (Order == FOrder_GoAndCover && vel.xy.length() < 0.65)
			{
				Order = FOrder_Cover;
			}

			if (vel.xy.length() < 0.15)
			{
				ClearGoal(true);
				A_ChangeVelocity(0, 0, vel.z, CVF_REPLACE);
				Moving = false;
			}
		}
	}

	private void TryActivateLine()
	{
		FLineTraceData data;
		LineTrace(angle, 40, 0, 0, height - 8, data: data);
		if (data.HitType == FLineTraceData.TRACE_HitWall)
		{
			if (ActivateAsPlayer)
			{
				data.HitLine.Activate(LinkedPlayer, 0, SPAC_Use);
			}
			else
			{
				data.HitLine.Activate(self, 0, SPAC_Use);
			}
		}
		ActivateAsPlayer = false;
	}

	// --------------------------------------------------
	// INFORMATION
	// --------------------------------------------------

	private Actor GetNextInChain()
	{
		int findex = Handler.Followers.Find(self);
		for (int i = findex - 1; i >= 0; --i)
		{
			HDFollower flw = Handler.Followers[i];
			if (!flw)
			{
				Console.Printf("Somehow flw is null and how this would ever happen is a mystery.");
				return LinkedPlayer;
			}
			if (flw.Status != FStatus_InactiveOrDead && flw.bFRIENDLY && (flw.Order == FOrder_Follow || flw.Order == FOrder_FollowIgnore) && flw.LinkedPlayer == LinkedPlayer && Distance3D(flw) < MaxFollowRange)
			{
				return Handler.Followers[i];
			}
		}
		return LinkedPlayer;
	}

	bool IsInIdleState()
	{
		return InStateSequence(CurState, FindState('Idle'));
	}

	bool IsInMovingState()
	{
		return InStateSequence(CurState, FindState('Moving'));
	}

	bool IsSteppingOnSomeone()
	{
		if (bOnMobj)
		{
			if (Distance2D(LinkedPlayer) <= LinkedPlayer.Radius + Radius)
			{
				return true;
			}

			for (int i = 0; i < Handler.Followers.Size(); ++i)
			{
				if (Distance2D(Handler.Followers[i]) <= Handler.Followers[i].Radius + Radius)
				{
					return true;
				}
			}
		}

		return false;
	}

	int GetBlockedSides()
	{
		int sides = 0;
		FLineTraceData data;

		LineTrace(angle - 25, radius + 7, 0, TRF_SOLIDACTORS, height - 6, 0, -radius, data);
		if (data.HitLine || data.HitActor)
		{
			sides |= BSide_Left;
		}
		LineTrace(angle + 25, radius + 7, 0, TRF_SOLIDACTORS, height - 6, 0, radius, data);
		if (data.HitLine || data.HitActor)
		{
			sides |= BSide_Right;
		}
		
		return sides;
	}

	// --------------------------------------------------
	// CONSTANTS
	// --------------------------------------------------

	const GoalRangeStop = HDCONST_ONEMETRE * 0.8; // [Ace] Start decelerating if closer than this distance.
	const MinFollowRangeStop = HDCONST_ONEMETRE * 2.8; // [Ace] If following the player, stop if closer than this distance.
	const MinFollowRange = HDCONST_ONEMETRE * 3.6;
	const MaxFollowRange = HDCONST_ONEMETRE * 25.0;
	const MaxWaitRange = HDCONST_ONEMETRE * 12;
	const MaxSearchRange = 24; // [Ace] This is for the LookFor* stuff.

	// --------------------------------------------------
	// VARIABLES
	// --------------------------------------------------

	HDPlayerPawn LinkedPlayer;
	protected FollowerTarget FTarget;
	private Actor TGoal;

	private bool Moving;
	FStatus Status;
	FOrder Order;
	private FOrder PrevOrder;

	private vector3 LastKnownPos;

	private int CommentTimer;
	private bool ActivateAsPlayer;
	private int NoSightTics; // [Ace] Used with CheckSight.

	private bool CanSeePlayer;
	private double DistanceToPlayer;
	private bool pNeedsHelp;
	private bool pNeedsMedic;
	private double CrouchFactor;
}