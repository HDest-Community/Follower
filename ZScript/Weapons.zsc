extend class HDFollower
{
	enum CSFlags
	{
		CSF_FIRE	= 1 << 0,
		CSF_RELOAD	= 1 << 1,
		CSF_ALL		= CSF_FIRE | CSF_RELOAD
	}

	enum RLFlags
	{
		RLF_FORCE	= 1 << 0,
		RLF_MANUAL	= 1 << 1,
		RLF_SILENT	= 1 << 2,
		RLF_NOJUMP	= 1 << 3
	}

	virtual void InitWeapons()
	{
		int WeaponFlags = hdf_loadout_weapons;
		int StartingAmmoFlags = hdf_loadout_startingammo;

		static const string AllWeapons[] = { "FW_SMG", "FW_Hunter", "FW_ZM66", "FW_RocketLauncher", "FW_Liberator", "FW_Boss", "FW_Bronto" };
		for (int i = 0; i < AllWeapons.Size(); ++i)
		{
			class<FollowerWeapon> fw = AllWeapons[i];
			if (fw && WeaponFlags & (1 << i))
			{
				FollowerWeapon wpn = FollowerWeapon(new(fw));
				if (StartingAmmoFlags & (1 << i))
				{
					wpn.Init();
				}
				Weapons.Push(wpn);
			}
		}
	}

	private void ClearWeapon()
	{
		SelWeapon = null;
	}

	private int AdjustForDistance(double distance, double mult = 1.0) const
	{
		return int(clamp((distance / 64.0) * mult, 4, 70));
	}

	clearscope int GetMaxGiveAmount(FollowerWeapon wpn)
	{
		int MaxMag = wpn.GetMaxMag();
		return min(LinkedPlayer.CountInv(wpn.GetAmmoType()), (MaxMag > 0 ? MaxMag : 1), wpn.GetMaxSpare() - wpn.SpareAmmo);
	}

	clearscope FollowerWeapon FindWeapon(class<FollowerWeapon> wpn)
	{
		for (int i = 0; i < Weapons.Size(); ++i)
		{
			if (Weapons[i].GetClass() == wpn)
			{
				return Weapons[i];
			}
		}

		return null;
	}

	clearscope FollowerWeapon GetWeaponByIndex(int index)
	{
		int Size = Weapons.Size();
		if (index > -1 && Size > 0 && index < Size)
		{
			return Weapons[index];
		}

		return null;
	}

	// [Ace] It's an int because it's used in NetworkProcess.
	void TryGiveAmmo(int wpnIndex)
	{
		FollowerWeapon wpn = GetWeaponByIndex(wpnIndex);
		if (Status == FStatus_InactiveOrDead || !wpn)
		{
			return;
		}

		class<Inventory> AmmoType = wpn.GetAmmoType();
		int MaxGive = GetMaxGiveAmount(wpn);

		if (Distance3D(LinkedPlayer) > radius + MaxInventoryDistance)
		{
			TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL);
			ThinkMessage(LinkedPlayer, "$AMMOGIVE_FAR_PLR");
			return;
		}
		else if (wpn.SpareAmmo >= wpn.GetMaxSpare())
		{
			TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL);
			PrintMessage(GetResponse("$AMMOGIVE_"..wpn.GetName().."_TOOMANY"), "Follower/AmmoGive/"..wpn.GetName().."/TooMany");
			return;
		}
		else if (LinkedPlayer.CountInv(AmmoType) == 0)
		{
			TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL);
			ThinkMessage(LinkedPlayer, "$AMMOGIVE_NOTENOUGH_PLR");
			return;
		}

		LinkedPlayer.A_TakeInventory(AmmoType, MaxGive);
		wpn.SpareAmmo += MaxGive;
		wpn.HasWarnedLowAmmo = false;
		TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL);

		PrintMessage(GetResponse("$AMMOGIVE_"..wpn.GetName().."_SUCCESS"), "Follower/AmmoGive/"..wpn.GetName().."/Success");
	}

	// [Ace] If weapon is out of ammo, reload.
	protected void TryReloadWeapon(FollowerWeapon wpn, int min = 0, RLFlags flags = 0)
	{
		if (SelWeapon && !(flags & RLF_FORCE))
		{
			return;
		}

		int MaxMag = wpn.GetMaxMag();
		if (MaxMag > 0 && (wpn.Mag <= 0 || wpn.Mag < min) || MaxMag == 0 && wpn.ChamberedRound != FollowerWeapon.CRType_Chambered)
		{
			if (wpn.SpareAmmo > 0)
			{
				// Console.Printf("Trying to reload "..wpn.GetName()..".");
				SelWeapon = wpn;
				Status = FStatus_InCombat;
				SetStateLabel(wpn.GetReloadState());
			}
			else
			{
				// [Ace] Keep complaining if manual.
				if (!(flags & RLF_SILENT) && (!wpn.HasWarnedLowAmmo || (flags & RLF_MANUAL)))
				{
					wpn.HasWarnedLowAmmo = true;
					PrintMessage(GetResponse("$NOAMMO_"..wpn.GetName()), "Follower/NoAmmo/"..wpn.GetName());
				}

				if (!(flags & RLF_NOJUMP))
				{
					ClearWeapon();
					SetStateLabel("Idle");
				}
			}
		}
	}

	protected void EngageTarget(Array<class<FollowerWeapon> > wpns, Actor other)
	{
		// [Ace] This is used so that FindWeapon() isn't copy-pasted numerous times in the targeting code.
		Array<FollowerWeapon> ActualWeapons;
		for (int i = 0; i < wpns.Size(); ++i)
		{
			FollowerWeapon w = FindWeapon(wpns[i]);
			if (w)
			{
				ActualWeapons.Push(w);
			}
		}

		FollowerWeapon HighestWithSpare = null;
		FollowerWeapon HighestWithAmmo = null;
		SelWeapon = null;

		// [Ace] Find a weapon that has ammo in it. Start from the end and work backwards.
		for (int i = ActualWeapons.Size() - 1; i >= 0; --i)
		{
			// [Ace] Ignore weapons that don't fulfill the required condition. When it comes to, say, a rocket launcher, this is the check that makes sure you don't get blasted to bits by accident.
			if (!ActualWeapons[i].CheckWeaponCondition(self, LinkedPlayer, other))
			{
				continue;
			}

			int MaxMag = ActualWeapons[i].GetMaxMag();
			if (ActualWeapons[i].SpareAmmo > 0)
			{
				HighestWithSpare = ActualWeapons[i];
			}
			if (ActualWeapons[i].Mag > 0 || ActualWeapons[i].ChamberedRound == FollowerWeapon.CRType_Chambered)
			{
				HighestWithAmmo = ActualWeapons[i];
			}
		}

		if (HighestWithAmmo)
		{
			SelWeapon = HighestWithAmmo;
		}
		else if (HighestWithSpare)
		{
			SelWeapon = HighestWithSpare;
			TryReloadWeapon(SelWeapon, 0, RLF_SILENT | RLF_NOJUMP);
			Status = FStatus_InCombat;
			return;
		}
		
		if (other && SelWeapon)
		{
			CTarget = other;
			SetStateLabel("See");
		}
	}

	protected void Aim()
	{
		// [Ace] Stop aiming if target is no longer valid, weapon is deselected, or the condition is not met.
		if (!CheckTarget() || !SelWeapon || !SelWeapon.CheckWeaponCondition(self, LinkedPlayer, CTarget))
		{
			SetStateLabel("Idle");
			Status = FStatus_None;
			return;
		}

		A_Face(CTarget, 0, 0, flags: FAF_MIDDLE);

		// [Ace] If you're incapped, follower can probably shoot over you. Otherwise it's not a good idea.
		Actor ATarget = AimTarget();
		if (ATarget && bFRIENDLY && (ATarget is "PlayerPawn" || ATarget.bFRIENDLY))
		{
			AimTimer = 0;
			SetStateLabel("Aiming");
		}
	}

	protected FollowerWeapon SelWeapon;
	Array<FollowerWeapon> Weapons;

	private int AimTimer;
	
	States
	{
		See:
			#### HH 2
			{
				Status = FStatus_InCombat;
				AimTimer = 0;
			}
		Aiming:
			#### H 1; // [Ace] Otherwise it's gonna cause an infinite loop.
			#### H 1 Aim(); // [Ace] This is on this line and not inside the anonymous function because of SetStateLabel.
			#### H 0
			{
				if (AimTimer++ > AdjustForDistance(Distance3D(CTarget), SelWeapon.GetAdjustmentMult()))
				{
					// Console.Printf("Trying to fire "..SelWeapon.GetName().." at "..CTarget.GetTag()..".");
					AimTimer = 0;
					SetStateLabel(SelWeapon.GetFireState());
				}
			}
			Loop;

		// ----------------------------------------
		// SMG
		// ----------------------------------------

		ShootSMG:
			#### H 1 Aim();
			#### I 1
			{
 				if (SelWeapon.TryFireRound(true))
 				{
 					A_StartSound("weapons/smg", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_9", height - 12, speedfactor: 1.1);
					A_SpawnItemEx("HDSpent9mm", cos(pitch) * 10, 0, height - 8 - sin(pitch) * 10, vel.x, vel.y, vel.z, 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
 				}

				if (!SelWeapon.TryChamberRound())
				{
					TryReloadWeapon(SelWeapon, flags: RLF_FORCE);
				}
			}
			#### H 1;
			Goto ShootSMG;
		ReloadSMG:
			#### H 3
			{
				bNOPAIN = true;
			}
			#### H 4
			{
				A_StartSound("weapons/rifleclick2");
			}
			#### H 0
			{
				A_StartSound("weapons/rifleload");
				HDMagAmmo.SpawnMag(self, "HD9mMag30", 0);
			}
			#### H 25 A_StartSound("weapons/pocket", 8);
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReloadMag();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/rifleclick2", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// Hunter
		// ----------------------------------------

		ShootHunter:
			#### H 1 Aim();
			#### I 1
			{
 				if (SelWeapon.TryFireRound(true))
 				{
					Hunter.Fire(self, 1);
					A_SpawnItemEx("HDSpentShell", cos(pitch) * 8, 0, height - 7 - sin(pitch) * 8, vel.x + cos(pitch) * cos(angle - random(86, 90)) * 5, vel.y + cos(pitch) * sin(angle - random(86, 90)) * 5, vel.z + sin(pitch) * random(4, 6), 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
 				}

 				if (!SelWeapon.TryChamberRound())
				{
					TryReloadWeapon(SelWeapon, flags: RLF_FORCE);
				}
			}
			#### H 1;
			Goto See;
		ReloadHunter:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 20 A_StartSound("weapons/pocket", 8);
		ReloadHunterLoop:
			#### HHH 8
			{
				if (SelWeapon.TryReloadMag())
				{
					A_StartSound("weapons/huntreload", 8);
				}
				else
				{
					if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Chambered)
					{
						SetStateLabel("See");
					}
					else
					{
						SetStateLabel("ChamberRoundHunter");
					}
					bNOPAIN = false;
				}
			}
			#### H 35;
			Loop;
		ChamberRoundHunter:
			#### H 5
			{
				bNOPAIN = true;
			}
			#### H 6 A_StartSound("weapons/huntrackdown", 8);
			#### H 10
			{
				SelWeapon.TryChamberRound();
				A_StartSound("weapons/huntrackup", 8);
			}
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// ZM66
		// ----------------------------------------

		ShootZM66:
			#### III 1
			{
				// [Ace] Technically it's caseless so it doesn't eject anything but for the sake of code let's assume it does.
				if (SelWeapon.TryFireRound(true))
				{
					A_StartSound("weapons/rifle", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_426", height - 12);
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
				}

				if (!SelWeapon.TryChamberRound())
				{
					TryReloadWeapon(SelWeapon, flags: RLF_FORCE);
				}
			}
			#### H 5;
			Goto See;
		ReloadZM66:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 6 A_StartSound("weapons/rifleclick2");
			#### H 3
			{
				A_StartSound("weapons/rifleload");
				HDMagAmmo.SpawnMag(self, "HD4mMag", 0);
			}
			#### H 35 A_StartSound("weapons/pocket", 8);
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReloadMag();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/rifleclick2", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// ROCKET LAUNCHER
		// ----------------------------------------

		ShootRL:
			#### H 2 Aim();
			#### I 1
			{
				if (SelWeapon.TryFireRound(true))
				{
					GyroGrenade Proj;
					Proj = GyroGrenade(spawn("GyroGrenade", pos + (0, 0, height - 12), ALLOW_REPLACE));
					Proj.angle = angle;
					Proj.target = self;
					Proj.master = self;
					Proj.pitch = pitch;
					Proj.Primed = false;
					Proj.IsRocket = true;

					A_StartSound("weapons/rockignite", CHAN_AUTO);
					A_StartSound("weapons/rockboom", CHAN_AUTO);
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
				}

				if (!SelWeapon.TryChamberRound())
				{
					TryReloadWeapon(SelWeapon, flags: RLF_FORCE);
				}
			}
			#### H 20;
			Goto See;
		ReloadRL:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 5 A_StartSound("weapons/rockopen", 8);
			#### H 12
			{
				A_StartSound("weapons/rockopen2", 8, CHANF_OVERLAP);
			}
		ReloadRLLoop:
			#### H 8 A_StartSound("weapons/pocket", 8);
			#### H 12
			{
				if (SelWeapon.TryReloadMag())
				{
					A_StartSound("weapons/rockreload", 8);
					SelWeapon.TryChamberRound();
				}
				else
				{
					SetStateLabel("See");
					bNOPAIN = false;
				}
			}
			Loop;

		// ----------------------------------------
		// LIBERATOR
		// ----------------------------------------

		ShootLiberator:
			#### H 2 Aim();
			#### I 1
			{
				if (SelWeapon.TryFireRound(true))
				{
					A_StartSound("weapons/bigrifle", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_776", height - 12);
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
					A_SpawnItemEx("HDSpent7mm", cos(pitch) * 12, 0, height - 8 - sin(pitch) * 12, cos(pitch) * 3, 0.2 * randompick(-1, 1), -sin(pitch) * 3, 0, SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
				}

				if (!SelWeapon.TryChamberRound())
				{
					TryReloadWeapon(SelWeapon, flags: RLF_FORCE);
				}
			}
			#### H 3;
			Goto ShootLiberator;
		ReloadLiberator:
			#### H 10
			{
				bNOPAIN = true;
			}
			#### H 15 A_StartSound("weapons/rifleclick2");
			#### H 8
			{
				A_StartSound ("weapons/rifleload", 8, CHANF_OVERLAP);
				HDMagAmmo.SpawnMag(self, "HD7mMag", 0);
			}
			#### H 35 A_StartSound("weapons/pocket", 8);
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReloadMag();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/libchamber", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// BOSS RIFLE
		// ----------------------------------------

		ShootBoss:
			#### H 4 Aim();
			#### I 1
			{
				if (SelWeapon.TryFireRound(false))
				{
					A_StartSound("weapons/bigrifle2", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_776", height - 12, speedfactor: 0.99);
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
				}
			}
			#### H 5;
		ChamberRoundBoss:
			#### H 0
			{
				bNOPAIN = true;
			}
			#### H 5 A_StartSound("weapons/boltback", 8);
			#### H 7
			{
				if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Spent)
				{
					A_SpawnItemEx("HDSpent7mm", cos(pitch) * 8, 1, height - 7 - sin(pitch) * 8, cos(pitch) * cos(angle - 80) * 6 + vel.x, cos(pitch) * sin(angle - 80) * 6 + vel.y, -sin(pitch) * 6+ vel.z, 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
					SelWeapon.ChamberedRound = FollowerWeapon.CRType_Empty;
				}
				A_StartSound("weapons/boltfwd", 8);
				if (!SelWeapon.TryChamberRound())
				{
					TryReloadWeapon(SelWeapon, flags: RLF_FORCE);
				}
			}
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto ShootBoss;
		ReloadBoss:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 2 A_StartSound("weapons/rifleclick2", 8, CHANF_OVERLAP, 0.9, pitch: 0.95);
			#### H 4 A_StartSound("weapons/rifleload", 8, CHANF_OVERLAP);
			#### H 20 A_StartSound("weapons/pocket", 8);
		ReloadBossLoop:
			#### H 12
			{
				if (SelWeapon.TryReloadMag())
				{
					A_StartSound("weapons/rifleclick2", 8);
				}
				else
				{
					if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Chambered)
					{
						SetStateLabel("See");
					}
					else
					{
						SetStateLabel("ChamberRoundBoss");
					}
					bNOPAIN = false;
				}
			}
			Loop;

		// ----------------------------------------
		// BRONTORNIS
		// ----------------------------------------

		ShootBronto:
			#### I 1
			{
				if (SelWeapon.TryFireRound(false))
				{
					A_StartSound("weapons/bronto",CHAN_WEAPON);
					A_StartSound("weapons/bronto",CHAN_WEAPON, CHANF_OVERLAP);
					A_StartSound("weapons/bronto2",CHAN_WEAPON, CHANF_OVERLAP);
					HDBulletActor.FireBullet(self, "HDB_Bronto", height - 12);
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
					A_Recoil(6);
				}
				
				TryReloadWeapon(SelWeapon, flags: RLF_FORCE);
			}
			#### H 10;
			Goto See;
		ReloadBronto:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 5
			{
				A_StartSound("weapons/brontunload", 8);
				if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Spent)
				{
					A_SpawnItemEx("TerrorCasing", cos(pitch) * 4, 0, height - 10 - sin(pitch) * 4, vel.x, vel.y, vel.z - frandom(-1, 1), frandom(-1, 1), SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH | SXF_TRANSFERTRANSLATION);
					SelWeapon.ChamberedRound = FollowerWeapon.CRType_Empty;
				}
			}
			#### H 12 A_StartSound("weapons/brontoload", 9);
			#### H 12 A_StartSound("weapons/pocket", 10);
			#### H 10
			{
				A_StartSound("weapons/brontoload", 10);
				SelWeapon.TryChamberRound();
			}
			#### H 10 A_StartSound("weapons/brontunload", 11);
			#### H 5 A_StartSound("weapons/brontoclose", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;
	}
}

class FollowerWeapon
{
	enum CRType
	{
		CRType_Empty,
		CRType_Chambered,
		CRType_Spent
	}

	CRType ChamberedRound;
	int Mag;
	int SpareAmmo;
	bool HasWarnedLowAmmo;

	virtual void Init()
	{
		ChamberedRound = CRType_Chambered;
		Mag = GetMaxMag();
	}
	virtual string GetName() { return "N/A"; } // [Ace] Name is used for LANGUAGE identification.
	virtual class<HDAmmo> GetAmmoType() { return null; }
	virtual string GetAmmoName() { return "N/A"; }
	virtual StateLabel GetFireState() { return null; }
	virtual StateLabel GetReloadState() { return null; }
	virtual int GetMaxMag() { return 0; } // [Ace] Max mag being 0 means that spare ammo is treated as mag.
	virtual int GetMaxSpare() { return 0; }
	virtual double GetAdjustmentMult() { return 1.0; }
	virtual play bool CheckWeaponCondition(HDFollower caller, HDPlayerPawn plr, Actor trgt) { return true; }

	clearscope int GetLoadedRounds()
	{
		return Mag + (ChamberedRound == CRType_Chambered);
	}

	bool TryFireRound(bool eject)
	{
		if (ChamberedRound == CRType_Chambered)
		{
			ChamberedRound = eject ? CRType_Empty : CRType_Spent;
			return true;
		}

		return false;
	}

	virtual bool TryChamberRound()
	{
		if (ChamberedRound == CRType_Empty && Mag > 0)
		{
			Mag--;
			ChamberedRound = CRType_Chambered;
			return true;
		}

		return false;
	}
	
	virtual bool TryReloadMag()
	{
		if (SpareAmmo <= 0)
		{
			return false;
		}

		int AmmoMissing = GetMaxMag() - Mag;
		int AmmoToLoad = min(AmmoMissing, SpareAmmo);
		SpareAmmo -= AmmoToLoad;
		Mag += AmmoToLoad;

		return true;
	}
}

class FW_SMG : FollowerWeapon
{
	override void Init()
	{
		Super.Init();
		SpareAmmo = GetMaxMag() * 2;
	}
	override string GetName() { return "SMG"; }
	override class<HDAmmo> GetAmmoType() { return "HDPistolAmmo"; }
	override string GetAmmoName() { return "9mm Rounds"; }
	override int GetMaxMag() { return 30; }
	override int GetMaxSpare() { return 300; }
	override StateLabel GetFireState() { return "ShootSMG"; }
	override StateLabel GetReloadState() { return "ReloadSMG"; }
}

class FW_Hunter : FollowerWeapon
{
	override void Init()
	{
		Super.Init();
		SpareAmmo = GetMaxMag();
	}
	override string GetName() { return "Hunter"; }
	override class<HDAmmo> GetAmmoType() { return "HDShellAmmo"; }
	override string GetAmmoName() { return "12 ga. Shells"; }
	override int GetMaxMag() { return 7; }
	override int GetMaxSpare() { return 60; }
	override StateLabel GetFireState() { return "ShootHunter"; }
	override StateLabel GetReloadState() { return "ReloadHunter"; }
	override double GetAdjustmentMult() { return 0.85; }

	override bool TryReloadMag()
	{
		if (SpareAmmo <= 0 || Mag == GetMaxMag())
		{
			return false;
		}

		SpareAmmo -= 1;
		Mag += 1;
		
		return true;
	}
}

class FW_ZM66 : FollowerWeapon
{
	override void Init()
	{
		Super.Init();
		SpareAmmo = GetMaxMag();
	}
	override string GetName() { return "ZM66"; }
	override class<HDAmmo> GetAmmoType() { return "FourMilAmmo"; }
	override string GetAmmoName() { return "4mm Rounds"; }
	override int GetMaxMag() { return 50; }
	override int GetMaxSpare() { return 250; }
	override StateLabel GetFireState() { return "ShootZM66"; }
	override StateLabel GetReloadState() { return "ReloadZM66"; }
	override double GetAdjustmentMult() { return 0.75; }
}

class FW_RocketLauncher : FollowerWeapon
{
	override string GetName() { return "RL"; }
	override class<HDAmmo> GetAmmoType() { return "HDRocketAmmo"; }
	override string GetAmmoName() { return "Rocket Grenades"; }
	override int GetMaxMag() { return 5; }
	override int GetMaxSpare() { return 15; }
	override StateLabel GetFireState() { return "ShootRL"; }
	override StateLabel GetReloadState() { return "ReloadRL"; }
	override double GetAdjustmentMult() { return 0.85; }

	override bool TryReloadMag()
	{
		if (SpareAmmo <= 0 || Mag == GetMaxMag())
		{
			return false;
		}

		SpareAmmo -= 1;
		Mag += 1;
		
		return true;
	}

	override bool CheckWeaponCondition(HDFollower caller, HDPlayerPawn plr, Actor trgt)
	{
		return caller.Distance3D(trgt) >= 42 * 11 && (plr.Distance3D(trgt) >= 42 * 15 || plr.Distance3D(trgt) >= 42 * 4 && !trgt.CheckSight(plr));
	}
}

class FW_Liberator : FollowerWeapon
{
	override string GetName() { return "Liberator"; }
	override class<HDAmmo> GetAmmoType() { return "SevenMilAmmo"; }
	override string GetAmmoName() { return "7mm Rounds"; }
	override int GetMaxMag() { return 30; }
	override int GetMaxSpare() { return 150; }
	override StateLabel GetFireState() { return "ShootLiberator"; }
	override StateLabel GetReloadState() { return "ReloadLiberator"; }
	override double GetAdjustmentMult() { return 0.70; }
}

class FW_Boss : FollowerWeapon
{
	override string GetName() { return "Boss"; }
	override class<HDAmmo> GetAmmoType() { return "SevenMilAmmo"; }
	override string GetAmmoName() { return "7mm Rounds"; }
	override int GetMaxMag() { return 10; }
	override int GetMaxSpare() { return 50; }
	override StateLabel GetFireState() { return "ShootBoss"; }
	override StateLabel GetReloadState() { return "ReloadBoss"; }
	override double GetAdjustmentMult() { return 0.40; }

	override bool TryReloadMag()
	{
		if (SpareAmmo <= 0 || Mag == GetMaxMag())
		{
			return false;
		}

		SpareAmmo -= 1;
		Mag += 1;
		
		return true;
	}
}

class FW_Bronto : FollowerWeapon
{
	override string GetName() { return "Bronto"; }
	override class<HDAmmo> GetAmmoType() { return "BrontornisRound"; }
	override string GetAmmoName() { return "Brontornis Bolt"; }
	override int GetMaxMag() { return 0; }
	override int GetMaxSpare() { return 5; }
	override StateLabel GetFireState() { return "ShootBronto"; }
	override StateLabel GetReloadState() { return "ReloadBronto"; }

	override bool TryChamberRound()
	{
		if (ChamberedRound == CRType_Empty && SpareAmmo > 0)
		{
			SpareAmmo--;
			ChamberedRound = CRType_Chambered;
			return true;
		}

		return false;
	}
}