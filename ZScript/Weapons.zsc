extend class HDFollower
{
	enum RLFlags
	{
		RLF_FORCE	= 1 << 0,
		RLF_MANUAL	= 1 << 1,
		RLF_SILENT	= 1 << 2,
		RLF_NOJUMP	= 1 << 3
	}

	private void ClearWeapon()
	{
		SelWeapon = null;
	}

	double GetShotHeight()
	{
		return height - HDCONST_CROWNTOSHOULDER;
	}

	private int AdjustForDistance(double distance, double mult = 1.0) const
	{
		return int(clamp((distance / 42.0) * mult, 8, MaxTargetRange / 42.0));
	}

	clearscope FollowerWeapon FindWeapon(class<FollowerWeapon> wpn)
	{
		for (int i = 0; i < Weapons.Size(); ++i)
		{
			if (Weapons[i].GetClass() == wpn)
			{
				return Weapons[i];
			}
		}

		return null;
	}

	clearscope bool AmmoIsUsed(class<HDAmmo> cls)
	{
		for (int i = 0; i < Weapons.Size(); ++i)
		{
			class<HDAmmo> AType, MType;
			[AType, MType] = Weapons[i].GetAmmoType();
			if (!MType && AType == cls || MType == cls)
			{
				return true;
			}
		}

		return false;
	}

	// [Ace] If weapon is out of ammo, reload.
	bool TryReloadWeapon(FollowerWeapon wpn, int flags = 0)
	{
		if (Status == FStatus_InactiveOrDead || SelWeapon && !(flags & RLF_FORCE))
		{
			return false;
		}

		int ReloadResult = wpn.TryReload(true);
		if (ReloadResult == FollowerWeapon.RResult_CanReload)
		{
			if (hdf_debug == 1)
			{
				Console.Printf("Trying to reload "..wpn.GetName()..".");
			}
			SelWeapon = wpn;
			Status = FStatus_InCombat;
			SetStateLabel(wpn.GetReloadState());
			return true;
		}
		else if (ReloadResult == FollowerWeapon.RResult_NoAmmo)
		{
			// [Ace] Keep complaining if manual.
			if (!(flags & RLF_SILENT) && (!wpn.HasWarnedLowAmmo || (flags & RLF_MANUAL)))
			{
				wpn.HasWarnedLowAmmo = true;
				PrintMessage(GetResponse("NOAMMO_"..wpn.GetLocalizationTag()), "NoAmmo/"..wpn.GetLocalizationTag(), PMType_Critical);
			}

			if (!(flags & RLF_NOJUMP))
			{
				ClearWeapon();
				SetStateLabel('Idle');
			}
		}

		return false;
	}

	protected void EngageTarget(Array<class<FollowerWeapon> > wpns, Actor other)
	{
		// [Ace] This is used so that FindWeapon() isn't copy-pasted numerous times in the targeting code.
		Array<FollowerWeapon> ActualWeapons;
		for (int i = 0; i < wpns.Size(); ++i)
		{
			FollowerWeapon w = FindWeapon(wpns[i]);
			if (w)
			{
				ActualWeapons.Push(w);
			}
		}

		FollowerWeapon HighestWithSpare = null;
		FollowerWeapon HighestWithAmmo = null;
		SelWeapon = null;

		// [Ace] Find a weapon that has ammo in it. Start from the end and work backwards.
		for (int i = ActualWeapons.Size() - 1; i >= 0; --i)
		{
			// [Ace] Ignore weapons that don't fulfill the required condition. When it comes to, say, a rocket launcher, this is the check that makes sure you don't get blasted to bits by accident.
			if (!ActualWeapons[i].CheckWeaponCondition(self, other))
			{
				continue;
			}

			class<HDAmmo> AType, MType;
			[AType, MType] = ActualWeapons[i].GetAmmoType();
			if (MType && GetAmount(MType) > 0 || !MType && GetAmount(AType) > 0)
			{
				HighestWithSpare = ActualWeapons[i];
			}
			if (ActualWeapons[i].Mag > 0 || ActualWeapons[i].ChamberedRound == FollowerWeapon.CRType_Chambered)
			{
				HighestWithAmmo = ActualWeapons[i];
			}
		}

		if (hdf_debug == 1)
		{
			Console.Printf("Highest with spare is "..(HighestWithSpare ? HighestWithSpare.GetName() : "nothing")..".");
			Console.Printf("Highest with ammo is "..(HighestWithAmmo ? HighestWithAmmo.GetName() : "nothing")..".");
		}

		if (HighestWithAmmo)
		{
			SelWeapon = HighestWithAmmo;
		}
		else if (HighestWithSpare)
		{
			SelWeapon = HighestWithSpare;
			TryReloadWeapon(SelWeapon, RLF_FORCE | RLF_SILENT | RLF_NOJUMP);
			return;
		}
		
		if (other && SelWeapon)
		{
			CTarget = other;
			SetStateLabel('See');
		}
	}

	protected void Aim()
	{
		// [Ace] Stop aiming if target is no longer valid, weapon is deselected, or the condition is not met.
		if (!CheckTarget() || !SelWeapon || !SelWeapon.CheckWeaponCondition(self, CTarget))
		{
			SetStateLabel('Idle');
			Status = FStatus_None;
			return;
		}

		if (hdf_debug == 1)
		{
			Console.Printf("Aiming at %s.", CTarget.GetClassName());
		}

		A_Face(CTarget, 0, 0, flags: FAF_MIDDLE);

		// [Ace] If you're incapped, follower can probably shoot over you. Otherwise it's not a good idea.
		Actor BlockActor = AimBlocked();
		if (BlockActor)
		{
			if (Distance3D(BlockActor) < 42 * 5)
			{
				double dangle = DeltaAngle(angle, AngleTo(BlockActor));
				int dir = dangle > 0 ? -1 : 1;
				A_ChangeVelocity(0, (default.MovementSpeed / frandom(1.3, 1.5)) * dir, vel.z, CVF_RELATIVE | CVF_REPLACE);
			}
			AimTimer = 0;
			SetStateLabel('Aiming');
		}
	}

	protected Actor AimBlocked()
	{
		FLineTraceData TraceData;
		LineTrace(angle, MaxTargetRange, pitch, TRF_NOSKY, Height - HDCONST_CROWNTOSHOULDER, data: TraceData);
		Actor a = TraceData.HitActor;
		if (a && bFRIENDLY && (a is "PlayerPawn" || a is 'HDFollower' && a.bFRIENDLY || !a.bISMONSTER && a.bSOLID))
		{
			if (hdf_debug == 2)
			{
				Console.Printf("Aim is being blocked by %s.", a.GetClassName());
			}
			return a;
		}
		return null;
	}

	protected FollowerWeapon SelWeapon;
	Array<FollowerWeapon> Weapons;

	private int AimTimer;
	private bool ContinueReloading;
	
	States
	{
		See:
			#### HH 2
			{
				Status = FStatus_InCombat;
				AimTimer = 0;
			}
		Aiming:
			#### H 1; // [Ace] Otherwise it's gonna cause an infinite loop.
			#### H 0 Aim(); // [Ace] This is on this line and not inside the anonymous function because of SetStateLabel.
			#### H 0
			{
				if (AimTimer++ > AdjustForDistance(Distance3D(CTarget), SelWeapon.GetAdjustmentMult()))
				{
					if (hdf_debug == 1)
					{
						Console.Printf("Trying to fire "..SelWeapon.GetName().." at "..CTarget.GetTag()..".");
					}
					AimTimer = 0;
					SetStateLabel(SelWeapon.GetFireState());
				}
			}
			Loop;

		// ----------------------------------------
		// SMG
		// ----------------------------------------

		ShootSMG:
			#### H 1 Aim();
			#### I 1
			{
 				SelWeapon.FireWeapon();
				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 1;
			Goto ShootSMG;
		ReloadSMG:
			#### H 3
			{
				bNOPAIN = true;
			}
			#### H 4
			{
				A_StartSound("weapons/rifleclick2");
			}
			#### H 25
			{
				A_StartSound("weapons/pocket", 8);
				A_StartSound("weapons/rifleload");
				SelWeapon.EjectMag();
			}
			#### H 10
			{
				SelWeapon.TryReload();
				A_StartSound("weapons/rifleload", 9);
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/rifleclick2", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// Hunter
		// ----------------------------------------

		ShootHunter:
			#### H 1 Aim();
			#### I 1
			{
 				SelWeapon.FireWeapon();
 				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 1;
			Goto See;
		ReloadHunter:
			#### H 8
			{
				bNOPAIN = true;
			}
		ReloadHunterLoop:
			#### H 30 A_StartSound("weapons/pocket", 8);
			#### HHH 8
			{
				if (SelWeapon.TryReload() == FollowerWeapon.RResult_CanReload)
				{
					A_StartSound("weapons/huntreload", 8);
					if (SelWeapon.ChamberedRound < FollowerWeapon.CRType_Chambered)
					{
						ContinueReloading = true;
						SetStateLabel('ChamberRoundHunter');
					}
				}
				else
				{
					if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Chambered)
					{
						SetStateLabel('See');
					}
					else
					{
						SetStateLabel('ChamberRoundHunter');
					}
					bNOPAIN = false;
				}
			}
			Loop;
		ChamberRoundHunter:
			#### H 5
			{
				bNOPAIN = true;
			}
			#### H 6 A_StartSound("weapons/huntrackdown", 8);
			#### H 10
			{
				SelWeapon.TryChamberRound();
				A_StartSound("weapons/huntrackup", 8);
			}
			#### H 0
			{
				if (ContinueReloading)
				{
					ContinueReloading = false;
					SetStateLabel('ReloadHunterLoop');
					return;
				}
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// ZM66
		// ----------------------------------------

		ShootZM66:
			#### III 1
			{
				SelWeapon.FireWeapon();
				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
					SetStateLabel('See');
				}
			}
			#### H 5;
			Goto See;
		ReloadZM66:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 6 A_StartSound("weapons/rifleclick2");
			#### H 3
			{
				A_StartSound("weapons/rifleload");
				SelWeapon.EjectMag();
			}
			#### H 35 A_StartSound("weapons/pocket", 8);
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReload();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/rifleclick", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// ROCKET LAUNCHER
		// ----------------------------------------

		ShootRL:
			#### H 2 Aim();
			#### I 1
			{
				SelWeapon.FireWeapon();
				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 20;
			Goto See;
		ReloadRL:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 5 A_StartSound("weapons/rockopen", 8);
			#### H 12
			{
				A_StartSound("weapons/rockopen2", 8, CHANF_OVERLAP);
			}
		ReloadRLLoop:
			#### H 8 A_StartSound("weapons/pocket", 8);
			#### H 12
			{
				if (SelWeapon.TryReload() == FollowerWeapon.RResult_CanReload)
				{
					A_StartSound("weapons/rockreload", 8);
					SelWeapon.TryChamberRound();
				}
				else
				{
					SetStateLabel('See');
					bNOPAIN = false;
				}
			}
			Loop;

		// ----------------------------------------
		// LIBERATOR
		// ----------------------------------------

		ShootLiberator:
			#### H 2 Aim();
			#### I 1
			{
				SelWeapon.FireWeapon();

				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 3;
			Goto ShootLiberator;
		ReloadLiberator:
			#### H 10
			{
				bNOPAIN = true;
			}
			#### H 15 A_StartSound("weapons/rifleclick2");
			#### H 8
			{
				A_StartSound ("weapons/rifleload", 8, CHANF_OVERLAP);
				SelWeapon.EjectMag();
			}
			#### H 35 A_StartSound("weapons/pocket", 8);
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReload();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/libchamber", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// BOSS RIFLE
		// ----------------------------------------

		ShootBoss:
			#### H 4 Aim();
			#### H 0 A_JumpIf(SelWeapon.ChamberedRound < FollowerWeapon.CRType_Chambered, 'ChamberRoundBoss');
			#### I 1
			{
				SelWeapon.FireWeapon();
			}
			#### H 5;
		ChamberRoundBoss:
			#### H 0
			{
				bNOPAIN = true;
			}
			#### H 5 A_StartSound("weapons/boltback", 8);
			#### H 7
			{
				if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Spent)
				{
					A_SpawnItemEx("HDSpent7mm", cos(pitch) * 8, 1, height - 7 - sin(pitch) * 8, cos(pitch) * cos(angle - 80) * 6 + vel.x, cos(pitch) * sin(angle - 80) * 6 + vel.y, -sin(pitch) * 6+ vel.z, 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
					SelWeapon.ChamberedRound = FollowerWeapon.CRType_Empty;
				}
				A_StartSound("weapons/boltfwd", 8);
				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto ShootBoss;
		ReloadBoss:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 2 A_StartSound("weapons/rifleclick2", 8, CHANF_OVERLAP, 0.9, pitch: 0.95);
			#### H 4 A_StartSound("weapons/rifleload", 8, CHANF_OVERLAP);
			#### H 15 A_StartSound("weapons/pocket", 8);
			#### H 4 A_StartSound("weapons/rifleclick2", 8);
			#### HHH 3 A_StartSound("weapons/rifleclick2", 8, pitch: 1.01);
			#### HHH 2 A_StartSound("weapons/rifleclick2", 8, CHANF_OVERLAP, pitch: 1.02);
			#### HHH 1 A_StartSound("weapons/rifleclick2", 8, CHANF_OVERLAP, pitch: 1.02);
			#### H 8
			{
				A_StartSound("weapons/rifleclick");
				SelWeapon.TryReload();

				if (SelWeapon.ChamberedRound < FollowerWeapon.CRType_Chambered)
				{
					SetStateLabel('ChamberRoundBoss');
				}
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// BRONTORNIS
		// ----------------------------------------

		ShootBronto:
			#### I 1
			{
				SelWeapon.FireWeapon();
				ClearWeapon();
			}
			#### H 10;
			Goto See;
		ReloadBronto:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 5
			{
				A_StartSound("weapons/brontunload", 8);
				if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Spent)
				{
					A_SpawnItemEx("TerrorCasing", cos(pitch) * 4, 0, height - 10 - sin(pitch) * 4, vel.x, vel.y, vel.z - frandom(-1, 1), frandom(-1, 1), SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH | SXF_TRANSFERTRANSLATION);
					SelWeapon.ChamberedRound = FollowerWeapon.CRType_Empty;
				}
			}
			#### H 12 A_StartSound("weapons/brontoload", 9);
			#### H 12 A_StartSound("weapons/pocket", 10);
			#### H 10
			{
				A_StartSound("weapons/brontoload", 10);
				SelWeapon.TryReload();
				SelWeapon.TryChamberRound();
			}
			#### H 10 A_StartSound("weapons/brontunload", 11);
			#### H 5 A_StartSound("weapons/brontoclose", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;
	}
}

class FollowerWeapon abstract
{
	static play void CreateAndAdd(class<FollowerWeapon> wpn, HDFollower flw)
	{
		FollowerWeapon fw = FollowerWeapon(new(wpn));
		fw.Owner = flw;
		flw.Weapons.Push(fw);
	}

	enum CRType
	{
		CRType_Empty,
		CRType_Spent,
		CRType_Chambered
	}

	enum RResult
	{
		RResult_CanReload,
		RResult_MagFull,
		RResult_NoAmmo,
		RResult_Invalid
	}

	CRType ChamberedRound;
	int Mag;
	bool HasWarnedLowAmmo;
	HDFollower Owner;

	abstract string GetName();
	abstract string GetIcon();
	abstract class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType();
	abstract StateLabel GetFireState();
	abstract StateLabel GetReloadState();
	abstract play void FireWeapon();

	virtual string GetLocalizationTag() { return GetName(); }
	virtual double GetAdjustmentMult() { return 1.0; }
	virtual play bool CheckWeaponCondition(HDFollower caller, Actor trgt) { return true; }

	play void EjectMag()
	{
		class<HDAmmo> AType, MType; int MaxMag;
		[AType, MType, MaxMag] = GetAmmoType();
		if (MType && Mag > -1)
		{
			HDMagAmmo.SpawnMag(Owner, MType, Mag);
			Mag = -1;
		}
	}

	virtual play RResult TryReload(bool justCheck = false)
	{
		class<HDAmmo> AType, MType; int MaxMag;
		[AType, MType, MaxMag] = GetAmmoType();

		if (Mag == MaxMag)
		{
			return RResult_MagFull;
		}
		if (!MType && Owner.GetAmount(AType) == 0 || MType && Owner.GetAmount(MType) == 0)
		{
			return RResult_NoAmmo;
		}
		if (justCheck)
		{
			return RResult_CanReload;
		}

		if (MType)
		{
			InventorySlot wpnAmmo = Owner.FindHighestAmount(MType);
			Mag = wpnAmmo.Amount;
			wpnAmmo.Destroy();
		}
		else if (AType)
		{
			InventorySlot wpnAmmo = Owner.FindLowestAmount(AType);
			Mag++;
			wpnAmmo.Amount--;
			if (wpnAmmo.Amount == 0)
			{
				wpnAmmo.Destroy();
			}
		}

		return RResult_CanReload;
	}

	play bool TryChamberRound()
	{
		if (ChamberedRound == CRType_Empty && Mag > 0)
		{
			Mag--;
			ChamberedRound = CRType_Chambered;
			return true;
		}

		return false;
	}

	virtual play void EmptyWeapon()
	{
		class<HDAmmo> AType; class<HDMagAmmo> MType;
		[AType, MType] = GetAmmoType();

		if (ChamberedRound == CRType_Chambered)
		{
			ChamberedRound = FollowerWeapon.CRType_Empty;
			Owner.A_SpawnItemEx(AType, random(0, 16), 0, 0, frandom(1.0, 2.0), 0, frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
		}

		if (Mag > 0)
		{
			if (MType)
			{
				HDMagAmmo.SpawnMag(Owner, MType, Mag);
			}
			else
			{
				Actor a; bool success;
				[success, a] = Owner.A_SpawnItemEx(AType, random(0, 16), 0, 0, frandom(1.0, 2.0), 0, frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
				Inventory(a).Amount = Mag;
			}
			Mag = 0;
		}
	}
}

class FW_SMG : FollowerWeapon
{
	override string GetName() { return "SMG"; }
	override string GetIcon() { return "SMGNA0"; }
	override class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType() { return 'HDPistolAmmo', 'HD9mMag30', 30; }
	override StateLabel GetFireState() { return 'ShootSMG'; }
	override StateLabel GetReloadState() { return 'ReloadSMG'; }

	override void FireWeapon()
	{
		if (ChamberedRound != CRType_Chambered)
		{
			return;
		}
		Owner.A_StartSound("weapons/smg", CHAN_WEAPON);
		HDBulletActor.FireBullet(Owner, "HDB_9", Owner.GetShotHeight(), speedfactor: 1.1);
		Owner.A_SpawnItemEx("HDSpent9mm", cos(Owner.pitch) * 10, 0, Owner.height - 8 - sin(Owner.pitch) * 10, Owner.vel.x, Owner.vel.y, Owner.vel.z, 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
		ChamberedRound = CRType_Empty;
	}
}

class FW_Hunter : FollowerWeapon
{
	override string GetName() { return "Hunter"; }
	override string GetIcon() { return "HUNTA0"; }
	override class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType() { return 'HDShellAmmo', null, 7; }
	override StateLabel GetFireState() { return 'ShootHunter'; }
	override StateLabel GetReloadState() { return 'ReloadHunter'; }
	override double GetAdjustmentMult() { return 0.85; }

	override void FireWeapon()
	{
		if (ChamberedRound != CRType_Chambered)
		{
			return;
		}

		double ShotPower = HDShotgun.GetShotPower();
		double Spread = 6 * ShotPower;
		double SpeedFactor = 1.02857 * ShotPower;
		double ShotHeight = Owner.GetShotHeight();

		HDBulletActor.FireBullet(Owner, "HDB_wad", ShotHeight);
		let p = HDBulletActor.FireBullet(Owner, "HDB_00", ShotHeight, spread: Spread, speedfactor: SpeedFactor, amount: 10);
		DistantNoise.Make(p, "world/shotgunfar");
		Owner.A_StartSound("weapons/hunter", CHAN_WEAPON);
		Owner.A_SpawnItemEx("HDSpentShell", cos(Owner.pitch) * 8, 0, Owner.height - 7 - sin(Owner.pitch) * 8, Owner.vel.x + cos(Owner.pitch) * cos(Owner.angle - random(86, 90)) * 5, Owner.vel.y + cos(Owner.pitch) * sin(Owner.angle - random(86, 90)) * 5, Owner.vel.z + sin(Owner.pitch) * random(4, 6), 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
		ChamberedRound = CRType_Empty;
	}
}

class FW_ZM66 : FollowerWeapon
{
	override string GetName() { return "ZM66"; }
	override string GetIcon() { return "RIFLA0"; }
	override class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType() { return 'FourMilAmmo', 'HD4mMag', 50; }
	override StateLabel GetFireState() { return 'ShootZM66'; }
	override StateLabel GetReloadState() { return 'ReloadZM66'; }
	override double GetAdjustmentMult() { return 0.75; }

	override void FireWeapon()
	{
		if (ChamberedRound != CRType_Chambered)
		{
			return;
		}

		Owner.A_StartSound("weapons/rifle", CHAN_WEAPON);
		HDBulletActor.FireBullet(Owner, "HDB_426", Owner.GetShotHeight());
		Owner.A_AlertMonsters(flags: AMF_TARGETEMITTER);
		ChamberedRound = CRType_Empty;
	}
}

class FW_RocketLauncher : FollowerWeapon
{
	override string GetName() { return "Rocket Launcher"; }
	override string GetIcon() { return "LAUNA0"; }
	override string GetLocalizationTag() { return "RL"; }
	override class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType() { return 'HDRocketAmmo', null, 6; }
	override StateLabel GetFireState() { return 'ShootRL'; }
	override StateLabel GetReloadState() { return 'ReloadRL'; }
	override double GetAdjustmentMult() { return 0.85; }

	override void FireWeapon()
	{
		if (ChamberedRound != CRType_Chambered)
		{
			return;
		}
		GyroGrenade Proj;
		Proj = GyroGrenade(Owner.Spawn("GyroGrenade", Owner.pos + (0, 0, Owner.GetShotHeight()), ALLOW_REPLACE));
		Proj.angle = Owner.angle;
		Proj.target = Owner;
		Proj.master = Owner;
		Proj.pitch = Owner.pitch;
		Proj.Primed = false;
		Proj.IsRocket = true;

		Owner.A_StartSound("weapons/rockignite", CHAN_AUTO);
		Owner.A_StartSound("weapons/rockboom", CHAN_AUTO);
		Owner.A_AlertMonsters(flags: AMF_TARGETEMITTER);
		ChamberedRound = CRType_Empty;
	}

	override bool CheckWeaponCondition(HDFollower caller, Actor trgt)
	{
		if (caller.Distance3D(trgt) < 42 * 11)
		{
			return false;
		}

		bool OtherFollowersSafe = true;
		for (int i = 0; i < caller.Handler.Followers.Size(); ++i)
		{
			HDFollower f = caller.Handler.Followers[i];
			bool HasSight = f.CheckSight(trgt);
			double Dist = f.Distance3D(trgt);
			if (Dist < 42 * 3 || Dist < 42 * 15 && HasSight)
			{
				OtherFollowersSafe = false;
				break;
			}
		}
		bool OtherPlayersSafe = true;
		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			let plr = HDPlayerPawn(players[i].mo);
			if (plr)
			{
				bool HasSight = plr.CheckSight(trgt);
				double Dist = plr.Distance3D(trgt);
				if (Dist < 42 * 3 || Dist < 42 * 15 && HasSight)
				{
					OtherPlayersSafe = false;
					break;
				}
			}
		}
		
		return OtherFollowersSafe && OtherPlayersSafe;
	}
}

class FW_Liberator : FollowerWeapon
{
	override string GetName() { return "Liberator"; }
	override string GetIcon() { return "BRLLA0"; }
	override class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType() { return 'SevenMilAmmo', 'HD7mMag', 30; }
	override StateLabel GetFireState() { return 'ShootLiberator'; }
	override StateLabel GetReloadState() { return 'ReloadLiberator'; }
	override double GetAdjustmentMult() { return 0.70; }

	override void FireWeapon()
	{
		if (ChamberedRound != CRType_Chambered)
		{
			return;
		}

		Owner.A_StartSound("weapons/bigrifle", CHAN_WEAPON);
		HDBulletActor.FireBullet(Owner, "HDB_776", Owner.GetShotHeight());
		Owner.A_AlertMonsters(flags: AMF_TARGETEMITTER);
		Owner.A_SpawnItemEx("HDSpent7mm", cos(Owner.pitch) * 12, 0, Owner.height - 8 - sin(Owner.pitch) * 12, cos(Owner.pitch) * 3, 0.2 * randompick(-1, 1), -sin(Owner.pitch) * 3, 0, SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
		ChamberedRound = CRType_Empty;
	}
}

class FW_Boss : FollowerWeapon
{
	override string GetName() { return "Boss Rifle"; }
	override string GetIcon() { return "BORFA0"; }
	override string GetLocalizationTag() { return "Boss"; }
	override class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType() { return 'SevenMilAmmo', 'HD7mClip', 10; }
	override StateLabel GetFireState() { return 'ShootBoss'; }
	override StateLabel GetReloadState() { return 'ReloadBoss'; }
	override double GetAdjustmentMult() { return 0.40; }

	override void FireWeapon()
	{
		if (ChamberedRound != CRType_Chambered)
		{
			return;
		}

		Owner.A_StartSound("weapons/bigrifle2", CHAN_WEAPON);
		HDBulletActor.FireBullet(Owner, "HDB_776", Owner.GetShotHeight(), speedfactor: 0.99);
		Owner.A_AlertMonsters(flags: AMF_TARGETEMITTER);
		ChamberedRound = CRType_Spent;
	}

	override RResult TryReload()
	{
		if (Mag > 0)
		{
			return RResult_MagFull;
		}

		EjectMag();
		return Super.TryReload();
	}

	override void EmptyWeapon()
	{
		class<HDAmmo> AType = GetAmmoType();

		if (ChamberedRound == CRType_Chambered)
		{
			ChamberedRound = FollowerWeapon.CRType_Empty;
			Owner.A_SpawnItemEx(AType, random(0, 16), 0, 0, frandom(1.0, 2.0), 0, frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
		}

		for (int i = 0; i < Mag; ++i)
		{
			Owner.A_SpawnItemEx(AType, random(0, 16), 0, 0, frandom(1.0, 2.0), 0, frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
		}
		Mag = 0;
	}
}

class FW_Bronto : FollowerWeapon
{
	override string GetName() { return "Brontornis"; }
	override string GetIcon() { return "BLSTA0"; }
	override string GetLocalizationTag() { return "Bronto"; }
	override class<HDAmmo>, class<HDMagAmmo>, int GetAmmoType() { return 'BrontornisRound', null, 1; }
	override StateLabel GetFireState() { return "ShootBronto"; }
	override StateLabel GetReloadState() { return "ReloadBronto"; }

	override void FireWeapon()
	{
		if (ChamberedRound != CRType_Chambered)
		{
			return;
		}

		Owner.A_StartSound("weapons/bronto", CHAN_WEAPON);
		Owner.A_StartSound("weapons/bronto", CHAN_WEAPON, CHANF_OVERLAP);
		Owner.A_StartSound("weapons/bronto2", CHAN_WEAPON, CHANF_OVERLAP);
		HDBulletActor.FireBullet(Owner, "HDB_Bronto", Owner.GetShotHeight());
		Owner.A_AlertMonsters(flags: AMF_TARGETEMITTER);
		Owner.A_Recoil(6);
		ChamberedRound = CRType_Spent;
	}

	override RResult TryReload(bool justCheck)
	{
		if (ChamberedRound == CRType_Chambered)
		{
			return RResult_MagFull;
		}

		return Super.TryReload(justCheck);
	}
}