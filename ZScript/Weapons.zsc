extend class HDFollower
{
	enum RLFlags
	{
		RLF_FORCE	= 1 << 0,
		RLF_MANUAL	= 1 << 1,
		RLF_SILENT	= 1 << 2,
		RLF_NOJUMP	= 1 << 3
	}

	private void ClearWeapon()
	{
		SelWeapon = null;
	}

	private double GetShotHeight()
	{
		return height - HDCONST_CROWNTOSHOULDER;
	}

	private int AdjustForDistance(double distance, double mult = 1.0) const
	{
		return int(clamp((distance / 42.0) * mult, 4, 60));
	}

	clearscope int GetMaxGiveAmount(FollowerWeapon wpn)
	{
		int MaxMag = wpn.GetMaxMag();
		return min(LinkedPlayer.CountInv(wpn.GetAmmoType()), (MaxMag > 0 ? MaxMag : 1), wpn.GetMaxSpare() - wpn.SpareAmmo);
	}

	clearscope FollowerWeapon FindWeapon(class<FollowerWeapon> wpn)
	{
		for (int i = 0; i < Weapons.Size(); ++i)
		{
			if (Weapons[i].GetClass() == wpn)
			{
				return Weapons[i];
			}
		}

		return null;
	}

	clearscope FollowerWeapon GetWeaponByIndex(int index)
	{
		int Size = Weapons.Size();
		if (index > -1 && Size > 0 && index < Size)
		{
			return Weapons[index];
		}

		return null;
	}

	void DropAllAmmo()
	{
		for (int i = 0; i < Weapons.Size(); ++i)
		{
			FollowerWeapon fw = Weapons[i];
			class<HDAmmo> AType = fw.GetAmmoType();
			if (!AType)
			{
				continue;
			}

			Actor a; bool success;
			int TotalAmmo = fw.GetLoadedRounds() + fw.SpareAmmo;
			if (TotalAmmo > 0)
			{
				[success, a] = A_SpawnItemEx(AType, random(0, 16), 0, 0, frandom(1.0, 2.0), 0, frandom(2.0, 5.0), random(0, 359), SXF_NOCHECKPOSITION);
				Inventory(a).Amount = TotalAmmo;
			}
			fw.ChamberedRound = FollowerWeapon.CRType_Empty;
			fw.Mag = 0;
			fw.SpareAmmo = 0;
		}
	}

	// [Ace] It's an int because it's used in NetworkProcess.
	void TryGiveAmmo(int wpnIndex)
	{
		FollowerWeapon wpn = GetWeaponByIndex(wpnIndex);
		if (Status == FStatus_InactiveOrDead || !wpn)
		{
			return;
		}

		string ATag = GetTag();

		class<Inventory> AmmoType = wpn.GetAmmoType();
		int MaxGive = GetMaxGiveAmount(wpn);

		if (DistanceToPlayer > radius + MaxInventoryDistance)
		{
			if (!TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL))
			{
				ThinkMessage(LinkedPlayer, "$AMMOGIVE_FAR_PLR");
			}
			return;
		}
		else if (wpn.SpareAmmo >= wpn.GetMaxSpare())
		{
			if (!TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL))
			{
				PrintMessage(GetResponse("$"..ATag.."_AMMOGIVE_"..wpn.GetLocalizationTag().."_TOOMANY"), "Follower/"..ATag.."/AmmoGive/"..wpn.GetLocalizationTag().."/TooMany", PMType_Important);
			}
			return;
		}
		else if (LinkedPlayer.CountInv(AmmoType) == 0)
		{
			if (!TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL))
			{
				ThinkMessage(LinkedPlayer, "$AMMOGIVE_NOTENOUGH_PLR");
			}
			return;
		}

		LinkedPlayer.A_TakeInventory(AmmoType, MaxGive);
		wpn.SpareAmmo += MaxGive;
		wpn.HasWarnedLowAmmo = false;
		TryReloadWeapon(wpn, wpn.GetMaxMag(), RLF_MANUAL);

		PrintMessage(GetResponse("$"..ATag.."_AMMOGIVE_"..wpn.GetLocalizationTag().."_SUCCESS"), "Follower/"..ATag.."/AmmoGive/"..wpn.GetLocalizationTag().."/Success", PMType_General);
	}

	// [Ace] If weapon is out of ammo, reload.
	protected bool TryReloadWeapon(FollowerWeapon wpn, int min = 0, RLFlags flags = 0)
	{
		if (SelWeapon && !(flags & RLF_FORCE))
		{
			return false;
		}

		string ATag = GetTag();

		int MaxMag = wpn.GetMaxMag();
		if (MaxMag > 0 && (wpn.Mag <= 0 || wpn.Mag < min) || MaxMag == 0 && wpn.ChamberedRound != FollowerWeapon.CRType_Chambered)
		{
			if (wpn.SpareAmmo > 0)
			{
				if (hdf_debug == 1)
				{
					Console.Printf("Trying to reload "..wpn.GetName()..".");
				}
				SelWeapon = wpn;
				Status = FStatus_InCombat;
				SetStateLabel(wpn.GetReloadState());
				return true;
			}
			else
			{
				// [Ace] Keep complaining if manual.
				if (!(flags & RLF_SILENT) && (!wpn.HasWarnedLowAmmo || (flags & RLF_MANUAL)))
				{
					wpn.HasWarnedLowAmmo = true;
					PrintMessage(GetResponse("$"..ATag.."_NOAMMO_"..wpn.GetLocalizationTag()), "Follower/"..ATag.."/NoAmmo/"..wpn.GetLocalizationTag(), PMType_Critical);
				}

				if (!(flags & RLF_NOJUMP))
				{
					ClearWeapon();
					SetStateLabel('Idle');
				}
				return false;
			}
		}

		return false;
	}

	protected void EngageTarget(Array<class<FollowerWeapon> > wpns, Actor other)
	{
		// [Ace] This is used so that FindWeapon() isn't copy-pasted numerous times in the targeting code.
		Array<FollowerWeapon> ActualWeapons;
		for (int i = 0; i < wpns.Size(); ++i)
		{
			FollowerWeapon w = FindWeapon(wpns[i]);
			if (w)
			{
				ActualWeapons.Push(w);
			}
		}

		FollowerWeapon HighestWithSpare = null;
		FollowerWeapon HighestWithAmmo = null;
		SelWeapon = null;

		// [Ace] Find a weapon that has ammo in it. Start from the end and work backwards.
		for (int i = ActualWeapons.Size() - 1; i >= 0; --i)
		{
			// [Ace] Ignore weapons that don't fulfill the required condition. When it comes to, say, a rocket launcher, this is the check that makes sure you don't get blasted to bits by accident.
			if (!ActualWeapons[i].CheckWeaponCondition(self, other))
			{
				continue;
			}

			int MaxMag = ActualWeapons[i].GetMaxMag();
			if (ActualWeapons[i].SpareAmmo > 0)
			{
				HighestWithSpare = ActualWeapons[i];
			}
			if (ActualWeapons[i].Mag > 0 || ActualWeapons[i].ChamberedRound == FollowerWeapon.CRType_Chambered)
			{
				HighestWithAmmo = ActualWeapons[i];
			}
		}

		if (hdf_debug == 1)
		{
			Console.Printf("Highest with spare is "..(HighestWithSpare ? HighestWithSpare.GetName() : "nothing")..".");
			Console.Printf("Highest with ammo is "..(HighestWithAmmo ? HighestWithAmmo.GetName() : "nothing")..".");
		}

		if (HighestWithAmmo)
		{
			SelWeapon = HighestWithAmmo;
		}
		else if (HighestWithSpare)
		{
			SelWeapon = HighestWithSpare;
			TryReloadWeapon(SelWeapon, 0, RLF_FORCE | RLF_SILENT | RLF_NOJUMP);
			return;
		}
		
		if (other && SelWeapon)
		{
			CTarget = other;
			SetStateLabel('See');
		}
	}

	protected void Aim()
	{
		// [Ace] Stop aiming if target is no longer valid, weapon is deselected, or the condition is not met.
		if (!CheckTarget() || !SelWeapon || !SelWeapon.CheckWeaponCondition(self, CTarget))
		{
			SetStateLabel('Idle');
			Status = FStatus_None;
			return;
		}

		if (hdf_debug == 1)
		{
			Console.Printf("Aiming at %s.", CTarget.GetClassName());
		}

		A_Face(CTarget, 0, 0, flags: FAF_MIDDLE);

		// [Ace] If you're incapped, follower can probably shoot over you. Otherwise it's not a good idea.
		Actor BlockActor = AimBlocked();
		if (BlockActor)
		{
			if (Distance3D(BlockActor) < 42 * 3)
			{
				double dangle = DeltaAngle(angle, AngleTo(BlockActor));
				int dir = dangle > 0 ? -1 : 1;
				A_ChangeVelocity(0, (default.MovementSpeed / frandom(1.3, 1.5)) * dir, vel.z, CVF_RELATIVE | CVF_REPLACE);
			}
			AimTimer = 0;
			SetStateLabel('Aiming');
		}
	}

	protected Actor AimBlocked()
	{
		FLineTraceData TraceData;
		LineTrace(angle, MaxTargetRange, pitch, TRF_NOSKY, Height - HDCONST_CROWNTOSHOULDER, data: TraceData);
		if (TraceData.HitActor && bFRIENDLY && (TraceData.HitActor is "PlayerPawn" || TraceData.HitActor is 'HDFollower' && TraceData.HitActor.bFRIENDLY))
		{
			if (hdf_debug == 2)
			{
				Console.Printf("Aim is being blocked by %s.", TraceData.HitActor.GetClassName());
			}
			return TraceData.HitActor;
		}
		return null;
	}

	protected FollowerWeapon SelWeapon;
	Array<FollowerWeapon> Weapons;

	private int AimTimer;
	
	States
	{
		See:
			#### HH 2
			{
				Status = FStatus_InCombat;
				AimTimer = 0;
			}
		Aiming:
			#### H 1; // [Ace] Otherwise it's gonna cause an infinite loop.
			#### H 1 Aim(); // [Ace] This is on this line and not inside the anonymous function because of SetStateLabel.
			#### H 0
			{
				if (AimTimer++ > AdjustForDistance(Distance3D(CTarget), SelWeapon.GetAdjustmentMult()))
				{
					if (hdf_debug == 1)
					{
						Console.Printf("Trying to fire "..SelWeapon.GetName().." at "..CTarget.GetTag()..".");
					}
					AimTimer = 0;
					SetStateLabel(SelWeapon.GetFireState());
				}
			}
			Loop;

		// ----------------------------------------
		// SMG
		// ----------------------------------------

		ShootSMG:
			#### H 1 Aim();
			#### I 1
			{
 				if (SelWeapon.TryFireRound(true))
 				{
 					A_StartSound("weapons/smg", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_9", GetShotHeight(), speedfactor: 1.1);
					A_SpawnItemEx("HDSpent9mm", cos(pitch) * 10, 0, height - 8 - sin(pitch) * 10, vel.x, vel.y, vel.z, 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
 				}

				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 1;
			Goto ShootSMG;
		ReloadSMG:
			#### H 3
			{
				bNOPAIN = true;
			}
			#### H 4
			{
				A_StartSound("weapons/rifleclick2");
			}
			#### H 25
			{
				A_StartSound("weapons/pocket", 8);
				A_StartSound("weapons/rifleload");
				SelWeapon.TryEjectMag(self);
			}
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReloadMag();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/rifleclick2", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// Hunter
		// ----------------------------------------

		ShootHunter:
			#### H 1 Aim();
			#### I 1
			{
 				if (SelWeapon.TryFireRound(true))
 				{
					double ShotPower = HDShotgun.GetShotPower();
					double Spread = 6 * ShotPower;
					double SpeedFactor = 1.02857 * ShotPower;
					double ShotHeight = GetShotHeight();

					HDBulletActor.FireBullet(self, "HDB_wad", ShotHeight);
					let p = HDBulletActor.FireBullet(self,"HDB_00", ShotHeight, spread: Spread, speedfactor: SpeedFactor, amount: 10);
					DistantNoise.Make(p, "world/shotgunfar");
					A_StartSound("weapons/hunter", CHAN_WEAPON);

					A_SpawnItemEx("HDSpentShell", cos(pitch) * 8, 0, height - 7 - sin(pitch) * 8, vel.x + cos(pitch) * cos(angle - random(86, 90)) * 5, vel.y + cos(pitch) * sin(angle - random(86, 90)) * 5, vel.z + sin(pitch) * random(4, 6), 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
 				}

 				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 1;
			Goto See;
		ReloadHunter:
			#### H 8
			{
				bNOPAIN = true;
			}
		ReloadHunterLoop:
			#### H 30 A_StartSound("weapons/pocket", 8);
			#### HHH 8
			{
				if (SelWeapon.TryReloadMag())
				{
					A_StartSound("weapons/huntreload", 8);
				}
				else
				{
					if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Chambered)
					{
						SetStateLabel('See');
					}
					else
					{
						SetStateLabel('ChamberRoundHunter');
					}
					bNOPAIN = false;
				}
			}
			Loop;
		ChamberRoundHunter:
			#### H 5
			{
				bNOPAIN = true;
			}
			#### H 6 A_StartSound("weapons/huntrackdown", 8);
			#### H 10
			{
				SelWeapon.TryChamberRound();
				A_StartSound("weapons/huntrackup", 8);
			}
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// ZM66
		// ----------------------------------------

		ShootZM66:
			#### III 1
			{
				// [Ace] Technically it's caseless so it doesn't eject anything but for the sake of code let's assume it does.
				if (SelWeapon.TryFireRound(true))
				{
					A_StartSound("weapons/rifle", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_426", GetShotHeight());
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
				}

				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
					SetStateLabel('See');
				}
			}
			#### H 5;
			Goto See;
		ReloadZM66:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 6 A_StartSound("weapons/rifleclick2");
			#### H 3
			{
				A_StartSound("weapons/rifleload");
				SelWeapon.TryEjectMag(self);
			}
			#### H 35 A_StartSound("weapons/pocket", 8);
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReloadMag();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/rifleclick", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// ROCKET LAUNCHER
		// ----------------------------------------

		ShootRL:
			#### H 2 Aim();
			#### I 1
			{
				if (SelWeapon.TryFireRound(true))
				{
					GyroGrenade Proj;
					Proj = GyroGrenade(Spawn("GyroGrenade", pos + (0, 0, GetShotHeight()), ALLOW_REPLACE));
					Proj.angle = angle;
					Proj.target = self;
					Proj.master = self;
					Proj.pitch = pitch;
					Proj.Primed = false;
					Proj.IsRocket = true;

					A_StartSound("weapons/rockignite", CHAN_AUTO);
					A_StartSound("weapons/rockboom", CHAN_AUTO);
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
				}

				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 20;
			Goto See;
		ReloadRL:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 5 A_StartSound("weapons/rockopen", 8);
			#### H 12
			{
				A_StartSound("weapons/rockopen2", 8, CHANF_OVERLAP);
			}
		ReloadRLLoop:
			#### H 8 A_StartSound("weapons/pocket", 8);
			#### H 12
			{
				if (SelWeapon.TryReloadMag())
				{
					A_StartSound("weapons/rockreload", 8);
					SelWeapon.TryChamberRound();
				}
				else
				{
					SetStateLabel('See');
					bNOPAIN = false;
				}
			}
			Loop;

		// ----------------------------------------
		// LIBERATOR
		// ----------------------------------------

		ShootLiberator:
			#### H 2 Aim();
			#### I 1
			{
				if (SelWeapon.TryFireRound(true))
				{
					A_StartSound("weapons/bigrifle", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_776", GetShotHeight());
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
					A_SpawnItemEx("HDSpent7mm", cos(pitch) * 12, 0, height - 8 - sin(pitch) * 12, cos(pitch) * 3, 0.2 * randompick(-1, 1), -sin(pitch) * 3, 0, SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
				}

				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 3;
			Goto ShootLiberator;
		ReloadLiberator:
			#### H 10
			{
				bNOPAIN = true;
			}
			#### H 15 A_StartSound("weapons/rifleclick2");
			#### H 8
			{
				A_StartSound ("weapons/rifleload", 8, CHANF_OVERLAP);
				SelWeapon.TryEjectMag(self);
			}
			#### H 35 A_StartSound("weapons/pocket", 8);
			#### H 10
			{
				A_StartSound("weapons/rifleload", 9);
				SelWeapon.TryReloadMag();
			}
			#### H 0 A_JumpIf(!SelWeapon.TryChamberRound(), 2);
			#### H 2 A_StartSound("weapons/libchamber", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;

		// ----------------------------------------
		// BOSS RIFLE
		// ----------------------------------------

		ShootBoss:
			#### H 4 Aim();
			#### I 1
			{
				if (SelWeapon.TryFireRound(false))
				{
					A_StartSound("weapons/bigrifle2", CHAN_WEAPON);
					HDBulletActor.FireBullet(self, "HDB_776", GetShotHeight(), speedfactor: 0.99);
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
				}
			}
			#### H 5;
		ChamberRoundBoss:
			#### H 0
			{
				bNOPAIN = true;
			}
			#### H 5 A_StartSound("weapons/boltback", 8);
			#### H 7
			{
				if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Spent)
				{
					A_SpawnItemEx("HDSpent7mm", cos(pitch) * 8, 1, height - 7 - sin(pitch) * 8, cos(pitch) * cos(angle - 80) * 6 + vel.x, cos(pitch) * sin(angle - 80) * 6 + vel.y, -sin(pitch) * 6+ vel.z, 0, SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
					SelWeapon.ChamberedRound = FollowerWeapon.CRType_Empty;
				}
				A_StartSound("weapons/boltfwd", 8);
				if (!SelWeapon.TryChamberRound())
				{
					ClearWeapon();
				}
			}
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto ShootBoss;
		ReloadBoss:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 2 A_StartSound("weapons/rifleclick2", 8, CHANF_OVERLAP, 0.9, pitch: 0.95);
			#### H 4 A_StartSound("weapons/rifleload", 8, CHANF_OVERLAP);
			#### H 20 A_StartSound("weapons/pocket", 8);
		ReloadBossLoop:
			#### H 12
			{
				if (SelWeapon.TryReloadMag())
				{
					A_StartSound("weapons/rifleclick2", 8);
				}
				else
				{
					if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Chambered)
					{
						SetStateLabel('See');
					}
					else
					{
						SetStateLabel('ChamberRoundBoss');
					}
					bNOPAIN = false;
				}
			}
			Loop;

		// ----------------------------------------
		// BRONTORNIS
		// ----------------------------------------

		ShootBronto:
			#### I 1
			{
				if (SelWeapon.TryFireRound(false))
				{
					A_StartSound("weapons/bronto",CHAN_WEAPON);
					A_StartSound("weapons/bronto",CHAN_WEAPON, CHANF_OVERLAP);
					A_StartSound("weapons/bronto2",CHAN_WEAPON, CHANF_OVERLAP);
					HDBulletActor.FireBullet(self, "HDB_Bronto", GetShotHeight());
					A_AlertMonsters(flags: AMF_TARGETEMITTER);
					A_Recoil(6);
				}
				ClearWeapon();
			}
			#### H 10;
			Goto See;
		ReloadBronto:
			#### H 8
			{
				bNOPAIN = true;
			}
			#### H 5
			{
				A_StartSound("weapons/brontunload", 8);
				if (SelWeapon.ChamberedRound == FollowerWeapon.CRType_Spent)
				{
					A_SpawnItemEx("TerrorCasing", cos(pitch) * 4, 0, height - 10 - sin(pitch) * 4, vel.x, vel.y, vel.z - frandom(-1, 1), frandom(-1, 1), SXF_ABSOLUTEMOMENTUM | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH | SXF_TRANSFERTRANSLATION);
					SelWeapon.ChamberedRound = FollowerWeapon.CRType_Empty;
				}
			}
			#### H 12 A_StartSound("weapons/brontoload", 9);
			#### H 12 A_StartSound("weapons/pocket", 10);
			#### H 10
			{
				A_StartSound("weapons/brontoload", 10);
				SelWeapon.TryChamberRound();
			}
			#### H 10 A_StartSound("weapons/brontunload", 11);
			#### H 5 A_StartSound("weapons/brontoclose", 8);
			#### H 0
			{
				bNOPAIN = false;
			}
			Goto See;
	}
}

class FollowerWeapon abstract
{
	// [Ace; 28.04.2021]
	// This should have been Empty -> Spent -> Chambered, but changing it now will break followers
	// and would require recreating them. Ah well.
	enum CRType
	{
		CRType_Empty,
		CRType_Chambered,
		CRType_Spent
	}

	CRType ChamberedRound;
	int Mag;
	int SpareAmmo;
	bool HasWarnedLowAmmo;

	virtual void Init()
	{
		ChamberedRound = CRType_Chambered;
		Mag = GetMaxMag();
	}
	abstract string GetName();
	abstract class<HDAmmo> GetAmmoType();
	abstract string GetAmmoName();
	abstract StateLabel GetFireState();
	abstract StateLabel GetReloadState();
	abstract int GetMaxMag(); // [Ace] Max mag being 0 means that spare ammo is treated as mag.
	abstract int GetMaxSpare();
	virtual string GetLocalizationTag() { return GetName(); }
	virtual class<HDMagAmmo> GetMagType() { return null; }
	virtual double GetAdjustmentMult() { return 1.0; }
	virtual play bool CheckWeaponCondition(HDFollower caller, Actor trgt) { return true; }

	virtual play void TryEjectMag(HDFollower dropper)
	{
		class<HDMagAmmo> MagType = GetMagType();
		if (MagType && Mag <= 0)
		{
			HDMagAmmo.SpawnMag(dropper, MagType, 0);
		}
	}

	clearscope int GetLoadedRounds()
	{
		return Mag + (ChamberedRound == CRType_Chambered);
	}

	// [Ace] Chamber + mag.
	clearscope bool IsFullyLoaded()
	{
		return ChamberedRound == CRType_Chambered && Mag == GetMaxMag();
	}

	bool TryFireRound(bool eject)
	{
		if (ChamberedRound == CRType_Chambered)
		{
			ChamberedRound = eject ? CRType_Empty : CRType_Spent;
			return true;
		}

		return false;
	}

	virtual bool TryChamberRound()
	{
		if (ChamberedRound == CRType_Empty && Mag > 0)
		{
			Mag--;
			ChamberedRound = CRType_Chambered;
			return true;
		}

		return false;
	}
	
	virtual bool TryReloadMag()
	{
		if (SpareAmmo <= 0)
		{
			return false;
		}

		int AmmoMissing = GetMaxMag() - Mag;
		int AmmoToLoad = min(AmmoMissing, SpareAmmo);
		SpareAmmo -= AmmoToLoad;
		Mag += AmmoToLoad;

		return true;
	}
}

class FW_SMG : FollowerWeapon
{
	override void Init()
	{
		Super.Init();
		SpareAmmo = GetMaxMag() * 2;
	}
	override string GetName() { return "SMG"; }
	override class<HDAmmo> GetAmmoType() { return "HDPistolAmmo"; }
	override class<HDMagAmmo> GetMagType() { return "HD9mMag30"; }
	override string GetAmmoName() { return "9mm Rounds"; }
	override int GetMaxMag() { return 30; }
	override int GetMaxSpare() { return 300; }
	override StateLabel GetFireState() { return "ShootSMG"; }
	override StateLabel GetReloadState() { return "ReloadSMG"; }
}

class FW_Hunter : FollowerWeapon
{
	override void Init()
	{
		Super.Init();
		SpareAmmo = GetMaxMag();
	}
	override string GetName() { return "Hunter"; }
	override class<HDAmmo> GetAmmoType() { return "HDShellAmmo"; }
	override string GetAmmoName() { return "12 ga. Shells"; }
	override int GetMaxMag() { return 7; }
	override int GetMaxSpare() { return 60; }
	override StateLabel GetFireState() { return "ShootHunter"; }
	override StateLabel GetReloadState() { return "ReloadHunter"; }
	override double GetAdjustmentMult() { return 0.85; }

	override bool TryReloadMag()
	{
		if (SpareAmmo <= 0 || Mag == GetMaxMag())
		{
			return false;
		}

		SpareAmmo -= 1;
		Mag += 1;
		
		return true;
	}
}

class FW_ZM66 : FollowerWeapon
{
	override void Init()
	{
		Super.Init();
		SpareAmmo = GetMaxMag();
	}
	override string GetName() { return "ZM66"; }
	override class<HDAmmo> GetAmmoType() { return "FourMilAmmo"; }
	override class<HDMagAmmo> GetMagType() { return "HD4mMag"; }
	override string GetAmmoName() { return "4mm Rounds"; }
	override int GetMaxMag() { return 50; }
	override int GetMaxSpare() { return 250; }
	override StateLabel GetFireState() { return "ShootZM66"; }
	override StateLabel GetReloadState() { return "ReloadZM66"; }
	override double GetAdjustmentMult() { return 0.75; }
}

class FW_RocketLauncher : FollowerWeapon
{
	override string GetName() { return "Rocket Launcher"; }
	override string GetLocalizationTag() { return "RL"; }
	override class<HDAmmo> GetAmmoType() { return "HDRocketAmmo"; }
	override string GetAmmoName() { return "Rocket Grenades"; }
	override int GetMaxMag() { return 5; }
	override int GetMaxSpare() { return 15; }
	override StateLabel GetFireState() { return "ShootRL"; }
	override StateLabel GetReloadState() { return "ReloadRL"; }
	override double GetAdjustmentMult() { return 0.85; }

	override bool TryReloadMag()
	{
		if (SpareAmmo <= 0 || Mag == GetMaxMag())
		{
			return false;
		}

		SpareAmmo -= 1;
		Mag += 1;
		
		return true;
	}

	override bool CheckWeaponCondition(HDFollower caller, Actor trgt)
	{
		if (caller.Distance3D(trgt) < 42 * 11)
		{
			return false;
		}

		bool OtherFollowersSafe = true;
		for (int i = 0; i < caller.Handler.Followers.Size(); ++i)
		{
			HDFollower f = caller.Handler.Followers[i];
			bool HasSight = f.CheckSight(trgt);
			double Dist = f.Distance3D(trgt);
			if (Dist < 42 * 3 || Dist < 42 * 15 && HasSight)
			{
				OtherFollowersSafe = false;
				break;
			}
		}
		bool OtherPlayersSafe = true;
		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			let plr = HDPlayerPawn(players[i].mo);
			if (plr)
			{
				bool HasSight = plr.CheckSight(trgt);
				double Dist = plr.Distance3D(trgt);
				if (Dist < 42 * 3 || Dist < 42 * 15 && HasSight)
				{
					OtherPlayersSafe = false;
					break;
				}
			}
		}
		
		return OtherFollowersSafe && OtherPlayersSafe;
	}
}

class FW_Liberator : FollowerWeapon
{
	override string GetName() { return "Liberator"; }
	override class<HDAmmo> GetAmmoType() { return "SevenMilAmmo"; }
	override class<HDMagAmmo> GetMagType() { return "HD7mMag"; }
	override string GetAmmoName() { return "7mm Rounds"; }
	override int GetMaxMag() { return 30; }
	override int GetMaxSpare() { return 150; }
	override StateLabel GetFireState() { return "ShootLiberator"; }
	override StateLabel GetReloadState() { return "ReloadLiberator"; }
	override double GetAdjustmentMult() { return 0.70; }
}

class FW_Boss : FollowerWeapon
{
	override string GetName() { return "Boss Rifle"; }
	override string GetLocalizationTag() { return "Boss"; }
	override class<HDAmmo> GetAmmoType() { return "SevenMilAmmo"; }
	override string GetAmmoName() { return "7mm Rounds"; }
	override int GetMaxMag() { return 10; }
	override int GetMaxSpare() { return 50; }
	override StateLabel GetFireState() { return "ShootBoss"; }
	override StateLabel GetReloadState() { return "ReloadBoss"; }
	override double GetAdjustmentMult() { return 0.40; }

	override bool TryReloadMag()
	{
		if (SpareAmmo <= 0 || Mag == GetMaxMag())
		{
			return false;
		}

		SpareAmmo -= 1;
		Mag += 1;
		
		return true;
	}
}

class FW_Bronto : FollowerWeapon
{
	override string GetName() { return "Brontornis"; }
	override string GetLocalizationTag() { return "Bronto"; }
	override class<HDAmmo> GetAmmoType() { return "BrontornisRound"; }
	override string GetAmmoName() { return "Brontornis Bolt"; }
	override int GetMaxMag() { return 0; }
	override int GetMaxSpare() { return 5; }
	override StateLabel GetFireState() { return "ShootBronto"; }
	override StateLabel GetReloadState() { return "ReloadBronto"; }

	override bool TryChamberRound()
	{
		if (ChamberedRound == CRType_Empty && SpareAmmo > 0)
		{
			SpareAmmo--;
			ChamberedRound = CRType_Chambered;
			return true;
		}

		return false;
	}
}