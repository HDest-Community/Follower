class FollowerCommand ui
{
	string EventName;
	int Args[3];
	bool UseUiHandler;
}

struct FollowerSelection
{
	Array<HDFollower> SelFollowers;
	clearscope HDFollower GetLast() const // [Ace] This const is gonna bite me in the ass. Mark my words.
	{
		int Size = SelFollowers.Size();
		return Size > 0 ? SelFollowers[Size - 1] : null;
	}
}

struct UiDataHolder
{
	Array<HDPickup> ValidItems;
	int RepeatTics[4];
	int ArrowKeysHeld;
	int SlotFocused;
	int PSlotIndex;
	int PSlotSubIndex;
	int TransferAmount;
	int FSlotIndex;
	bool Confirmation;
	CVar Scale;
	CVar UiColorCVar;
	Color UiColor;
}

extend class FollowerHandler
{
	enum FollowerMenus
	{
		FMenu_Closed,
		FMenu_Recruitment,
		FMenu_Followers,
		FMenu_Main,
		FMenu_Orders,
		FMenu_Inventory,
		FMenu_Miscellaneous,
		FMenu_ColorPicker
	}

	enum KeyHold
	{
		HOLD_LEFT = 1,
		HOLD_RIGHT = 2,
		HOLD_UP = 4,
		HOLD_DOWN = 8,
	}
	
	private transient ui HUDFont MainFont;

	// [Ace] Because this is the 5th time I've tried to convert these to UI scope: FUCKING DON'T.
	// These are data/play scope because NetworkProcess needs to access them.
	private transient int FollowerMenuLevel[MAXPLAYERS];
	private transient int FollowerPage[MAXPLAYERS];
	private transient HDOperator SelMarine[MAXPLAYERS];
	private transient FollowerSelection Selection[MAXPLAYERS];
	private transient int Modifiers[MAXPLAYERS];

	private transient ui bool InInputMode[MAXPLAYERS];
	private transient ui string InputString[MAXPLAYERS];

	private transient ui UiDataHolder UiData[MAXPLAYERS];

	

	private transient ui int SelectedColorIndex[MAXPLAYERS];

	const FollowersPerPage = 8;
	const InvColumns = 6;
	const PickerColumns = 20;
	const ColSquareSize = 6;
	const SlotSize = 24;
	const Spacing = 1;
	
	override void RenderOverlay(RenderEvent e)
	{
		MainFont = HUDFont.Create("CONFONT");

		int OriginalWidth = StatusBar.HorizontalResolution;
		int OriginalHeight = StatusBar.VerticalResolution;

		if (!UiData[consoleplayer].UiColorCVar)
		{
			UiData[consoleplayer].UiColorCVar = CVar.GetCVar('hdf_uicolor', players[consoleplayer]);
		}
		UiData[consoleplayer].UiColor = 0x40000000 | UiData[consoleplayer].UiColorCVar.GetInt();

		if (!UiData[consoleplayer].Scale)
		{
			UiData[consoleplayer].Scale = CVar.GetCVar('hdf_uiscale', players[consoleplayer]);
		}
		double uiScale = UiData[consoleplayer].Scale.GetFloat();
		StatusBar.BeginHUD(1.0, true);
		StatusBar.SetSize(StatusBar.RelTop, int(640 / uiScale), int(480 / uiScale));

		if (FollowerMenuLevel[consoleplayer] > FMenu_Closed && !AutomapActive && GameState == GS_LEVEL)
		{
			DrawCommandMenu(HDStatusBar(StatusBar), (0, 40), StatusBar.DI_SCREEN_LEFT | StatusBar.DI_SCREEN_VCENTER | StatusBar.DI_TEXT_ALIGN_LEFT);
		}

		// --------------- PRETEND WE WERE NEVER HERE ---------------

		StatusBar.BeginHUD(1.0, false);
		StatusBar.SetSize(StatusBar.RelTop, OriginalWidth, OriginalHeight);
	}

	// ----------------------------------------------------------------------
	//
	// NAVIGATION AND WHATNOT
	//
	// ----------------------------------------------------------------------

	override void UiTick()
	{
		Super.UiTick();

		switch (FollowerMenuLevel[consoleplayer])
		{
			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Inventory:
			{
				int size = Selection[consoleplayer].SelFollowers.Size();
				if (size > 1)
				{
					break;
				}

				HDFollower lastFol = Selection[consoleplayer].GetLast();
				int maxSIndex = HDFollower.SlotCount - 1;
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_LEFT && UiData[consoleplayer].RepeatTics[0] % 3 == 0)
				{
					if (UiData[consoleplayer].SlotFocused == 0 && UiData[consoleplayer].FSlotIndex % InvColumns > 0)
					{
						UiData[consoleplayer].FSlotIndex = max(UiData[consoleplayer].FSlotIndex - 1, 0);
					}
					else if (UiData[consoleplayer].SlotFocused == 1)
					{
						if (--UiData[consoleplayer].PSlotSubIndex < 0)
						{
							UiData[consoleplayer].PSlotSubIndex = maxSIndex;
						}
					}
					else if (UiData[consoleplayer].SlotFocused == 2)
					{
						int amt = Modifiers[consoleplayer] & OpMod_Shift ? 20 : 2;
						UiData[consoleplayer].TransferAmount = clamp(UiData[consoleplayer].TransferAmount - amt, 0, 1000);
					}
				}
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_RIGHT && UiData[consoleplayer].RepeatTics[1] % 3 == 0)
				{
					if (UiData[consoleplayer].SlotFocused == 0 && UiData[consoleplayer].FSlotIndex % InvColumns < InvColumns - 1)
					{
						UiData[consoleplayer].FSlotIndex = min(UiData[consoleplayer].FSlotIndex + 1, maxSIndex);
					}
					else if (UiData[consoleplayer].SlotFocused == 1)
					{
						if (++UiData[consoleplayer].PSlotSubIndex > maxSIndex)
						{
							UiData[consoleplayer].PSlotSubIndex = 0;
						}
					}
					else if (UiData[consoleplayer].SlotFocused == 2)
					{
						int amt = Modifiers[consoleplayer] & OpMod_Shift ? 20 : 2;
						UiData[consoleplayer].TransferAmount = clamp(UiData[consoleplayer].TransferAmount + amt, 0, 1000);
					}
				}
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_UP && UiData[consoleplayer].RepeatTics[2] % 3 == 0)
				{
					if (UiData[consoleplayer].SlotFocused == 0)
					{
						if (UiData[consoleplayer].FSlotIndex > InvColumns - 1)
						{
							UiData[consoleplayer].FSlotIndex = max(UiData[consoleplayer].FSlotIndex - InvColumns, 0);
						}
					}
					else if (UiData[consoleplayer].SlotFocused == 1)
					{
						UpdateValidItems(lastFol);
						if (--UiData[consoleplayer].PSlotIndex < 0)
						{
							UiData[consoleplayer].PSlotIndex = UiData[consoleplayer].ValidItems.Size() - 1;
						}
					}
				}
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_DOWN && UiData[consoleplayer].RepeatTics[3] % 3 == 0)
				{
					if (UiData[consoleplayer].SlotFocused == 0)
					{
						if (UiData[consoleplayer].FSlotIndex < maxSIndex - (InvColumns - 1))
						{
							UiData[consoleplayer].FSlotIndex = min(UiData[consoleplayer].FSlotIndex + InvColumns, maxSIndex);
						}
					}
					else if (UiData[consoleplayer].SlotFocused == 1)
					{
						UpdateValidItems(lastFol);
						if (++UiData[consoleplayer].PSlotIndex == UiData[consoleplayer].ValidItems.Size())
						{
							UiData[consoleplayer].PSlotIndex = 0;
						}
					}
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_ColorPicker:
			{
				int maxIndex = TColors.Size() - 1;
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_LEFT && SelectedColorIndex[consoleplayer] % PickerColumns > 0 && UiData[consoleplayer].RepeatTics[0] % 3 == 0)
				{
					SelectedColorIndex[consoleplayer] = max(SelectedColorIndex[consoleplayer] - 1, 0);
				}
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_RIGHT && SelectedColorIndex[consoleplayer] % PickerColumns < PickerColumns - 1 && UiData[consoleplayer].RepeatTics[1] % 3 == 0)
				{
					SelectedColorIndex[consoleplayer] = min(SelectedColorIndex[consoleplayer] + 1, maxIndex);
				}
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_UP && SelectedColorIndex[consoleplayer] > PickerColumns - 1 && UiData[consoleplayer].RepeatTics[2] % 3 == 0)
				{
					SelectedColorIndex[consoleplayer] = max(SelectedColorIndex[consoleplayer] - PickerColumns, 0);
				}
				if (UiData[consoleplayer].ArrowKeysHeld & HOLD_DOWN && UiData[consoleplayer].RepeatTics[3] % 3 == 0)
				{
					SelectedColorIndex[consoleplayer] = min(SelectedColorIndex[consoleplayer] + PickerColumns, maxIndex);
				}
				break;
			}
		}

		UiData[consoleplayer].RepeatTics[0] = UiData[consoleplayer].ArrowKeysHeld & HOLD_LEFT ? UiData[consoleplayer].RepeatTics[0] + 1 : 0;
		UiData[consoleplayer].RepeatTics[1] = UiData[consoleplayer].ArrowKeysHeld & HOLD_RIGHT ? UiData[consoleplayer].RepeatTics[1] + 1 : 0;
		UiData[consoleplayer].RepeatTics[2] = UiData[consoleplayer].ArrowKeysHeld & HOLD_UP ? UiData[consoleplayer].RepeatTics[2] + 1 : 0;
		UiData[consoleplayer].RepeatTics[3] = UiData[consoleplayer].ArrowKeysHeld & HOLD_DOWN ? UiData[consoleplayer].RepeatTics[3] + 1 : 0;

		if (FollowerMenuLevel[consoleplayer] != FMenu_Inventory)
		{
			UiData[consoleplayer].SlotFocused = 0;
			UiData[consoleplayer].FSlotIndex = 0;
			UiData[consoleplayer].PSlotIndex = 0;
			UiData[consoleplayer].PSlotSubIndex = 0;
		}

		if (UiData[consoleplayer].Confirmation)
		{
			if (FollowerMenuLevel[consoleplayer] == FMenu_Closed)
			{
				UiData[consoleplayer].Confirmation = false;
			}
			else
			{
				HDFollower lastFol = Selection[consoleplayer].GetLast();
				if (lastFol.Health > 0 && FollowerMenuLevel[consoleplayer] != FMenu_Miscellaneous || lastFol.Health <= 0 && FollowerMenuLevel[consoleplayer] != FMenu_Main)
				{
					UiData[consoleplayer].Confirmation = false;
				}
			}
		}

		if (UiData[consoleplayer].SlotFocused < 2)
		{
			UiData[consoleplayer].TransferAmount = 0;
		}

		if (UiData[consoleplayer].SlotFocused < 1)
		{
			UiData[consoleplayer].PSlotSubIndex = 0;
		}

		int size = UiData[consoleplayer].ValidItems.Size();
		UiData[consoleplayer].PSlotIndex = clamp(UiData[consoleplayer].PSlotIndex, 0, size - 1);
		if (size > 0 && !UiData[consoleplayer].ValidItems[UiData[consoleplayer].PSlotIndex])
		{
			UiData[consoleplayer].ValidItems.Delete(UiData[consoleplayer].PSlotIndex);
			if (UiData[consoleplayer].SlotFocused == 2)
			{
				UiData[consoleplayer].SlotFocused = 1;
				UiData[consoleplayer].TransferAmount = 0;
			}
		}
	}

	// ----------------------------------------------------------------------
	//
	// COMMAND MENU
	//
	// ----------------------------------------------------------------------

	private ui void DrawCommandMenu(HDStatusBar sb, vector2 pos, int flags)
	{
		vector2 OriginalPos = pos;
		int rectHeight = MainFont.mFont.GetHeight() + 4;

		// [Ace] This is still valid even when multiple followers are selected.
		// [24.09.2021] Note to self: before you freak out again that "THE INVENTORY MENUS ARE BUGGED", keep in mind that dead and hostile followers are always
		// excluded from the selection. They will not mess up all of the lastFol conditions because lastFol is GUARANTEED to be a living being. Friendly, too.

		HDFollower lastFol = Selection[consoleplayer].GetLast();
		int selSize = Selection[consoleplayer].SelFollowers.Size();

		switch (FollowerMenuLevel[consoleplayer])
		{
			case FMenu_Recruitment:
			{
				if (!SelMarine[consoleplayer] || SelMarine[consoleplayer].Health <= 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				Array<string> Commands;
				Commands.Push("Recruit?");
				Commands.Push("Cancel");

				string n = (SelMarine[consoleplayer].bFRIENDLY ? "Friendly " : "Hostile ").."marine";
				DrawRectangle(sb, pos, (140, rectHeight), MainFont, GetTruncatedText(n, 16), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += rectHeight + Spacing;

				for (int i = 0; i < Commands.Size(); ++i)
				{
					DrawRectangle(sb, pos, (140, rectHeight), MainFont, (i + 1)..") "..Commands[i], flags);
					pos.y += rectHeight + Spacing;
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Followers:
			{
				if (Followers.Size() == 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				
				int FSize = Followers.Size();
				int RelSize = min(FollowersPerPage, FSize - FollowersPerPage * FollowerPage[consoleplayer]);
				if (RelSize > 4)
				{
					pos.y -= (rectHeight * 2 - 4) * 4;
				}

				int LastIndex = 0;
				for (int i = FollowersPerPage * FollowerPage[consoleplayer]; i < min(FollowersPerPage * (FollowerPage[consoleplayer] + 1), FSize); ++i)
				{
					LastIndex++;
					bool Valid = Followers[i].CanInteractWith(false);
					int FollowerBlockSize = Valid ? rectHeight * 2 - 2 : rectHeight;
					DrawFollowerRectangle(sb, pos, (150, FollowerBlockSize), MainFont, LastIndex, Followers[i], Valid, flags);
					pos.y += FollowerBlockSize + Spacing;
				}
				if (FSize > FollowersPerPage * (FollowerPage[consoleplayer] + 1))
				{
					LastIndex++;
					DrawRectangle(sb, pos, (150, rectHeight), MainFont, LastIndex..") Next...", flags);
					pos.y += rectHeight + Spacing;
				}
				if (FollowerPage[consoleplayer] > 0)
				{
					LastIndex++;
					if (LastIndex == 10)
					{
						LastIndex = 0;
					}
					DrawRectangle(sb, pos, (150, rectHeight), MainFont, LastIndex..") Back...", flags);
					pos.y += rectHeight + Spacing;
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Main:
			{
				if (!lastFol || lastFol.LinkedPlayer != players[consoleplayer].mo || !lastFol.bFRIENDLY && lastFol.Health > 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				if (selSize > 1)
				{
					DrawRectangle(sb, pos, (160, rectHeight), MainFont, selSize.." followers", flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += rectHeight + Spacing;

					DrawRectangle(sb, pos, (160, rectHeight), MainFont, "1) Orders", flags);
					pos.y += rectHeight + Spacing;

					DrawRectangle(sb, pos, (160, rectHeight), MainFont, InInputMode[consoleplayer] ? InputString[consoleplayer].."_" : "2) Input command", flags);
					pos.y += rectHeight + Spacing;

					DrawRectangle(sb, pos, (160, rectHeight), MainFont, "3) Misc commands", flags);
					pos.y += rectHeight + Spacing;

					if (Followers.Size() > 1)
					{
						DrawRectangle(sb, pos, (160, rectHeight), MainFont, "4) Back...", flags);
					}
				}
				else if (lastFol.Health <= 0)
				{
					DrawRectangle(sb, pos, (260, rectHeight), MainFont, GetTruncatedText(lastFol.GetTag(), 27), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += rectHeight + Spacing;

					int RequiredSips = lastFol.GetRequiredSips();
					int RequiredBlood = lastFol.GetRequiredBlood();
					string BloodDanger;
					if (RequiredBlood < 10)
					{
						BloodDanger = "\c[FLW_BloodGreen](Safe)\c-";
					}
					else if (RequiredBlood < 20)
					{
						BloodDanger = "\c[FLW_BloodPoison](Risky)\c-";
					}
					else if (RequiredBlood < 30)
					{
						BloodDanger = "\c[FLW_BloodYellow](Dangerous)\c-";
					}
					else if (RequiredBlood < 40)
					{
						BloodDanger = "\c[FLW_BloodOrange](Extremely Risky)\c-";
					}
					else if (RequiredBlood < 50)
					{
						BloodDanger = "\c[FLW_BloodRed](Almost Deadly)\c-";
					}
					else
					{
						BloodDanger = "\c[FLW_BloodBlack](Certain Death)\c-";
					}

					Array<string> Commands;
					Commands.Push("Carry follower");
					if (lastFol.ResurrectType & HDFollower.RESF_BLUES)
					{
						Commands.Push((sb.CheckInventory("BluePotion", 1) ? "" : "\c[Red]").."Give blue potion\c- ".."\c[Blue]("..RequiredSips.."/12)\c-");
					}
					if (lastFol.ResurrectType & HDFollower.RESF_BLOOD)
					{
						Commands.Push("Feed blood "..BloodDanger);
					}
					Commands.Push("Manage inventory");
					if (lastFol.bCANDISMISS)
					{
						Commands.Push("\c[FLW_BloodRed]"..(UiData[consoleplayer].Confirmation ? "Confirm?" : "Dismiss").."\c-");
					}
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawRectangle(sb, pos, (260, rectHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += rectHeight + Spacing;
					}
				}
				else
				{
					DrawRectangle(sb, pos, (160, rectHeight), MainFont, GetTruncatedText(lastFol.GetTag(), 20), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += rectHeight + Spacing;

					if (Followers.Size() == 1 && lastFol.CanInteractWith(false))
					{
						double Dist = lastFol.Distance3D(lastFol.LinkedPlayer) / HDCONST_ONEMETRE;
						DrawRectangle(sb, pos, (160, rectHeight), MainFont, String.Format("%.2fm", Dist), flags, Font.CR_DARKGRAY);
						pos.y += rectHeight + Spacing;
					}

					Array<string> Commands;
					Commands.Push("Orders");
					Commands.Push("Carry follower");
					Commands.Push("Manage inventory");
					Commands.Push("Misc commands");
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawRectangle(sb, pos, (160, rectHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += rectHeight + Spacing;
					}
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Orders:
			{
				if (!lastFol || lastFol.LinkedPlayer != players[consoleplayer].mo)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				static const string Orders[] = { "Follow", "Follow and ignore hostiles", "Stay and provide cover", "Go there and provide cover", "Come and help me", "Do some healing" };

				if (selSize > 1)
				{
					DrawRectangle(sb, pos, (240, rectHeight), MainFont, selSize.." followers", flags, Font.FindFontColor('FLW_NameBlue'));
				}
				else
				{
					DrawRectangle(sb, pos, (240, rectHeight), MainFont, GetTruncatedText(lastFol.GetTag(), 30), flags, Font.FindFontColor('FLW_NameBlue'));
				}
				pos.y += rectHeight + Spacing;

				for (int i = 0; i < Orders.Size(); ++i)
				{
					DrawRectangle(sb, pos, (240, rectHeight), MainFont, (i + 1)..") "..(selSize == 1 && lastFol.Order == i ? "\c[Green]" : "")..Orders[i].."\c-", flags);
					pos.y += rectHeight + Spacing;
				}
				DrawRectangle(sb, pos, (240, rectHeight), MainFont, (Orders.Size() + 1)..") Back...", flags);
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Inventory:
			{
				if (!lastFol || lastFol.LinkedPlayer != players[consoleplayer].mo)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				int w = InvColumns * SlotSize + (InvColumns - 1) + 2;
				int wHeight = rectHeight * 3;

				pos.y -= 70;

				int wSize = lastFol.Weapons.Size();
				if (wSize > 1)
				{
					for (int i = 0; i < wSize; ++i)
					{
						DrawWeaponRectangle(sb, pos + (0, (wHeight + Spacing) * i) - (0, wSize > 7 ? (wHeight + Spacing) * (wSize - 7) : 0), (w, wHeight), MainFont, flags, lastFol, lastFol.Weapons[i]);
					}
					pos.x += w + Spacing;
				}

				let arm = HDArmourWorn(lastFol.FindInventory("HDArmourWorn"));
				bool showArmor = arm && UiData[consoleplayer].SlotFocused == 0;
				if (showArmor)
				{
					DrawArmorRectangle(sb, pos + (w + Spacing, rectHeight + Spacing), (wHeight, wHeight), flags, arm);	
				}

				DrawRectangle(sb, pos, (w + (showArmor ? wHeight + Spacing : 0), rectHeight), MainFont, GetTruncatedText(lastFol.GetTag(), 30), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += rectHeight + Spacing;

				if (wSize == 1)
				{
					DrawWeaponRectangle(sb, pos, (w, wHeight), MainFont, flags, lastFol, lastFol.Weapons[0], selSize > 1 ? 1 : 0);
					pos.y += wHeight + Spacing;
				}

				int rows = int(ceil(HDFollower.SlotCount / double(InvColumns)));
				int invh = rows * SlotSize + (rows - 1) + 2;
				DrawFollowerInventory(sb, pos, (w, invh), MainFont, flags, lastFol);

				if (UiData[consoleplayer].SlotFocused > 0)
				{
					DrawPlayerInventory(sb, pos + (w + 1, 0), (w, invh), MainFont, flags);
				}
				pos.y += invh;

				DrawRectangle(sb, pos, (w, rectHeight), MainFont, "1) Cancel/Back", flags);
				pos.y += rectHeight + Spacing;

				if (lastFol.CanInteractWith(false))
				{
					DrawRectangle(sb, pos, (w, rectHeight), MainFont, InInputMode[consoleplayer] ? InputString[consoleplayer].."_" : "2) Input command", flags);
					pos.y += rectHeight + Spacing;
				}

				DrawRectangle(sb, pos, (w, rectHeight), MainFont, "Bsp) Take", flags); pos.y += rectHeight + Spacing;
				DrawRectangle(sb, pos, (w, rectHeight), MainFont, "Ent) Select/Give", flags); pos.y += rectHeight + Spacing;
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Miscellaneous:
			{
				if (!lastFol || lastFol.LinkedPlayer != players[consoleplayer].mo)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				if (selSize > 1)
				{
					DrawRectangle(sb, pos, (200, rectHeight), MainFont, selSize.." followers", flags, Font.FindFontColor('FLW_NameBlue'));
				}
				else
				{
					DrawRectangle(sb, pos, (200, rectHeight), MainFont, GetTruncatedText(lastFol.GetTag(), 24), flags, Font.FindFontColor('FLW_NameBlue'));
				}
				pos.y += rectHeight + Spacing;

				Array<string> Commands;
				if (!(lastFol.bDONTTRANSLATE))
				{
					Commands.Push("Change color");
				}
				if (selSize == 1 && lastFol.bCANDISMISS)
				{
					Commands.Push("\c[FLW_BloodRed]"..(UiData[consoleplayer].Confirmation ? "Confirm?" : "Dismiss").."\c-");
				}
				Commands.Push("Back...");

				for (int i = 0; i < Commands.Size(); ++i)
				{
					DrawRectangle(sb, pos, (200, rectHeight), MainFont, (i + 1)..") "..Commands[i], flags);
					pos.y += rectHeight + Spacing;
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_ColorPicker:
			{
				if (!lastFol || lastFol.LinkedPlayer != players[consoleplayer].mo)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				int tSize = TColors.Size();
				int rows = int(ceil(tSize / double(PickerColumns)));
				double w = PickerColumns * ColSquareSize + (PickerColumns - 1) + 2;
				double h = rows * ColSquareSize + (rows - 1) + 2;

				if (selSize > 1)
				{
					DrawRectangle(sb, pos, (w, rectHeight), MainFont, selSize.." followers", flags, Font.FindFontColor('FLW_NameBlue'));
				}
				else
				{
					DrawRectangle(sb, pos, (w, rectHeight), MainFont, GetTruncatedText(lastFol.GetTag(), int(ceil(w / 8))), flags, Font.FindFontColor('FLW_NameBlue'));
				}
				pos.y += rectHeight + Spacing;

				sb.Fill(UiData[consoleplayer].UiColor, pos.x, pos.y, w, h, flags);
				for (int i = 0; i < tSize; ++i)
				{
					if (SelectedColorIndex[consoleplayer] == i)
					{
						Color selCol = Color(255, int(TColors[i].r * 1.5), int(TColors[i].g * 1.5), int(TColors[i].b * 1.5));
						sb.Fill(selCol, pos.x + (ColSquareSize + 1) * (i % PickerColumns), pos.y + (ColSquareSize + 1) * (i / PickerColumns), ColSquareSize + 2, ColSquareSize + 2, flags);
					}
					sb.Fill(TColors[i], pos.x + 1 + (ColSquareSize + 1) * (i % PickerColumns), pos.y + 1 + (ColSquareSize + 1) * (i / PickerColumns), ColSquareSize, ColSquareSize, flags);
				}

				DrawRectangle(sb, pos + (0, h + 1), (w, rectHeight), MainFont, "0) Back", flags);
				pos.y += rectHeight + Spacing;
				break;
			}

		}
	}

	// ----------------------------------------------------------------------
	//
	// UI FUNCTIONS
	//
	// ----------------------------------------------------------------------

	private ui void DrawFollowerRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int index, HDFollower flw, bool valid, int flags)
	{
		bool selected = Selection[consoleplayer].SelFollowers.Find(flw) != Selection[consoleplayer].SelFollowers.Size();
		Color c = valid ? (selected ? Color(128, 96, 255, 96) : UiData[consoleplayer].UiColor) : Color(128, 255, 16, 16);
		sb.Fill(c, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		pos += (2, 2);
		int FontHeight = fnt.mFont.GetHeight();
		sb.DrawString(fnt, index..") "..GetTruncatedText(flw.GetTag(), 15), pos, flags, Font.FindFontColor('FLW_NameBlue')); pos.y += FontHeight + 1;

		if (valid)
		{
			double Dist = flw.Distance3D(flw.LinkedPlayer) / HDCONST_ONEMETRE;
			sb.DrawString(fnt, String.Format("%.2fm", Dist), pos, flags, Font.CR_DARKGRAY); pos.y += FontHeight + 1;
		}
	}

	private ui void DrawWeaponRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int flags, HDFollower flw, FollowerWeapon wpn, int flags2 = 0)
	{
		// [Ace] flags2 values are as follows:
		// 1 - multiselect

		sb.Fill(UiData[consoleplayer].UiColor, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		sb.DrawString(fnt, wpn.GetName(), pos + (2, 2), flags, Font.FindFontColor('FLW_WeaponBlue'));

		sb.DrawString(fnt, sb.FormatNumber(flw.Weapons.Find(wpn) + 1, 1, 3), pos + (size.x - 4, 2), flags | sb.DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD);

		// [Ace] Icon.
		sb.DrawImage(wpn.GetIcon(), pos + (4, 12), flags | sb.DI_ITEM_LEFT_TOP, 1.0, (size.x / 2, 17));

		// [Ace] Spare ammo.
		if (!(flags2 & 1))
		{
			class<HDAmmo> AType, MType; int MaxMag;
			[AType, MType, MaxMag] = wpn.GetAmmoType();

			sb.DrawString(fnt, "Ammo", pos + (size.x - 4, size.y - 24), flags | sb.DI_TEXT_ALIGN_RIGHT, Font.CR_WHITE);
			string ChamberString = "";
			switch (wpn.ChamberedRound)
			{
				case FollowerWeapon.CRType_Chambered: ChamberString = "+"; break;
				case FollowerWeapon.CRType_Spent: ChamberString = "_"; break;
			}
			sb.DrawString(fnt, ChamberString..sb.FormatNumber(flw.GetAmount(MType ? MType : AType), 1, 4), pos + (size.x - 4, size.y - 15), flags | sb.DI_TEXT_ALIGN_RIGHT, Font.CR_WHITE);

			// [Ace] Magazine bar.
			sb.Fill(UiData[consoleplayer].UiColor, pos.x + 1, pos.y + (size.y - 4), size.x - 2, 1, flags);
			sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + (size.y - 3), size.x - 2, 2, flags);
			int mag = MaxMag == 1 ? int(wpn.ChamberedRound == wpn.CRType_Chambered) : wpn.Mag;
			double amPercent = clamp(mag / double(MaxMag), 0, 1.0);
			sb.Fill(GetPercentColor(amPercent), pos.x + 1, pos.y + (size.y - 3), (size.x - 2) * AmPercent, 2, flags);
		}
	}

	private ui void DrawFollowerInventory(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int flags, HDFollower flw)
	{
		sb.Fill(UiData[consoleplayer].UiColor, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		for (int i = 0; i < HDFollower.SlotCount; ++i)
		{
			vector2 realPos = (SlotSize * (i % InvColumns) + (i % InvColumns), SlotSize * (i / InvColumns) + (i / InvColumns));

			Color col;
			switch (UiData[consoleplayer].FSlotIndex == i ? (UiData[consoleplayer].SlotFocused > 0 ? 2 : 1) : 0)
			{
				case 0: col = UiData[consoleplayer].UiColor; break;
				case 1: col = Color(128, 255, 255, 128); break;
				case 2: col = Color(96, 96, 255, 96); break;
			}
			sb.Fill(col, pos.x + 1 + realPos.x, pos.y + 1 + realPos.y, SlotSize, SlotSize, flags);
			sb.Fill(Color(128, 0, 0, 0), pos.x + 2 + realPos.x, pos.y + 2 + realPos.y, SlotSize - 2, SlotSize - 2, flags);

			let item = flw.Slots[i];
			if (item)
			{
				sb.DrawImage(item.Icon, pos + (1, 1) + (SlotSize, SlotSize) / 2 + realPos, flags | sb.DI_ITEM_CENTER, 1.0, (SlotSize, SlotSize) - (6, 6), (3.0, 3.0));
				if (InventorySlot.IsRealMag(item.ItemClass) || item.Amount > int(!item.Multipickup))
				{
					sb.DrawString(sb.mAmountFont, sb.FormatNumber(item.Amount, 1, 4), pos + (3, SlotSize - 8) + realPos, flags, Font.CR_GOLD);
				}
			}
		}
	}

	// [Ace] Contrary to what the function is called, it only draws the *valid* items.
	private ui void DrawPlayerInventory(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int flags)
	{
		sb.Fill(UiData[consoleplayer].UiColor, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		for (int i = 0; i < HDFollower.SlotCount; ++i)
		{
			vector2 realPos = (SlotSize * (i % InvColumns) + (i % InvColumns), SlotSize * (i / InvColumns) + (i / InvColumns));

			Color col;
			switch (UiData[consoleplayer].PSlotSubIndex == i ? (UiData[consoleplayer].SlotFocused > 1 ? 2 : 1) : 0)
			{
				case 0: col = UiData[consoleplayer].UiColor; break;
				case 1: col = Color(128, 255, 255, 128); break;
				case 2: col = Color(96, 96, 255, 96); break;
			}
			sb.Fill(col, pos.x + 1 + RealPos.x, pos.y + 1 + RealPos.y, SlotSize, SlotSize, flags);
			sb.Fill(Color(128, 0, 0, 0), pos.x + 2 + RealPos.x, pos.y + 2 + RealPos.y, SlotSize - 2, SlotSize - 2, flags);
		}

		int vSize = UiData[consoleplayer].ValidItems.Size();
		HDPickup item = vSize > 0 && UiData[consoleplayer].PSlotIndex < vSize ? UiData[consoleplayer].ValidItems[UiData[consoleplayer].PSlotIndex] : null;
		if (!item)
		{
			return;
		}

		int count = item is 'HDMagAmmo' ? HDMagAmmo(item).Mags.Size() : (!item.bMULTIPICKUP ? item.Amount : 1);
		for (int i = 0; i < min(count, HDFollower.SlotCount); ++i)
		{
			vector2 realPos = (SlotSize * (i % InvColumns) + (i % InvColumns), SlotSize * (i / InvColumns) + (i / InvColumns));
			int amt = item.Amount;
			if (item is 'HDMagAmmo')
			{
				HDMagAmmo mag = HDMagAmmo(item);
				amt = mag.Mags[i];
			}
			string icon = AceCore.GetIcon(item, amt);
			sb.DrawImage(icon, pos + (1, 1) + (SlotSize, SlotSize) / 2 + RealPos, flags | sb.DI_ITEM_CENTER, 1.0, (SlotSize, SlotSize) - (6, 6), (3.0, 3.0));
			if (InventorySlot.IsRealMag(item.GetClass()) || item.bMULTIPICKUP && item.Amount > 0)
			{
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(amt, 1, 4), pos + (3, SlotSize - 8) + realPos, flags, Font.CR_GOLD);
			}
		}

		if (UiData[consoleplayer].SlotFocused == 2)
		{
			int rectHeight = MainFont.mFont.GetHeight() + 4;
			DrawAmountRectangle(sb, pos + (0, size.y + 1), (size.x, rectHeight), fnt, UiData[consoleplayer].TransferAmount, 1000, flags, Font.CR_CREAM);
		}
	}

	private ui void DrawAmountRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int amt, int maxAmt, int flags, int col = Font.CR_WHITE)
	{
		sb.Fill(UiData[consoleplayer].UiColor, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);
		double percent = amt / double(maxAmt);
		sb.Fill(Color(32, 255, 255, 128), pos.x + 1, pos.y + 1, (size.x - 2) * percent, size.y - 2, flags);
		sb.DrawString(fnt, "Amount:"..amt, pos + (2, 2), flags, col);
	}

	private ui void DrawArmorRectangle(HDStatusBar sb, vector2 pos, vector2 size, int flags, HDArmourWorn arm)
	{
		sb.Fill(UiData[consoleplayer].UiColor, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		sb.DrawImage(AceCore.GetIcon(arm), pos + size / 2, flags | sb.DI_ITEM_CENTER, box: size - (5, 5));
		sb.DrawString(MainFont, (arm.Mega ? "\c[Blue]" : "\c[DarkGreen]")..arm.Durability, pos + size - (4, 10), flags | sb.DI_TEXT_ALIGN_RIGHT);
	}

	private ui void DrawRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, string command, int flags, int col = Font.CR_WHITE)
	{
		sb.Fill(UiData[consoleplayer].UiColor, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);
		if (command != "")
		{
			sb.DrawString(fnt, command, (pos.x + 2, pos.y + (size.y - fnt.mFont.GetHeight()) / 2), flags, col); 
		}
	}

	// ----------------------------------------------------------------------
	//
	// INPUT PROCESS
	//
	// ----------------------------------------------------------------------

	override bool InputProcess(InputEvent e)
	{
		// [Ace] This exists so that your input isn't arbitrarily intercepted when it shouldn't be. Returning directly won't fly.
		bool ret = false;

		bool IsShift = e.KeyScan == InputEvent.Key_LShift || e.KeyScan == InputEvent.Key_RShift;
		bool IsCtrl = e.KeyScan == InputEvent.Key_LCtrl || e.KeyScan == InputEvent.Key_RCtrl;
		bool IsAlt = e.KeyScan == InputEvent.Key_LAlt || e.KeyScan == InputEvent.Key_RAlt;
		if (IsShift || IsCtrl || IsAlt)
		{
			if (e.Type == InputEvent.Type_KeyDown)
			{
				SendNetworkEvent("HDF_SetModifiers", 1, IsShift ? OpMod_Shift : (IsAlt ? OpMod_Alt : OpMod_Ctrl));
			}
			else if (e.Type == InputEvent.Type_KeyUp)
			{
				SendNetworkEvent("HDF_SetModifiers", 0, IsShift ? OpMod_Shift : (IsAlt ? OpMod_Alt : OpMod_Ctrl));
			}
		}

		if (e.Type == InputEvent.Type_KeyDown)
		{
			switch (e.KeyScan)
			{
				case InputEvent.Key_LeftArrow: UiData[consoleplayer].ArrowKeysHeld |= HOLD_LEFT; break;
				case InputEvent.Key_RightArrow: UiData[consoleplayer].ArrowKeysHeld |= HOLD_RIGHT; break;
				case InputEvent.Key_UpArrow: UiData[consoleplayer].ArrowKeysHeld |= HOLD_UP; break;
				case InputEvent.Key_DownArrow: UiData[consoleplayer].ArrowKeysHeld |= HOLD_DOWN; break;
			}
		}
		else if (e.Type == InputEvent.Type_KeyUp)
		{
			switch (e.KeyScan)
			{
				case InputEvent.Key_LeftArrow: UiData[consoleplayer].ArrowKeysHeld &= ~HOLD_LEFT; break;
				case InputEvent.Key_RightArrow: UiData[consoleplayer].ArrowKeysHeld &= ~HOLD_RIGHT; break;
				case InputEvent.Key_UpArrow: UiData[consoleplayer].ArrowKeysHeld &= ~HOLD_UP; break;
				case InputEvent.Key_DownArrow: UiData[consoleplayer].ArrowKeysHeld &= ~HOLD_DOWN; break;
			}
		}
		
		// --------------------------------------------------------------------------------
		// THIS IS WHERE THE REAL FUN BEGINS
		// --------------------------------------------------------------------------------

		if (FollowerMenuLevel[consoleplayer] > FMenu_Closed && e.Type == InputEvent.Type_KeyDown)
		{
			if (InInputMode[consoleplayer])
			{
				switch (e.KeyScan)
				{
					case InputEvent.Key_Enter:
					{
						InInputMode[consoleplayer] = false;
						ret = true;
						break;
					}

					// Delete last character.
					case InputEvent.Key_Backspace:
					{
						InputString[consoleplayer].DeleteLastCharacter();
						return true;
					}

					default:
					{
						if (InputString[consoleplayer].Length() < 17 && e.KeyChar >= 32 && e.KeyChar <= 126) // [Ace] Only valid characters.
						{
							InputString[consoleplayer] = InputString[consoleplayer]..String.Format("%c", e.KeyChar);
						}
						return true;
					}
				}
			}

			int NumKey = e.KeyChar - 48;
			if (NumKey == 0)
			{
				NumKey = 10;
			}

			Array<FollowerCommand> Commands;
			switch (FollowerMenuLevel[consoleplayer])
			{
				case FMenu_Recruitment:
				{
					Commands.Push(CreateCommand("HDF_ConfirmRecruitment"));
					Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Closed));
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Followers:
				{
					if (e.KeyScan == InputEvent.Key_Enter)
					{
						SendNetworkEvent("HDF_ApplySelection");
						ret = true;
					}
					else if (Modifiers[consoleplayer] & OpMod_Ctrl)
					{
						int Page = Modifiers[consoleplayer] & OpMod_Alt ? FollowerPage[consoleplayer] : -1;
						switch (e.KeyChar)
						{
							// [Ace] A - Select (A)ll, (I)nvert, (D)eselect.
							case 65: case 97:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 0, Page);
								break;
							}
							case 73: case 105:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 1, Page);
								break;
							}
							case 68: case 100:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 2, Page);
								break;
							}
						}
						ret = true;
					}
					else
					{
						int FSize = Followers.Size();
						int RelSize = min(FollowersPerPage, FSize - FollowersPerPage * FollowerPage[consoleplayer]);
						bool HasMorePages = FSize > FollowersPerPage * (FollowerPage[consoleplayer] + 1);
						int SelIndex = (NumKey + FollowersPerPage * FollowerPage[consoleplayer]) - 1;
						if (NumKey == RelSize + 1 && HasMorePages)
						{
							SendNetworkEvent("HDF_SetFollowerPage", 1);
						}
						else if (FollowerPage[consoleplayer] > 0 && NumKey == RelSize + (HasMorePages ? 2 : 1))
						{
							SendNetworkEvent("HDF_SetFollowerPage", 0);
						}
						else if (NumKey > 0 && (NumKey - 1) < RelSize)
						{
							if (Modifiers[consoleplayer] & OpMod_Shift)
							{
								SendNetworkEvent("HDF_ToggleSelection", SelIndex);
							}
							else
							{
								SendNetworkEvent("HDF_ToggleSelection", SelIndex, true);
								SendNetworkEvent("HDF_ApplySelection");
							}
						}
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Main:
				{
					HDFollower lastFol = Selection[consoleplayer].GetLast();
					int selSize = Selection[consoleplayer].SelFollowers.Size();

					if (selSize > 1)
					{
						if (e.KeyScan == InputEvent.Key_Enter && !InInputMode[consoleplayer] && ret)
						{
							if (!InInputMode[consoleplayer] && ret)
							{
								ProcessInputString(InputString[consoleplayer], lastFol, selSize > 1);
								return true;
							}
						}
						switch (NumKey)
						{
							case 1:
							{
								SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Orders);
								break;
							}
							case 2:
							{
								InInputMode[consoleplayer] = true;
								ret = true;
								break;
							}
							case 3:
							{
								SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Miscellaneous);
								break;
							}
							case 4:
							{
								if (Followers.Size() > 1)
								{
									SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Followers);
								}
								break;
							}
						}
					}
					else if (lastFol.Health <= 0)
					{
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						if (lastFol.ResurrectType & HDFollower.RESF_BLUES)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 0));
						}
						if (lastFol.ResurrectType & HDFollower.RESF_BLOOD)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 1));
						}
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Inventory));
						if (lastFol.bCANDISMISS)
						{
							if (UiData[consoleplayer].Confirmation)
							{
								Commands.Push(CreateCommand("HDF_DismissFollower"));
							}
							else
							{
								Commands.Push(CreateCommand("HDF_ToggleConfirmation", true, useUiHandler: true));
							}
						}
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}
					}
					else if (lastFol.bFRIENDLY)
					{
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Orders));
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Inventory));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Miscellaneous));
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------
					
				case FMenu_Orders:
				{
					Commands.Push(CreateCommand("HDF_ChangeOrders", HDFollower.FOrder_Follow));
					Commands.Push(CreateCommand("HDF_ChangeOrders", HDFollower.FOrder_FollowIgnore));
					Commands.Push(CreateCommand("HDF_ChangeOrders", HDFollower.FOrder_Cover));
					Commands.Push(CreateCommand("HDF_ChangeOrders", HDFollower.FOrder_GoAndCover));
					Commands.Push(CreateCommand("HDF_ChangeOrders", HDFollower.FOrder_ComeAndHelp));
					Commands.Push(CreateCommand("HDF_ChangeOrders", HDFollower.FOrder_HealSelf));
					Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Main));
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Inventory:
				{
					HDFollower lastFol = Selection[consoleplayer].GetLast();
					int selSize = Selection[consoleplayer].SelFollowers.Size();

					// [Ace] Navigation.
					int maxSIndex = HDFollower.SlotCount - 1;
					switch (e.KeyScan)
					{
						case InputEvent.Key_Enter:
						{
							if (!InInputMode[consoleplayer] && ret)
							{
								ProcessInputString(InputString[consoleplayer], lastFol, selSize > 1);
								return true;
							}

							if (selSize > 1)
							{
								break;
							}

							if (UiData[consoleplayer].SlotFocused == 0)
							{
								UpdateValidItems(lastFol);
								UiData[consoleplayer].SlotFocused++;
								for (int i = 0; i < UiData[consoleplayer].ValidItems.Size(); ++i)
								{
									class<HDAmmo> AType, MType; int MaxMag;
									[AType, MType, MaxMag] = lastFol.Weapons[0].GetAmmoType();

									InventorySlot selSlot = lastFol.Slots[UiData[consoleplayer].FSlotIndex];
									class<HDPickup> itemcls = UiData[consoleplayer].ValidItems[i].GetClass();
									if (SelSlot && SelSlot.ItemClass == itemcls || !SelSlot && itemcls == (MType ? MType : AType))
									{
										UiData[consoleplayer].PSlotIndex = i;
										break;
									}
								}
							}
							else if (UiData[consoleplayer].SlotFocused == 1)
							{
								int size = UiData[consoleplayer].ValidItems.Size();
								if (size > 0 && UiData[consoleplayer].PSlotIndex < size)
								{
									HDPickup item = UiData[consoleplayer].ValidItems[UiData[consoleplayer].PSlotIndex];
									if (IsValidIndex(item, UiData[consoleplayer].PSlotSubIndex))
									{
										if (item is 'HDMagAmmo' || !item.bMULTIPICKUP)
										{
											if (item is 'HDMagAmmo')
											{
												SendNetworkEvent('hdf_transfermag:'..item.GetClassName(), UiData[consoleplayer].PSlotSubIndex, UiData[consoleplayer].FSlotIndex);
											}
											else
											{
												SendNetworkEvent('hdf_transferitem:'..item.GetClassName(), 1, UiData[consoleplayer].FSlotIndex);
											}
										}
										else
										{
											UiData[consoleplayer].SlotFocused++;
										}
									}
									UpdateValidItems(lastFol);
								}
								else
								{
									UiData[consoleplayer].SlotFocused--;
								}
							}
							else if (UiData[consoleplayer].SlotFocused == 2)
							{
								int size = UiData[consoleplayer].ValidItems.Size();
								if (size > 0 && UiData[consoleplayer].PSlotIndex < size)
								{
									HDPickup item = UiData[consoleplayer].ValidItems[UiData[consoleplayer].PSlotIndex];
									SendNetworkEvent('hdf_transferitem:'..item.GetClassName(), UiData[consoleplayer].TransferAmount, UiData[consoleplayer].FSlotIndex);
									UiData[consoleplayer].SlotFocused = 0;
								}
								else
								{
									UiData[consoleplayer].SlotFocused = 0;
								}
							}
							ret = true;
							break;
						}
						case InputEvent.Key_Backspace:
						{
							if (selSize > 1)
							{
								break;
							}
							if (lastFol.Slots[UiData[consoleplayer].FSlotIndex] && UiData[consoleplayer].SlotFocused < 2)
							{
								SendNetworkEvent("HDF_TakeInvItem", UiData[consoleplayer].FSlotIndex);
								ret = true;
							}
							break;
						}
					}

					if (NumKey == 2)
					{
						InInputMode[consoleplayer] = true;
						ret = true;
						break;
					}
					if (NumKey == 1)
					{
						if (UiData[consoleplayer].SlotFocused > 0)
						{
							UiData[consoleplayer].SlotFocused--;
						}
						else
						{
							SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main);
						}
						ret = true;
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Miscellaneous:
				{
					HDFollower lastFol = Selection[consoleplayer].GetLast();
					int selSize = Selection[consoleplayer].SelFollowers.Size();

					if (!(lastFol.bDONTTRANSLATE))
					{
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_ColorPicker));
					}
					if (selSize == 1 && lastFol.bCANDISMISS)
					{
						if (UiData[consoleplayer].Confirmation)
						{
							Commands.Push(CreateCommand("HDF_DismissFollower"));
						}
						else
						{
							Commands.Push(CreateCommand("HDF_ToggleConfirmation", true, useUiHandler: true));
						}
					}
					Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Main));
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_ColorPicker:
				{
					if (e.KeyScan == InputEvent.Key_Enter)
					{
						SendNetworkEvent("HDF_ChangeColor", SelectedColorIndex[consoleplayer]);
						ret = true;
					}
					if (NumKey == 10)
					{
						SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main);
						ret = true;
					}
					break;
				}
			}

			if (NumKey > 0 && NumKey - 1 < Commands.Size())
			{
				FollowerCommand cmd = Commands[NumKey - 1];
				if (cmd.useUiHandler)
				{
					HandleUiCommand(cmd);
				}
				else
				{
					SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
				}
			}

			// [Ace] Block 0-9 keys from affecting the world.
			if (NumKey >= 0 && NumKey <= 10)
			{
				ret = true;
			}

			if (!(Modifiers[consoleplayer] & OpMod_Shift))
			{
				// [Ace] Exit.
				int Key1, Key2;
				[Key1, Key2] = Bindings.GetKeysForCommand("HDF_OpenMenu");
				if (e.KeyScan == Key1 || e.KeyScan == Key2)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					ret = true;
				}
			}
			else if (FollowerMenuLevel[consoleplayer] == FMenu_Followers) // [Ace] Used only with the 0-9 keys.
			{
				SendNetworkEvent("HDF_OpenMenu");
			}
		}
		return ret;
	}

	// ----------------------------------------------------------------------
	//
	// UI COMMAND HANDLER
	//
	// ----------------------------------------------------------------------

	private ui void HandleUiCommand(FollowerCommand cmd)
	{
		if (cmd.EventName ~== "HDF_ToggleConfirmation")
		{
			UiData[consoleplayer].Confirmation = cmd.Args[0];
			return;
		}
	}

	// ----------------------------------------------------------------------
	//
	// NETWORK PROCESS
	//
	// ----------------------------------------------------------------------

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "HDF_SetModifiers")
		{
			switch (e.Args[0])
			{
				case 0: Modifiers[e.Player] &= ~e.Args[1]; break;
				case 1: Modifiers[e.Player] |= e.Args[1]; break;
			}
			return;
		}

		if (e.Name ~== "HDF_SetFollowerPage")
		{
			switch (e.Args[0])
			{
				case 0: FollowerPage[e.Player]--; break;
				case 1: FollowerPage[e.Player]++; break;
			}
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_rename") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");

			if (split.Size() < 2)
			{
				return;
			}

			let plr = players[e.Player].mo;
			FLineTraceData data;
			plr.LineTrace(plr.angle, HDCONST_ONEMETRE * 100, plr.pitch, TRF_SOLIDACTORS | TRF_THRUBLOCK, plr.height - 5, data: data);
			if (data.HitActor is 'HDFollower')
			{
				data.HitActor.SetTag(split[1]);
			}
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_resetfollower") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");

			if (split.Size() < 2)
			{
				return;
			}

			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].GetTag() ~== split[1])
				{
					Followers[i].Reset();
					break;
				}
			}
			return;
		}

		if (e.Name ~== "HDF_ConfirmRecruitment" && !e.IsManual)
		{
			CloseFollowerMenu(e.Player);
			RecruitMarine(SelMarine[e.Player], e.Player);
			return;
		}

		if (e.Name ~== "HDF_OpenMenu")
		{
			let plr = HDPlayerPawn(players[e.Player].mo);

			FLineTraceData TraceData;
			plr.LineTrace(plr.angle, HDCONST_ONEMETRE * 20, plr.pitch, TRF_NOSKY, plr.Height - HDCONST_CROWNTOSHOULDER, data: TraceData);
			Actor ATarget = TraceData.HitActor;

			if (ATarget is 'HDOperator' && ATarget.Health > 0 && TraceData.Distance < HDCONST_ONEMETRE * 2 && !IsPuppet(ATarget) && (ATarget.bFRIENDLY || ATarget.InStateSequence(ATarget.CurState, ATarget.FindState('Falldown')) && HDOperator(ATarget).Stunned > 70))
			{
				FollowerMenuLevel[e.Player] = FMenu_Recruitment;
				SelMarine[e.Player] = HDOperator(ATarget);
			}
			else
			{
				int FSize = Followers.Size();
				HDFollower flw = HDFollower(ATarget);
				if (flw && flw.CanInteractWith() && e.IsManual && CVar.GetCVar('hdf_quickaccess', players[e.Player]).GetBool())
				{
					if (FSize > 1 && Modifiers[e.Player] & OpMod_Shift)
					{
						ToggleSelection(e.Player, flw);
						FollowerMenuLevel[e.Player] = FMenu_Followers;
					}
					else if (!(Modifiers[e.Player] & OpMod_Shift))
					{
						ToggleSelection(e.Player, flw, true);
						FollowerMenuLevel[e.Player] = FMenu_Main;
						flw.ChangeLinkedPlayer(plr);
					}
				}
				else if (FSize == 1)
				{
					ToggleSelection(e.Player, Followers[0], true);
					FollowerMenuLevel[e.Player] = FMenu_Main;
					Followers[0].ChangeLinkedPlayer(plr);
				}
				else if (FSize > 0)
				{
					FollowerMenuLevel[e.Player] = FMenu_Followers;
				}
			}
			return;
		}

		// [Ace] Always allow to open the follower menu to the first page or close it.
		if (e.Name ~== "HDF_SetFollowerMenu")
		{
			if (e.Args[0] == FMenu_Closed)
			{
				CloseFollowerMenu(e.Player);
				return;
			}

			FollowerMenuLevel[e.Player] = e.Args[0];
			return;
		}

		if (Followers.Size() == 0)
		{
			return;
		}

		// [Ace] This is an obvious cheat, so don't use it unless you absolutely HAVE to.
		if (e.Name.MakeLower().IndexOf("hdf_warptoplayer") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");

			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].GetTag() ~== split[1])
				{
					Followers[i].WarpToPlayer();
					break;
				}
			}
			return;
		}

		if (e.Name ~== "HDF_ApplySelection")
		{
			ApplySelection(e.Player);
			return;
		}

		if (e.Name ~== "HDF_ToggleSelection")
		{
			// [Ace] Select only that follower.
			if (e.Args[1])
			{
				Selection[e.Player].SelFollowers.Clear();
			}
			ToggleSelection(e.Player, Followers[e.Args[0]], true);
			return;
		}

		if (e.Name ~== "HDF_ManipulateSelection")
		{
			switch (e.Args[0])
			{
				case 0: SelectAll(e.Player, e.Args[1], false); break;
				case 1: SelectAll(e.Player, e.Args[1], true); break;
				case 2: DeselectAll(e.Player, e.Args[1]); break;
			}
			return;
		}

		HDFollower lastFol = Selection[e.Player].GetLast();
		if (!lastFol || !lastFol.CanInteractWith())
		{
			return;
		}

		if (e.Name ~== "HDF_DismissFollower")
		{
			lastFol.Dismiss();
			CloseFollowerMenu(e.Player);
			return;
		}

		// [Ace] These commands cannot be used if alive and hostile.
		if (e.Name ~== "HDF_CarryFollower")
		{
			if (lastFol.PackFollower())
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_TryRevive")
		{
			if (lastFol.TryRevive(e.Args[0]))
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_TryArmor")
		{
			lastFol.TryUseArmor();
			return;
		}

		if (e.Name ~== "HDF_TryWeapon")
		{
			lastFol.TryUseWeapon();
			return;
		}

		if (e.Name ~== "HDF_ChangeOrders")
		{
			int size = Selection[e.Player].SelFollowers.Size();
			bool result = false;
			for (int i = 0; i < size; ++i)
			{
				result = Selection[e.Player].SelFollowers[i].ChangeOrders(e.Args[0], size > 1 ? HDFollower.COF_MULTI : 0);
			}
			if (!(Modifiers[e.Player] & OpMod_Shift) && (result || size > 1))
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_tryreloadweapon") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");
			if (split.Size() > 1)
			{
				int selSize = Selection[consoleplayer].SelFollowers.Size();
				for (int i = 0; i < selSize; ++i)
				{
					let flw = Selection[consoleplayer].SelFollowers[i];
					int wSize = flw.Weapons.Size();
					if (!flw.CanInteractWith(false) || wSize == 0)
					{
						continue;
					}

					if (selSize == 1)
					{
						int index = split[1].ToInt();
						if (index > 0 && index <= wSize)
						{
							flw.TryReloadWeapon(flw.Weapons[index - 1], HDFollower.RLF_MANUAL);
							continue;
						}
					}
					
					flw.TryReloadWeapon(flw.FindWeaponByName(split[1]), HDFollower.RLF_MANUAL);
				}
			}
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_removeweapon") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");
			if (split.Size() > 1)
			{
				int selSize = Selection[consoleplayer].SelFollowers.Size();
				for (int i = 0; i < selSize; ++i)
				{
					let flw = Selection[consoleplayer].SelFollowers[i];
					int wSize = flw.Weapons.Size();
					if (!flw.CanInteractWith(false) || wSize == 0)
					{
						continue;
					}

					if (selSize == 1)
					{
						int index = split[1].ToInt();
						if (index > 0 && index <= wSize)
						{
							flw.Weapons[index - 1].EmptyWeapon();
							flw.Weapons[index - 1].Destroy();
							flw.Weapons.Delete(index - 1);
							continue;
						}
					}

					let wpn = flw.FindWeaponByName(split[1]);
					if (!wpn)
					{
						continue;
					}
					int index = flw.Weapons.Find(wpn);
					wpn.EmptyWeapon();
					wpn.Destroy();
					flw.Weapons.Delete(index);
				}
			}
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_transfermag") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");
			HDMagAmmo item = HDMagAmmo(players[e.Player].mo.FindInventory(split[1]));
			if (item)
			{
				lastFol.AddMag(item, e.Args[0], e.Args[1]);
			}
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_transferitem") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");
			HDPickup item = HDPickup(players[e.Player].mo.FindInventory(split[1]));
			if (item)
			{
				lastFol.AddItem(item, e.Args[0], item.bMULTIPICKUP ? HDFollower.MaxLooseAmmoAmount : 1, e.Args[1]);
			}
			return;
		}

		if (e.Name ~== "HDF_TakeInvItem")
		{
			lastFol.TakeInvItem(lastFol.Slots[e.Args[0]]);
			return;
		}

		if (e.Name ~== "HDF_ChangeColor")
		{
			for (int i = 0; i < Selection[consoleplayer].SelFollowers.Size(); ++i)
			{
				let flw = Selection[consoleplayer].SelFollowers[i];
				if (flw.CanInteractWith() && !(flw.bDONTTRANSLATE))
				{
					flw.A_SetTranslation("FollowerTranslation"..e.Args[0]);
				}
			}
			return;
		}
	}

	// ----------------------------------------------------------------------
	//
	// MISCELLANEOUS HELPER FUNCTIONS
	//
	// ----------------------------------------------------------------------

	private ui void ProcessInputString(out string input, HDFollower selFol, bool multiselect)
	{
		Array<string> split;
		input.Split(split, " ");
		int splitSize = split.Size();
		switch (splitSize)
		{
			case 1:
			{
				if (!multiselect)
				{
					if (split[0] ~== "wpn")
					{
						SendNetworkEvent("HDF_TryWeapon");
						break;
					}
					if (split[0] ~== "arm")
					{
						SendNetworkEvent("HDF_TryArmor");
						break;
					}
				}
				break;
			}
			case 2:
			{
				if (split[0] ~== "rld" || split[0] ~== "rel")
				{
					SendNetworkEvent("HDF_TryReloadWeapon:"..split[1]);
					break;
				}
				if (split[0] ~== "rmv")
				{
					SendNetworkEvent("HDF_RemoveWeapon:"..split[1]);
					break;
				}
				break;
			}
		}
		input = "";
	}

	// [Ace] The only reason this is used is to allow dynamic menus with a variable number of options. That's literally the only reason.
	private ui FollowerCommand CreateCommand(string evName, int arg1 = 0, int arg2 = 0, int arg3 = 0, bool useUiHandler = false)
	{
		let Command = new('FollowerCommand');
		Command.EventName = evName;
		Command.Args[0] = arg1;
		Command.Args[1] = arg2;
		Command.Args[2] = arg3;
		Command.UseUiHandler = useUiHandler;
		return Command;
	}

	private ui void UpdateValidItems(HDFollower flw)
	{
		UiData[consoleplayer].ValidItems.Clear();
		Actor plr = players[consoleplayer].mo;
		for (Inventory Next = plr.Inv; Next; Next = Next.Inv)
		{
			HDPickup item = HDPickup(Next);
			if (item && flw.IsValidItem(item.GetClass()))
			{
				UiData[consoleplayer].ValidItems.Push(item);
			}
		}
	}

	private ui Color GetPercentColor(double percent)
	{
		if (percent >= 0.75)
		{
			return Color(128, 0, 255, 0);
		}	
		else if (percent >= 0.50)
		{
			return Color(128, 255, 255, 0);
		}
		else if (percent >= 0.25)
		{
			return Color(128, 255, 128, 0);
		}
		else
		{
			return Color(128, 255, 0, 0);
		}
	}

	private ui string GetTruncatedText(string text, int length)
	{
		if (text.Length() > length)
		{
			string TruncatedName = text.Mid(0, length);
			TruncatedName.DeleteLastCharacter();
			TruncatedName.DeleteLastCharacter();
			TruncatedName.DeleteLastCharacter();
			if (TruncatedName.ByteAt(TruncatedName.Length() - 1) == 32)
			{
				TruncatedName.DeleteLastCharacter();
			}
			text = TruncatedName.."...";
		}

		return text;
	}

	private ui bool IsValidIndex(HDPickup pkp, int index)
	{
		let mag = HDMagAmmo(pkp);
		if (mag)
		{
			int mSize = mag.Mags.Size();
			return mSize > 0 && index < mSize;
		}
		if (pkp.bMULTIPICKUP)
		{
			return pkp.Amount > 0 && index == 0;
		}
		else
		{
			return pkp.Amount > 0 && index < pkp.Amount;
		}
	}

	private void CloseFollowerMenu(int plrNum)
	{
		Selection[plrNum].SelFollowers.Clear();
		FollowerMenuLevel[plrNum] = FMenu_Closed;
	}

	private void ApplySelection(int plrNum)
	{
		int size = Selection[plrNum].SelFollowers.Size();
		if (size == 0 || Modifiers[plrNum] != 0)
		{
			return;
		}

		FollowerMenuLevel[plrNum] = FMenu_Main;
		for (int i = 0; i < size; ++i)
		{
			Selection[plrNum].SelFollowers[i].ChangeLinkedPlayer(HDPlayerPawn(players[plrNum].mo));
		}
	}

	private void DeselectAll(int plrNum, int page)
	{
		if (page > -1)
		{
			for (int i = FollowersPerPage * page; i < min(FollowersPerPage * (page + 1), Followers.Size()); ++i)
			{
				if (Selection[plrNum].SelFollowers.Find(Followers[i]) != Selection[plrNum].SelFollowers.Size())
				{
					ToggleSelection(plrNum, Followers[i]);
				}
			}
		}
		else
		{
			Selection[plrNum].SelFollowers.Clear();
		}
	}

	private void SelectAll(int plrNum, int page, bool invert)
	{
		if (!invert)
		{
			DeselectAll(plrNum, page);
		}
		if (page > -1)
		{
			for (int i = FollowersPerPage * page; i < min(FollowersPerPage * (page + 1), Followers.Size()); ++i)
			{
				ToggleSelection(plrNum, Followers[i]);
			}
		}
		else
		{
			for (int i = 0; i < Followers.Size(); ++i)
			{
				ToggleSelection(plrNum, Followers[i]);
			}
		}
	}

	private void ToggleSelection(int plrNum, HDFollower flw, bool allowDead = false)
	{
		if (flw.CanInteractWith(allowDead))
		{
			int FoundIndex = Selection[plrNum].SelFollowers.Find(flw);
			if (FoundIndex == Selection[plrNum].SelFollowers.Size())
			{
				Selection[plrNum].SelFollowers.Push(flw);
			}
			else
			{
				Selection[plrNum].SelFollowers.Delete(FoundIndex);
			}
		}
	}
}
