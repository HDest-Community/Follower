class FollowerCommand ui
{
	string EventName;
	int Args[3];
}

extend class FollowerHandler
{
	enum FollowerMenus
	{
		FMenu_Closed,
		FMenu_Recruitment,
		FMenu_Followers,
		FMenu_Main,
		FMenu_Orders,
		FMenu_OrdersMulti,
		FMenu_Weapons,
		FMenu_Supplies,
		FMenu_Miscellaneous
	}
	
	private transient ui HUDFont MainFont;

	const FollowersPerPage = 8;
	
	// [Ace] The only reason this is used is to allow dynamic menus with a variable number of options. That's literally the only reason.
	private ui FollowerCommand CreateCommand(string evName, int arg1 = 0, int arg2 = 0, int arg3 = 0)
	{
		let Command = new('FollowerCommand');
		Command.EventName = evName;
		Command.Args[0] = arg1;
		Command.Args[1] = arg2;
		Command.Args[2] = arg3;
		return Command;
	}

	private ui string GetTruncatedText(string text, int length)
	{
		if (text.Length() > length)
		{
			string TruncatedName = text.Mid(0, length);
			TruncatedName.DeleteLastCharacter();
			if (TruncatedName.ByteAt(TruncatedName.Length() - 1) == 32)
			{
				TruncatedName.DeleteLastCharacter();
			}
			text = TruncatedName.."...";
		}

		return text;
	}
	
	override void RenderOverlay(RenderEvent e)
	{
		MainFont = HUDFont.Create("CONFONT");

		int OriginalWidth = StatusBar.HorizontalResolution;
		int OriginalHeight = StatusBar.VerticalResolution;

		StatusBar.BeginHUD(1.0, true);
		StatusBar.SetSize(StatusBar.RelTop, 640, 480);

		if (FollowerMenuLevel[consoleplayer] > FMenu_Closed && !AutomapActive && GameState == GS_LEVEL)
		{
			DrawCommandMenu(StatusBar, (0, 40), StatusBar.DI_SCREEN_LEFT | StatusBar.DI_SCREEN_VCENTER | StatusBar.DI_TEXT_ALIGN_LEFT);
		}

		// --------------- PRETEND WE WERE NEVER HERE ---------------

		StatusBar.BeginHUD(1.0, false);
		StatusBar.SetSize(StatusBar.RelTop, OriginalWidth, OriginalHeight);
	}

	private ui void DrawCommandMenu(BaseStatusBar sb, vector2 pos, int flags)
	{
		vector2 OriginalPos = pos;
		int RectangleHeight = MainFont.mFont.GetHeight() + 4;
		int Spacing = 1;

		HDFollower SFol = Selection[consoleplayer].GetLast();

		// [Ace] Up here because it's used by several menus.
		string BrassString;
		if (SFol)
		{
			int Brass = SFol.GetTotalBrass();
			int MaxBrass = SFol.GetMaxBrass();
			BrassString = (Brass > 0 ? "" : "\c[Red]").."Collect brass\c- ".."("..Brass.."/"..MaxBrass..")";
		}

		switch (FollowerMenuLevel[consoleplayer])
		{
			case FMenu_Recruitment:
			{
				if (!SelMarine[consoleplayer])
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				Array<string> Commands;
				Commands.Push("Recruit?");
				Commands.Push("Cancel");

				DrawTextRectangle(sb, pos, (150, RectangleHeight), MainFont, GetTruncatedText(SelMarine[consoleplayer].nickname, 16), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;

				for (int i = 0; i < Commands.Size(); ++i)
				{
					DrawTextRectangle(sb, pos, (150, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
					pos.y += RectangleHeight + Spacing;
				}
				break;
			}

			case FMenu_Followers:
			{
				if (Followers.Size() == 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				
				int FSize = Followers.Size();
				int RelSize = min(FollowersPerPage, FSize - FollowersPerPage * FollowerPage[consoleplayer]);
				if (RelSize > 4)
				{
					pos.y -= (RectangleHeight * 2 - 2) * 4;
				}

				int LastIndex = 0;
				for (int i = FollowersPerPage * FollowerPage[consoleplayer]; i < min(FollowersPerPage * (FollowerPage[consoleplayer] + 1), FSize); ++i)
				{
					LastIndex++;
					bool Valid = Followers[i].CanInteractWith(false);
					int FollowerBlockSize = Valid ? RectangleHeight * 2 - 2 : RectangleHeight;
					DrawFollowerRectangle(sb, pos, (200, FollowerBlockSize), MainFont, LastIndex, Followers[i], Valid, flags);
					pos.y += FollowerBlockSize + Spacing;
				}
				if (FSize > FollowersPerPage * (FollowerPage[consoleplayer] + 1))
				{
					LastIndex++;
					DrawTextRectangle(sb, pos, (200, RectangleHeight), MainFont, LastIndex..") Next...", flags);
					pos.y += RectangleHeight + Spacing;
				}
				if (FollowerPage[consoleplayer] > 0)
				{
					LastIndex++;
					if (LastIndex == 10)
					{
						LastIndex = 0;
					}
					DrawTextRectangle(sb, pos, (200, RectangleHeight), MainFont, LastIndex..") Back...", flags);
					pos.y += RectangleHeight + Spacing;
				}
				break;
			}

			case FMenu_Main:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				if (SFol.Health <= 0)
				{
					int RequiredSips = SFol.GetRequiredSips();
					int RequiredBlood = SFol.GetRequiredBlood();
					string BloodDanger;
					if (RequiredBlood < 10)
					{
						BloodDanger = "\c[FLW_BloodGreen](Safe)\c-";
					}
					else if (RequiredBlood < 20)
					{
						BloodDanger = "\c[FLW_BloodPoison](Risky)\c-";
					}
					else if (RequiredBlood < 30)
					{
						BloodDanger = "\c[FLW_BloodYellow](Dangerous)\c-";
					}
					else if (RequiredBlood < 40)
					{
						BloodDanger = "\c[FLW_BloodOrange](Extremely Risky)\c-";
					}
					else if (RequiredBlood < 50)
					{
						BloodDanger = "\c[FLW_BloodRed](Almost Deadly)\c-";
					}
					else
					{
						BloodDanger = "\c[FLW_BloodBlack](Certain Death)\c-";
					}

					Array<string> Commands;
					Commands.Push("Carry follower");
					if (SFol.ResurrectType & HDFollower.RESF_BLUES)
					{
						Commands.Push((sb.CheckInventory("BluePotion", 1) ? "" : "\c[Red]").."Give blue potion\c- ".."\c[Blue]("..RequiredSips.."/12)\c-");
					}
					if (SFol.ResurrectType & HDFollower.RESF_BLOOD)
					{
						Commands.Push("Feed blood "..BloodDanger);
					}
					Commands.Push(BrassString);
					if (SFol.bCANDISMISS)
					{
						Commands.Push("\c[FLW_BloodRed]Dismiss\c-");
					}
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					DrawTextRectangle(sb, pos, (250, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 16), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += RectangleHeight + Spacing;

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawTextRectangle(sb, pos, (250, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += RectangleHeight + Spacing;
					}
				}
				else if (SFol.bFRIENDLY)
				{
					int Durability = 0;
					bool Mega = false;
					bool Waiting = SFol.Status == FStatus_WaitingForArmor;
					let Armor = HDArmourWorn(SFol.FindInventory("HDArmourWorn"));
					if (Armor)
					{
						Durability = Armor.Durability;
						Mega = Armor.Mega;
					}

					Array<string> Commands;
					Commands.Push("Orders");
					Commands.Push("Carry follower");
					Commands.Push("Give ammo");
					Commands.Push("Give supplies");
					Commands.Push((Waiting ? "Confirm/Cancel?" : "Use/drop armor"..(Durability > 0 ? (Mega ? "\c[Blue]" : "\c[DarkGreen]").." ("..Durability..")": "")).."\c-");
					Commands.Push("Misc commands");
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					int RectangleWidth = 150;
					if (!Waiting && Durability > 0)
					{
						RectangleWidth += 40;
					}

					DrawTextRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 16), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += RectangleHeight + Spacing;
					
					if (Followers.Size() == 1 && SFol.CanInteractWith(false))
					{
						double Dist = SFol.Distance3D(SFol.LinkedPlayer) / 42.0;
						DrawTextRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, String.Format("%.2fm", Dist), flags, Font.CR_DARKGRAY);
						pos.y += RectangleHeight + Spacing;
					}

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawTextRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += RectangleHeight + Spacing;
					}
				}
				break;
			}

			case FMenu_Orders:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				static const string Orders[] = { "Follow", "Follow and ignore hostiles", "Stay and provide cover", "Go there and provide cover", "Come and help me" };

				DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 30), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;
				for (int i = 0; i < Orders.Size(); ++i)
				{
					DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, (i + 1)..") "..(SFol.Order == i ? "\c[Green]" : "")..Orders[i].."\c-", flags);
					pos.y += RectangleHeight + Spacing;
				}
				DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, (Orders.Size() + 1)..") Back...", flags);
				break;
			}
			case FMenu_OrdersMulti:
			{
				if (Followers.Size() == 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				static const string Orders[] = { "Follow", "Follow and ignore hostiles", "Stay and provide cover" };

				DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, Selection[consoleplayer].SelFollowers.Size().." followers selected", flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;
				for (int i = 0; i < Orders.Size(); ++i)
				{
					DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, (i + 1)..") "..Orders[i], flags);
					pos.y += RectangleHeight + Spacing;
				}
				DrawTextRectangle(sb, pos, (240, RectangleHeight), MainFont, (Orders.Size() + 1)..") Back...", flags);
				break;
			}

			case FMenu_Weapons:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				int WeaponSize = SFol.Weapons.Size();
				int WeaponBlockSize = RectangleHeight * 3 - 5;
				if (WeaponSize > 4)
				{
					pos.y -= WeaponBlockSize * (WeaponSize - 4);
				}

				DrawTextRectangle(sb, pos, (160, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 16), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;
				for (int i = 0; i < WeaponSize; ++i)
				{
					DrawWeaponRectangle(sb, pos, (160, WeaponBlockSize), MainFont, i + 1, SFol, flags);
					pos.y += WeaponBlockSize + Spacing;
				}
				DrawTextRectangle(sb, pos, (160, RectangleHeight), MainFont, ((WeaponSize + 1 % 10))..") Back...", flags);
				break;
			}

			case FMenu_Supplies:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 22), flags, Font.FindFontColor('FLW_NameBlue')); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, "1) "..(sb.CheckInventory("PortableMedikit") ? "" : "\c[Red]").."Give Medikit\c- ".."("..SFol.SuturesLeft..", "..SFol.Medikits.."/"..SFol.MaxMedikits..")", flags); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, "2) "..(sb.CheckInventory("PortableStimpack") ? "" : "\c[Red]").."Give Stimpack\c- ".."("..SFol.Stimpacks.."/"..SFol.MaxStimpacks..")", flags); pos.y += RectangleHeight + Spacing;
				DrawTextRectangle(sb, pos, (205, RectangleHeight), MainFont, "3) Back...", flags);
				break;
			}

			case FMenu_Miscellaneous:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				Array<string> Commands;
				Commands.Push(BrassString);
				Commands.Push("Drop all ammo");
				Commands.Push("Drop all supplies");
				if (SFol.bCANDISMISS)
				{
					Commands.Push("\c[FLW_BloodRed]Dismiss\c-");
				}
				Commands.Push("Back...");

				DrawTextRectangle(sb, pos, (235, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 30), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;

				for (int i = 0; i < Commands.Size(); ++i)
				{
					DrawTextRectangle(sb, pos, (235, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
					pos.y += RectangleHeight + Spacing;
				}
				break;
			}
		}
	}

	private ui void DrawFollowerRectangle(BaseStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int index, HDFollower flw, bool valid, int flags)
	{
		bool selected = Selection[consoleplayer].SelFollowers.Find(flw) != Selection[consoleplayer].SelFollowers.Size();
		Color c = valid ? (selected ? Color(96, 96, 255, 96) : Color(64, 128, 192, 255)) : Color(64, 255, 16, 16);
		sb.Fill(c, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		pos += (2, 2);
		int FontHeight = fnt.mFont.GetHeight();
		sb.DrawString(fnt, index..") "..GetTruncatedText(flw.GetDisplayName(), 20), pos, flags, Font.FindFontColor('FLW_NameBlue')); pos.y += FontHeight + 1;

		if (valid)
		{
			double Dist = flw.Distance3D(flw.LinkedPlayer) / 42.0;
			sb.DrawString(fnt, String.Format("%.2fm", Dist), pos, flags, Font.CR_DARKGRAY); pos.y += FontHeight + 1;
		}
	}

	private ui void DrawTextRectangle(BaseStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, string command, int flags, int col = Font.CR_WHITE)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);
		sb.DrawString(fnt, command, (pos.x + 2, pos.y + (size.y - fnt.mFont.GetHeight()) / 2), flags, col); 
	}

	private ui void DrawWeaponRectangle(BaseStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int index, HDFollower flw, int flags)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		FollowerWeapon wpn = flw.GetWeaponByIndex(index - 1);
		int MaxSpare = wpn.GetMaxSpare();

		double AmPercent = wpn.SpareAmmo / double(MaxSpare);
		sb.Fill(GetPercentColor(AmPercent), pos.x + 1, pos.y + 1, (size.x - 2) * AmPercent, size.y - 2, flags);

		pos += (2, 2);
		int FontHeight = fnt.mFont.GetHeight();
		sb.DrawString(fnt, index..") "..wpn.GetName(), pos, flags, Font.FindFontColor('FLW_WeaponBlue')); pos.y += FontHeight + 1;
		sb.DrawString(fnt, (wpn.IsFullyLoaded() ? "\c[DarkGreen]" : "")..wpn.GetLoadedRounds().."\c-, "..wpn.SpareAmmo.."/"..MaxSpare, pos, flags, Font.CR_WHITE); pos.y += FontHeight + 1;

		int MaxGiveAmount = flw.GetMaxGiveAmount(wpn);
		string AmmoString = (MaxGiveAmount > 0 ? "\c[Green]" : "\c[Red]").."+"..MaxGiveAmount.." "..wpn.GetAmmoName().."\c-";
		sb.DrawString(fnt, AmmoString, pos, flags, Font.CR_WHITE);
	}

	override bool InputProcess(InputEvent e)
	{
		bool IsShift = e.KeyScan == InputEvent.Key_LShift || e.KeyScan == InputEvent.Key_RShift;
		bool IsCtrl = e.KeyScan == InputEvent.Key_LCtrl || e.KeyScan == InputEvent.Key_RCtrl;
		bool IsAlt = e.KeyScan == InputEvent.Key_LAlt || e.KeyScan == InputEvent.Key_RAlt;
		if (IsShift || IsCtrl || IsAlt)
		{
			if (e.Type == InputEvent.Type_KeyDown)
			{
				SendNetworkEvent("HDF_SetModifiers", 1, IsShift ? OpMod_Shift : (IsAlt ? OpMod_Alt : OpMod_Ctrl));
			}
			else if (e.Type == InputEvent.Type_KeyUp)
			{
				SendNetworkEvent("HDF_SetModifiers", 0, IsShift ? OpMod_Shift : (IsAlt ? OpMod_Alt : OpMod_Ctrl));
			}
		}

		bool RetVal = false;

		if (FollowerMenuLevel[consoleplayer] > FMenu_Closed && e.Type == InputEvent.Type_KeyDown)
		{
			int NumKey = e.KeyChar - 48;
			if (NumKey == 0)
			{
				NumKey = 10;
			}

			switch (FollowerMenuLevel[consoleplayer])
			{
				case FMenu_Recruitment:
				{
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_ConfirmRecruitment"); break;
						case 2: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed); break;
					}
					break;
				}

				case FMenu_Followers:
				{
					if (e.KeyScan == InputEvent.Key_Enter)
					{
						SendNetworkEvent("HDF_ApplySelection");
						RetVal = true;
					}
					else if (Modifiers[consoleplayer] & OpMod_Ctrl)
					{
						int Page = Modifiers[consoleplayer] & OpMod_Alt ? FollowerPage[consoleplayer] : -1;
						switch (e.KeyChar)
						{
							// [Ace] A - Select (A)ll, (I)nvert, (D)eselect.
							case 65: case 97:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 0, Page);
								break;
							}
							case 73: case 105:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 1, Page);
								break;
							}
							case 68: case 100:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 2, Page);
								break;
							}
						}
						RetVal = true;
					}
					else
					{
						int FSize = Followers.Size();
						int RelSize = min(FollowersPerPage, FSize - FollowersPerPage * FollowerPage[consoleplayer]);
						bool HasMorePages = FSize > FollowersPerPage * (FollowerPage[consoleplayer] + 1);
						int SelIndex = (NumKey + FollowersPerPage * FollowerPage[consoleplayer]) - 1;
						if (NumKey == RelSize + 1 && HasMorePages)
						{
							SendNetworkEvent("HDF_SetFollowerPage", 1);
						}
						else if (FollowerPage[consoleplayer] > 0 && NumKey == RelSize + (HasMorePages ? 2 : 1))
						{
							SendNetworkEvent("HDF_SetFollowerPage", 0);
						}
						else if (NumKey > 0 && (NumKey - 1) < RelSize)
						{
							if (Modifiers[consoleplayer] & OpMod_Shift)
							{
								SendNetworkEvent("HDF_ToggleSelection", SelIndex);
							}
							else
							{
								SendNetworkEvent("HDF_ToggleSelection", SelIndex, true);
								SendNetworkEvent("HDF_ApplySelection");
							}
						}
					}
					break;
				}

				case FMenu_Main:
				{
					HDFollower SFol = Selection[consoleplayer].GetLast();
					if (SFol.Health <= 0)
					{
						Array<FollowerCommand> Commands;
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						if (SFol.ResurrectType & HDFollower.RESF_BLUES)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 0));
						}
						if (SFol.ResurrectType & HDFollower.RESF_BLOOD)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 1));
						}
						Commands.Push(CreateCommand("HDF_CollectBrass"));
						if (SFol.bCANDISMISS)
						{
							Commands.Push(CreateCommand("HDF_DismissFollower"));
						}
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}

						if (NumKey > 0 && NumKey - 1 < Commands.Size())
						{
							FollowerCommand cmd = Commands[NumKey - 1];
							SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
						}
					}
					else if (SFol.bFRIENDLY)
					{
						Array<FollowerCommand> Commands;
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Orders));
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Weapons));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Supplies));
						Commands.Push(CreateCommand("HDF_TryArmor"));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Miscellaneous));
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}
						
						if (NumKey > 0 && NumKey - 1 < Commands.Size())
						{
							FollowerCommand cmd = Commands[NumKey - 1];
							SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
						}
					}
					break;
				}
					
				case FMenu_Orders:
				{
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_ChangeOrders", FOrder_Follow); break;
						case 2: SendNetworkEvent("HDF_ChangeOrders", FOrder_FollowIgnore); break;
						case 3: SendNetworkEvent("HDF_ChangeOrders", FOrder_Cover); break;
						case 4: SendNetworkEvent("HDF_ChangeOrders", FOrder_GoAndCover); break;
						case 5: SendNetworkEvent("HDF_ChangeOrders", FOrder_ComeAndHelp); break;
						case 6: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main); break;
					}
					break;
				}

				case FMenu_OrdersMulti:
				{
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_ChangeOrdersMulti", FOrder_Follow); break;
						case 2: SendNetworkEvent("HDF_ChangeOrdersMulti", FOrder_FollowIgnore); break;
						case 3: SendNetworkEvent("HDF_ChangeOrdersMulti", FOrder_Cover); break;
						case 4: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Followers); break;
					}
					break;
				}

				case FMenu_Weapons:
				{
					if (NumKey == (Selection[consoleplayer].GetLast().Weapons.Size() + 1) % 10)
					{
						SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main);
					}
					else
					{
						SendNetworkEvent("HDF_GiveAmmo", NumKey - 1);
					}
					break;
				}

				case FMenu_Supplies:
				{
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_GiveSupplies", 0); break;
						case 2: SendNetworkEvent("HDF_GiveSupplies", 1); break;
						case 3: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main); break;
					}
					break;
				}

				case FMenu_Miscellaneous:
				{
					Array<FollowerCommand> Commands;
					Commands.Push(CreateCommand("HDF_CollectBrass"));
					Commands.Push(CreateCommand("HDF_DropStuff", 0));
					Commands.Push(CreateCommand("HDF_DropStuff", 1));
					if (Selection[consoleplayer].GetLast().bCANDISMISS)
					{
						Commands.Push(CreateCommand("HDF_DismissFollower"));
					}
					Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Main));
					
					if (NumKey > 0 && NumKey - 1 < Commands.Size())
					{
						FollowerCommand cmd = Commands[NumKey - 1];
						SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
					}
					break;
				}
			}

			// [Ace] Block 0-9 keys from affecting the world.
			if (NumKey >= 0 && NumKey <= 10)
			{
				RetVal = true;
			}

			if (!(Modifiers[consoleplayer] & OpMod_Shift))
			{
				// [Ace] Exit.
				int Key1, Key2;
				[Key1, Key2] = Bindings.GetKeysForCommand("HDF_OpenMenu");
				if (e.KeyScan == Key1 || e.KeyScan == Key2)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					RetVal = true;
				}
			}
			else if (FollowerMenuLevel[consoleplayer] == FMenu_Followers)
			{
				SendNetworkEvent("HDF_OpenMenu");
			}
		}
		return RetVal;
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "HDF_InitStuff")
		{
			InitSelection();
		}

		if (e.Name ~== "HDF_SetModifiers")
		{
			switch (e.Args[0])
			{
				case 0: Modifiers[e.Player] &= ~e.Args[1]; break;
				case 1: Modifiers[e.Player] |= e.Args[1]; break;
			}
		}

		if (e.Name ~== "HDF_SetFollowerPage")
		{
			switch (e.Args[0])
			{
				case 0: FollowerPage[e.Player]--; break;
				case 1: FollowerPage[e.Player]++; break;
			}
		}

		if (e.Name ~== "HDF_ResetFollower" && e.Args[0] > 0)
		{
			Array<class<HDFollower> > FollowerClasses;

			// [Ace] Find all follower classes first.
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				if (AllActorClasses[i] is 'HDFollower' && AllActorClasses[i].GetClassName() != 'HDFollower')
				{
					FollowerClasses.Push((class<HDFollower>)(AllActorClasses[i]));
				}
			}

			int FollowerIndex = e.Args[0];

			// [Ace; 23.03.2021]
			// The problem with FollowerIndex, in hindsight, is that if two followers shame the same index, only the first one would get deleted.
			// I should have used class name for filtering. Unfortunately, it's too late. Not without breaking all of the existing follower sub-addons. Ah well.

			// [Ace] Destroy the class that is being reset, if applicable, then recreate it.
			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].Index == FollowerIndex)
				{
					RemoveFollower(Followers[i]);
					break;
				}
			}
			for (int i = 0; i < FollowerClasses.Size(); ++i)
			{
				if (GetDefaultByType(FollowerClasses[i]).Index == FollowerIndex)
				{
					CreateFollower(FollowerClasses[i], e.Player);
					break;
				}
			}
			return;
		}

		if (e.Name ~== "HDF_ConfirmRecruitment" && !e.IsManual)
		{
			CloseFollowerMenu(e.Player);
			RecruitMarine(SelMarine[e.Player], e.Player);
		}

		if (e.Name ~== "HDF_DismissFollower" && !e.IsManual)
		{
			Selection[e.Player].GetLast().Dismiss();
			CloseFollowerMenu(e.Player);
		}

		if (e.Name ~== "HDF_OpenMenu")
		{
			let plr = HDPlayerPawn(players[e.Player].mo);
			Actor ATarget = plr.AimTarget();
			if (ATarget is 'HDMarine' && plr.Distance3D(ATarget) <= 42 * 2 && ATarget.Health > 0 && !IsPuppet(ATarget) && (ATarget.bFRIENDLY || ATarget.InStateSequence(ATarget.CurState, ATarget.FindState('Falldown')) && HDMarine(ATarget).Stunned > 70))
			{
				FollowerMenuLevel[e.Player] = FMenu_Recruitment;
				SelMarine[e.Player] = HDMarine(ATarget);
			}
			else
			{
				int FSize = Followers.Size();
				HDFollower flw = HDFollower(ATarget);
				if (flw && flw.CanInteractWith(!(Modifiers[e.Player] & OpMod_Shift)) && e.IsManual && CVar.GetCVar('hdf_quickaccess', players[e.Player]).GetBool())
				{
					if (FSize > 1 && Modifiers[e.Player] & OpMod_Shift)
					{
						ToggleSelection(e.Player, flw);
						FollowerMenuLevel[e.Player] = FMenu_Followers;
					}
					else if (!(Modifiers[e.Player] & OpMod_Shift))
					{
						ToggleSelection(e.Player, flw);
						FollowerMenuLevel[e.Player] = FMenu_Main;
						flw.ChangeLinkedPlayer(plr);
					}
				}
				else if (FSize == 1 && Followers[0].CanInteractWith())
				{
					ToggleSelection(e.Player, Followers[0]);
					FollowerMenuLevel[e.Player] = FMenu_Main;
					let lol = Selection[e.Player].GetLast();
				}
				else if (FSize > 0)
				{
					FollowerMenuLevel[e.Player] = FMenu_Followers;
				}
			}
			return;
		}

		// [Ace] Always allow to open the follower menu to the first page or close it.
		if (e.Name ~== "HDF_SetFollowerMenu")
		{
			if (e.Args[0] == FMenu_Closed)
			{
				CloseFollowerMenu(e.Player);
				return;
			}

			FollowerMenuLevel[e.Player] = e.Args[0];
			return;
		}

		if (Followers.Size() == 0)
		{
			return;
		}

		// [Ace] This is an obvious cheat, so don't use it unless you absolutely HAVE to.
		if (e.Name ~== "HDF_WarpToPlayer")
		{
			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].Index == e.Args[0])
				{
					Followers[i].WarpToPlayer();
					break;
				}
			}
			return;
		}

		if (e.Name ~== "HDF_ApplySelection")
		{
			ApplySelection(e.Player);
			return;
		}

		if (e.Name ~== "HDF_ToggleSelection")
		{
			// [Ace] Select only that follower.
			if (e.Args[1])
			{
				Selection[e.Player].SelFollowers.Clear();
			}
			ToggleSelection(e.Player, Followers[e.Args[0]]);
			return;
		}

		if (e.Name ~== "HDF_ManipulateSelection")
		{
			switch (e.Args[0])
			{
				case 0: SelectAll(e.Player, e.Args[1], false); break;
				case 1: SelectAll(e.Player, e.Args[1], true); break;
				case 2: DeselectAll(e.Player, e.Args[1]); break;
			}
			return;
		}

		HDFollower SFol = Selection[e.Player].GetLast();
		if (!SFol || !SFol.CanInteractWith())
		{
			return;
		}

		// [Ace] These commands cannot be used if alive and hostile.
		if (e.Name ~== "HDF_CarryFollower")
		{
			if (SFol.PackFollower())
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_TryRevive")
		{
			if (SFol.TryRevive(e.Args[0]))
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_CollectBrass")
		{
			if (SFol.TryCollectBrass())
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_GiveAmmo")
		{
			SFol.TryGiveAmmo(e.Args[0]);
			return;
		}

		if (e.Name ~== "HDF_TryArmor")
		{
			SFol.TryUseArmor();
			CloseFollowerMenu(e.Player);
			return;
		}

		if (e.Name ~== "HDF_GiveSupplies")
		{
			switch (e.Args[0])
			{
				case 0: SFol.TryGiveMedikit(); break;
				case 1: SFol.TryGiveStimpack(); break;
			}
			return;
		}

		if (e.Name ~== "HDF_ChangeOrders")
		{
			if (SFol.ChangeOrders(e.Args[0]))
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_ChangeOrdersMulti")
		{
			for (int i = 0; i < Selection[e.Player].SelFollowers.Size(); ++i)
			{
				Selection[e.Player].SelFollowers[i].ChangeOrders(e.Args[0]);
			}
			CloseFollowerMenu(e.Player);
			return;
		}

		if (e.Name ~== "HDF_DropStuff")
		{
			switch (e.Args[0])
			{
				case 0: SFol.DropAllAmmo(); break;
				case 1: SFol.DropAllSupplies(); break;
			}
		}
	}

	private void CloseFollowerMenu(int plrNum)
	{
		Selection[plrNum].SelFollowers.Clear();
		FollowerMenuLevel[plrNum] = FMenu_Closed;
	}

	private void ToggleSelection(int plrNum, HDFollower flw)
	{
		if (flw.CanInteractWith(false))
		{
			int FoundIndex = Selection[plrNum].SelFollowers.Find(flw);
			if (FoundIndex == Selection[plrNum].SelFollowers.Size())
			{
				Selection[plrNum].SelFollowers.Push(flw);
			}
			else
			{
				Selection[plrNum].SelFollowers.Delete(FoundIndex);
			}
		}
	}

	private void ApplySelection(int plrNum)
	{
		int Size = Selection[plrNum].SelFollowers.Size();
		if (Size == 0 || Modifiers[plrNum] != 0)
		{
			return;
		}

		FollowerMenuLevel[plrNum] = Size > 1 ? FMenu_OrdersMulti : FMenu_Main;
		for (int i = 0; i < Size; ++i)
		{
			Selection[plrNum].SelFollowers[i].ChangeLinkedPlayer(HDPlayerPawn(players[plrNum].mo));
		}
	}

	private void SelectAll(int plrNum, int page, bool invert)
	{
		if (!invert)
		{
			DeselectAll(plrNum, page);
		}
		if (page > -1)
		{
			for (int i = FollowersPerPage * page; i < min(FollowersPerPage * (page + 1), Followers.Size()); ++i)
			{
				ToggleSelection(plrNum, Followers[i]);
			}
		}
		else
		{
			for (int i = 0; i < Followers.Size(); ++i)
			{
				ToggleSelection(plrNum, Followers[i]);
			}
		}
	}

	private void DeselectAll(int plrNum, int page)
	{
		if (page > -1)
		{
			for (int i = FollowersPerPage * page; i < min(FollowersPerPage * (page + 1), Followers.Size()); ++i)
			{
				if (Selection[plrNum].SelFollowers.Find(Followers[i]) != Selection[plrNum].SelFollowers.Size())
				{
					ToggleSelection(plrNum, Followers[i]);
				}
			}
		}
		else
		{
			Selection[plrNum].SelFollowers.Clear();
		}
	}

	private Color GetPercentColor(double percent) const
	{
		if (percent >= 0.75)
		{
			return Color(18, 0, 255, 0);
		}	
		else if (percent >= 0.50)
		{
			return Color(24, 255, 255, 0);
		}
		else if (percent >= 0.25)
		{
			return Color(30, 255, 128, 0);
		}
		else
		{
			return Color(36, 255, 0, 0);
		}
	}
}