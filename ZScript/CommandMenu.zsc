class FollowerCommand ui
{
	string EventName;
	int Args[3];
}

struct FollowerSelection
{
	Array<HDFollower> SelFollowers;
	clearscope HDFollower GetLast() const // [Ace] This const is gonna bite me in the ass. Mark my words.
	{
		int Size = SelFollowers.Size();
		return Size > 0 ? SelFollowers[Size - 1] : null;
	}
}

struct ValidItemsHolder
{
	Array<HDPickup> Items;
}

extend class FollowerHandler
{
	enum FollowerMenus
	{
		FMenu_Closed,
		FMenu_Recruitment,
		FMenu_Followers,
		FMenu_Main,
		FMenu_Orders,
		FMenu_OrdersMulti,
		FMenu_Inventory,
		FMenu_Miscellaneous,
		FMenu_ColorPicker
	}

	enum KeyHold
	{
		HOLD_LEFT = 1,
		HOLD_RIGHT = 2,
		HOLD_UP = 4,
		HOLD_DOWN = 8,
	}
	
	private transient ui HUDFont MainFont;

	private transient int FollowerMenuLevel[MAXPLAYERS];
	private transient int FollowerPage[MAXPLAYERS];
	private transient HDMarine SelMarine[MAXPLAYERS];
	private transient FollowerSelection Selection[MAXPLAYERS];
	private transient int Modifiers[MAXPLAYERS];

	private transient ui int ArrowKeysHeld[MAXPLAYERS];
	private transient ui int RepeatTics[MAXPLAYERS];

	private transient ui int SlotFocused[MAXPLAYERS];
	private transient ui ValidItemsHolder ValidItems[MAXPLAYERS];
	private transient ui int PSlotIndex[MAXPLAYERS];
	private transient ui int PSlotSubIndex[MAXPLAYERS];
	private transient ui int TransferAmount[MAXPLAYERS];
	private transient ui int SelWeaponIndex[MAXPLAYERS];
	private transient ui int FSlotIndex[MAXPLAYERS];

	private transient ui int SelectedColorIndex[MAXPLAYERS];

	const FollowersPerPage = 8;
	const InvColumns = 6;
	const PickerColumns = 20;
	const ColSquareSize = 6;
	const SlotSize = 24;
	const Spacing = 1;
	
	override void RenderOverlay(RenderEvent e)
	{
		MainFont = HUDFont.Create("CONFONT");

		int OriginalWidth = StatusBar.HorizontalResolution;
		int OriginalHeight = StatusBar.VerticalResolution;

		StatusBar.BeginHUD(1.0, true);
		StatusBar.SetSize(StatusBar.RelTop, 640, 480);

		if (FollowerMenuLevel[consoleplayer] > FMenu_Closed && !AutomapActive && GameState == GS_LEVEL)
		{
			DrawCommandMenu(HDStatusBar(StatusBar), (0, 40), StatusBar.DI_SCREEN_LEFT | StatusBar.DI_SCREEN_VCENTER | StatusBar.DI_TEXT_ALIGN_LEFT);
		}

		// --------------- PRETEND WE WERE NEVER HERE ---------------

		StatusBar.BeginHUD(1.0, false);
		StatusBar.SetSize(StatusBar.RelTop, OriginalWidth, OriginalHeight);
	}

	// ----------------------------------------------------------------------
	//
	// NAVIGATION AND WHATNOT
	//
	// ----------------------------------------------------------------------

	override void UiTick()
	{
		Super.UiTick();

		if (RepeatTics[consoleplayer] % 3 == 0)
		{
			switch (FollowerMenuLevel[consoleplayer])
			{
				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Inventory:
				{
					HDFollower SFol = Selection[consoleplayer].GetLast();
					int maxSIndex = HDFollower.SlotCount - 1;
					if (ArrowKeysHeld[consoleplayer] & HOLD_LEFT)
					{
						if (SlotFocused[consoleplayer] == 0 && FSlotIndex[consoleplayer] % InvColumns > 0)
						{
							FSlotIndex[consoleplayer] = max(FSlotIndex[consoleplayer] - 1, 0);
						}
						else if (SlotFocused[consoleplayer] == 1)
						{
							if (--PSlotSubIndex[consoleplayer] < 0)
							{
								PSlotSubIndex[consoleplayer] = maxSIndex;
							}
						}
						else if (SlotFocused[consoleplayer] == 2)
						{
							int amt = Modifiers[consoleplayer] & OpMod_Shift ? 20 : 2;
							TransferAmount[consoleplayer] = clamp(TransferAmount[consoleplayer] - amt, 0, 1000);
						}
					}
					if (ArrowKeysHeld[consoleplayer] & HOLD_RIGHT)
					{
						if (SlotFocused[consoleplayer] == 0 && FSlotIndex[consoleplayer] % InvColumns < InvColumns - 1)
						{
							FSlotIndex[consoleplayer] = min(FSlotIndex[consoleplayer] + 1, maxSIndex);
						}
						else if (SlotFocused[consoleplayer] == 1)
						{
							if (++PSlotSubIndex[consoleplayer] > maxSIndex)
							{
								PSlotSubIndex[consoleplayer] = 0;
							}
						}
						else if (SlotFocused[consoleplayer] == 2)
						{
							int amt = Modifiers[consoleplayer] & OpMod_Shift ? 20 : 2;
							TransferAmount[consoleplayer] = clamp(TransferAmount[consoleplayer] + amt, 0, 1000);
						}
					}
					if (ArrowKeysHeld[consoleplayer] & HOLD_UP)
					{
						if (SlotFocused[consoleplayer] == 0)
						{
							if (FSlotIndex[consoleplayer] > InvColumns - 1)
							{
								FSlotIndex[consoleplayer] = max(FSlotIndex[consoleplayer] - InvColumns, 0);
							}
						}
						else if (SlotFocused[consoleplayer] == 1)
						{
							UpdateValidItems(SFol);
							if (--PSlotIndex[consoleplayer] < 0)
							{
								PSlotIndex[consoleplayer] = ValidItems[consoleplayer].Items.Size() - 1;
							}
						}
					}
					if (ArrowKeysHeld[consoleplayer] & HOLD_DOWN)
					{
						if (SlotFocused[consoleplayer] == 0)
						{
							if (FSlotIndex[consoleplayer] < maxSIndex - (InvColumns - 1))
							{
								FSlotIndex[consoleplayer] = min(FSlotIndex[consoleplayer] + InvColumns, maxSIndex);
							}
						}
						else if (SlotFocused[consoleplayer] == 1)
						{
							UpdateValidItems(SFol);
							if (++PSlotIndex[consoleplayer] == ValidItems[consoleplayer].Items.Size())
							{
								PSlotIndex[consoleplayer] = 0;
							}
						}
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_ColorPicker:
				{
					int maxIndex = TColors.Size() - 1;
					if (ArrowKeysHeld[consoleplayer] & HOLD_LEFT && SelectedColorIndex[consoleplayer] % PickerColumns > 0)
					{
						SelectedColorIndex[consoleplayer] = max(SelectedColorIndex[consoleplayer] - 1, 0);
					}
					if (ArrowKeysHeld[consoleplayer] & HOLD_RIGHT && SelectedColorIndex[consoleplayer] % PickerColumns < PickerColumns - 1)
					{
						SelectedColorIndex[consoleplayer] = min(SelectedColorIndex[consoleplayer] + 1, maxIndex);
					}
					if (ArrowKeysHeld[consoleplayer] & HOLD_UP && SelectedColorIndex[consoleplayer] > PickerColumns - 1)
					{
						SelectedColorIndex[consoleplayer] = max(SelectedColorIndex[consoleplayer] - PickerColumns, 0);
					}
					if (ArrowKeysHeld[consoleplayer] & HOLD_DOWN)
					{
						SelectedColorIndex[consoleplayer] = min(SelectedColorIndex[consoleplayer] + PickerColumns, maxIndex);
					}
					break;
				}
			}	
		}

		if (ArrowKeysHeld[consoleplayer] & HOLD_LEFT || ArrowKeysHeld[consoleplayer] & HOLD_RIGHT || ArrowKeysHeld[consoleplayer] & HOLD_UP || ArrowKeysHeld[consoleplayer] & HOLD_DOWN)
		{
			RepeatTics[consoleplayer]++;
		}
		else
		{
			RepeatTics[consoleplayer] = 0;
		}

		if (FollowerMenuLevel[consoleplayer] != FMenu_Inventory)
		{
			SlotFocused[consoleplayer] = 0;
			FSlotIndex[consoleplayer] = 0;
			PSlotIndex[consoleplayer] = 0;
			PSlotSubIndex[consoleplayer] = 0;
		}

		if (SlotFocused[consoleplayer] < 2)
		{
			TransferAmount[consoleplayer] = 0;
		}

		if (SlotFocused[consoleplayer] < 1)
		{
			PSlotSubIndex[consoleplayer] = 0;
		}

		int size = ValidItems[consoleplayer].Items.Size();
		PSlotIndex[consoleplayer] = clamp(PSlotIndex[consoleplayer], 0, size - 1);
		if (size > 0 && !ValidItems[consoleplayer].Items[PSlotIndex[consoleplayer]])
		{
			ValidItems[consoleplayer].Items.Delete(PSlotIndex[consoleplayer]);
			if (SlotFocused[consoleplayer] == 2)
			{
				SlotFocused[consoleplayer] = 1;
				TransferAmount[consoleplayer] = 0;
			}
		}
	}

	// ----------------------------------------------------------------------
	//
	// COMMAND MENU
	//
	// ----------------------------------------------------------------------

	private ui void DrawCommandMenu(HDStatusBar sb, vector2 pos, int flags)
	{
		vector2 OriginalPos = pos;
		int RectangleHeight = MainFont.mFont.GetHeight() + 4;

		HDFollower SFol = Selection[consoleplayer].GetLast();

		switch (FollowerMenuLevel[consoleplayer])
		{
			case FMenu_Recruitment:
			{
				if (!SelMarine[consoleplayer] || SelMarine[consoleplayer].Health <= 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				Array<string> Commands;
				Commands.Push("Recruit?");
				Commands.Push("Cancel");

				string n = (SelMarine[consoleplayer].bFRIENDLY ? "Friendly " : "Hostile ")..SelMarine[consoleplayer].GetTag();
				DrawRectangle(sb, pos, (140, RectangleHeight), MainFont, GetTruncatedText(n, 16), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;

				for (int i = 0; i < Commands.Size(); ++i)
				{
					DrawRectangle(sb, pos, (140, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
					pos.y += RectangleHeight + Spacing;
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Followers:
			{
				if (Followers.Size() == 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				
				int FSize = Followers.Size();
				int RelSize = min(FollowersPerPage, FSize - FollowersPerPage * FollowerPage[consoleplayer]);
				if (RelSize > 4)
				{
					pos.y -= (RectangleHeight * 2 - 4) * 4;
				}

				int LastIndex = 0;
				for (int i = FollowersPerPage * FollowerPage[consoleplayer]; i < min(FollowersPerPage * (FollowerPage[consoleplayer] + 1), FSize); ++i)
				{
					LastIndex++;
					bool Valid = Followers[i].CanInteractWith(false);
					int FollowerBlockSize = Valid ? RectangleHeight * 2 - 2 : RectangleHeight;
					DrawFollowerRectangle(sb, pos, (150, FollowerBlockSize), MainFont, LastIndex, Followers[i], Valid, flags);
					pos.y += FollowerBlockSize + Spacing;
				}
				if (FSize > FollowersPerPage * (FollowerPage[consoleplayer] + 1))
				{
					LastIndex++;
					DrawRectangle(sb, pos, (150, RectangleHeight), MainFont, LastIndex..") Next...", flags);
					pos.y += RectangleHeight + Spacing;
				}
				if (FollowerPage[consoleplayer] > 0)
				{
					LastIndex++;
					if (LastIndex == 10)
					{
						LastIndex = 0;
					}
					DrawRectangle(sb, pos, (150, RectangleHeight), MainFont, LastIndex..") Back...", flags);
					pos.y += RectangleHeight + Spacing;
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Main:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				if (SFol.Health <= 0)
				{
					int RequiredSips = SFol.GetRequiredSips();
					int RequiredBlood = SFol.GetRequiredBlood();
					string BloodDanger;
					if (RequiredBlood < 10)
					{
						BloodDanger = "\c[FLW_BloodGreen](Safe)\c-";
					}
					else if (RequiredBlood < 20)
					{
						BloodDanger = "\c[FLW_BloodPoison](Risky)\c-";
					}
					else if (RequiredBlood < 30)
					{
						BloodDanger = "\c[FLW_BloodYellow](Dangerous)\c-";
					}
					else if (RequiredBlood < 40)
					{
						BloodDanger = "\c[FLW_BloodOrange](Extremely Risky)\c-";
					}
					else if (RequiredBlood < 50)
					{
						BloodDanger = "\c[FLW_BloodRed](Almost Deadly)\c-";
					}
					else
					{
						BloodDanger = "\c[FLW_BloodBlack](Certain Death)\c-";
					}

					Array<string> Commands;
					Commands.Push("Carry follower");
					if (SFol.ResurrectType & HDFollower.RESF_BLUES)
					{
						Commands.Push((sb.CheckInventory("BluePotion", 1) ? "" : "\c[Red]").."Give blue potion\c- ".."\c[Blue]("..RequiredSips.."/12)\c-");
					}
					if (SFol.ResurrectType & HDFollower.RESF_BLOOD)
					{
						Commands.Push("Feed blood "..BloodDanger);
					}
					Commands.Push("Manage inventory");
					if (SFol.bCANDISMISS)
					{
						Commands.Push("\c[FLW_BloodRed]Dismiss\c-");
					}
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 25), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += RectangleHeight + Spacing;

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += RectangleHeight + Spacing;
					}
				}
				else if (SFol.bFRIENDLY)
				{
					int Durability = 0;
					bool Mega = false;
					bool Waiting = SFol.Status == FStatus_WaitingForArmor;
					let Armor = HDArmourWorn(SFol.FindInventory("HDArmourWorn"));
					if (Armor)
					{
						Durability = Armor.Durability;
						Mega = Armor.Mega;
					}

					Array<string> Commands;
					Commands.Push("Orders");
					Commands.Push("Carry follower");
					Commands.Push("Manage inventory");
					Commands.Push((Waiting ? "Confirm/Cancel?" : "Use/drop armor"..(Durability > 0 ? (Mega ? "\c[Blue]" : "\c[DarkGreen]").." ("..Durability..")": "")).."\c-");
					Commands.Push("Misc commands");
					if (Followers.Size() > 1)
					{
						Commands.Push("Back...");
					}

					int RectangleWidth = 160;
					if (!Waiting && Durability > 0)
					{
						RectangleWidth += 40;
					}

					DrawRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), RectangleWidth > 160 ? 24 : 20), flags, Font.FindFontColor('FLW_NameBlue'));
					pos.y += RectangleHeight + Spacing;
					
					if (Followers.Size() == 1 && SFol.CanInteractWith(false))
					{
						double Dist = SFol.Distance3D(SFol.LinkedPlayer) / 42.0;
						DrawRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, String.Format("%.2fm", Dist), flags, Font.CR_DARKGRAY);
						pos.y += RectangleHeight + Spacing;
					}

					for (int i = 0; i < Commands.Size(); ++i)
					{
						DrawRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
						pos.y += RectangleHeight + Spacing;
					}
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Orders:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				static const string Orders[] = { "Follow", "Follow and ignore hostiles", "Stay and provide cover", "Go there and provide cover", "Come and help me" };

				DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 30), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;
				for (int i = 0; i < Orders.Size(); ++i)
				{
					DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, (i + 1)..") "..(SFol.Order == i ? "\c[Green]" : "")..Orders[i].."\c-", flags);
					pos.y += RectangleHeight + Spacing;
				}
				DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, (Orders.Size() + 1)..") Back...", flags);
				break;
			}
			case FMenu_OrdersMulti:
			{
				if (Followers.Size() == 0)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}
				static const string Orders[] = { "Follow", "Follow and ignore hostiles", "Stay and provide cover" };

				DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, Selection[consoleplayer].SelFollowers.Size().." followers selected", flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;
				for (int i = 0; i < Orders.Size(); ++i)
				{
					DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, (i + 1)..") "..Orders[i], flags);
					pos.y += RectangleHeight + Spacing;
				}
				DrawRectangle(sb, pos, (240, RectangleHeight), MainFont, (Orders.Size() + 1)..") Back...", flags);
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Inventory:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				int RectangleWidth = InvColumns * SlotSize + (InvColumns - 1) + 2;

				pos.y -= 120;
				DrawRectangle(sb, pos, (RectangleWidth, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 30), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;

				int wSize = SFol.Weapons.Size();
				if (wSize > 0)
				{
					SelWeaponIndex[consoleplayer] = min(SelWeaponIndex[consoleplayer], wSize - 1);
					DrawWeaponRectangle(sb, pos, (RectangleWidth, RectangleHeight * 3), MainFont, flags, SFol, SFol.Weapons[SelWeaponIndex[consoleplayer]]);
					pos.y += RectangleHeight * 3 + Spacing;
				}

				int rows = int(ceil(HDFollower.SlotCount / double(InvColumns)));
				int invRectHeight = Rows * SlotSize + (Rows - 1) + 2;
				DrawFollowerInventory(sb, pos, (RectangleWidth, invRectHeight), MainFont, flags, SFol);

				if (SlotFocused[consoleplayer] > 0)
				{
					DrawPlayerInventory(sb, pos + (RectangleWidth + 1, 0), (RectangleWidth, invRectHeight), MainFont, flags);
				}

				DrawRectangle(sb, pos + (0, invRectHeight + 1), (RectangleWidth, RectangleHeight), MainFont, "0) Cancel/Back", flags);
				pos.y += RectangleHeight + Spacing;

				if (wSize > 0)
				{
					if (wSize > 1)
					{
						DrawRectangle(sb, pos + (0, invRectHeight + 1), (RectangleWidth, RectangleHeight), MainFont, String.Format("1-%i) Weapon 1-%i", wSize, wSize), flags);
						pos.y += RectangleHeight + Spacing;
					}

					if (SFol.CanInteractWith(false))
					{
						DrawRectangle(sb, pos + (0, invRectHeight + 1), (RectangleWidth, RectangleHeight), MainFont, "Spc) Reload", flags);
						pos.y += RectangleHeight + Spacing;
					}
				}

				DrawRectangle(sb, pos + (0, invRectHeight + 1), (RectangleWidth, RectangleHeight), MainFont, "Bsp) Take", flags); pos.y += RectangleHeight + Spacing;
				DrawRectangle(sb, pos + (0, invRectHeight + 1), (RectangleWidth, RectangleHeight), MainFont, "Ent) Select/Give", flags); pos.y += RectangleHeight + Spacing;

				if (wSize > 0)
				{
					bool Waiting = SFol.Status == FStatus_WaitingForWeapon;
					DrawRectangle(sb, pos + (0, invRectHeight + 1), (RectangleWidth, RectangleHeight), MainFont, "P) "..(Waiting ? "Confirm/Cancel?" : "Pickup weapon"), flags); pos.y += RectangleHeight + Spacing;
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_Miscellaneous:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				Array<string> Commands;
				Commands.Push("Change color");
				if (SFol.bCANDISMISS)
				{
					Commands.Push("\c[FLW_BloodRed]Dismiss\c-");
				}
				Commands.Push("Back...");

				DrawRectangle(sb, pos, (160, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), 20), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;

				for (int i = 0; i < Commands.Size(); ++i)
				{
					DrawRectangle(sb, pos, (160, RectangleHeight), MainFont, (i + 1)..") "..Commands[i], flags);
					pos.y += RectangleHeight + Spacing;
				}
				break;
			}

			// --------------------------------------------------------------------------------
			//
			// --------------------------------------------------------------------------------

			case FMenu_ColorPicker:
			{
				if (!SFol)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					return;
				}

				int tSize = TColors.Size();
				int rows = int(ceil(tSize / double(PickerColumns)));
				double w = PickerColumns * ColSquareSize + (PickerColumns - 1) + 2;
				double h = rows * ColSquareSize + (rows - 1) + 2;

				DrawRectangle(sb, pos, (w, RectangleHeight), MainFont, GetTruncatedText(SFol.GetDisplayName(), int(ceil(w / 8))), flags, Font.FindFontColor('FLW_NameBlue'));
				pos.y += RectangleHeight + Spacing;

				sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, w, h, flags);
				
				for (int i = 0; i < tSize; ++i)
				{
					if (SelectedColorIndex[consoleplayer] == i)
					{
						Color selCol = Color(255, int(TColors[i].r * 1.5), int(TColors[i].g * 1.5), int(TColors[i].b * 1.5));
						sb.Fill(selCol, pos.x + (ColSquareSize + 1) * (i % PickerColumns), pos.y + (ColSquareSize + 1) * (i / PickerColumns), ColSquareSize + 2, ColSquareSize + 2, flags);
					}
					sb.Fill(TColors[i], pos.x + 1 + (ColSquareSize + 1) * (i % PickerColumns), pos.y + 1 + (ColSquareSize + 1) * (i / PickerColumns), ColSquareSize, ColSquareSize, flags);
				}

				DrawRectangle(sb, pos + (0, h + 1), (w, RectangleHeight), MainFont, "0) Back", flags);
				pos.y += RectangleHeight + Spacing;
				break;
			}

		}
	}

	// ----------------------------------------------------------------------
	//
	// UI FUNCTIONS
	//
	// ----------------------------------------------------------------------

	private ui void DrawFollowerRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int index, HDFollower flw, bool valid, int flags)
	{
		bool selected = Selection[consoleplayer].SelFollowers.Find(flw) != Selection[consoleplayer].SelFollowers.Size();
		Color c = valid ? (selected ? Color(96, 96, 255, 96) : Color(64, 128, 192, 255)) : Color(64, 255, 16, 16);
		sb.Fill(c, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		pos += (2, 2);
		int FontHeight = fnt.mFont.GetHeight();
		sb.DrawString(fnt, index..") "..GetTruncatedText(flw.GetDisplayName(), 15), pos, flags, Font.FindFontColor('FLW_NameBlue')); pos.y += FontHeight + 1;

		if (valid)
		{
			double Dist = flw.Distance3D(flw.LinkedPlayer) / 42.0;
			sb.DrawString(fnt, String.Format("%.2fm", Dist), pos, flags, Font.CR_DARKGRAY); pos.y += FontHeight + 1;
		}
	}

	private ui void DrawWeaponRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int flags, HDFollower flw, FollowerWeapon wpn)
	{
		Color col = wpn.Enabled ? Color(64, 128, 192, 255) : Color(128, 192, 64, 64);
		sb.Fill(col, pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		sb.DrawString(fnt, wpn.GetName(), pos + (2, 2), flags, Font.FindFontColor('FLW_WeaponBlue'));

		// [Ace] Icon.
		sb.DrawImage(wpn.GetIcon(), pos + (4, 12), flags | sb.DI_ITEM_LEFT_TOP, 1.0, (size.x / 2, 17));

		// [Ace] Spare ammo.
		class<HDAmmo> AType, MType; int MaxMag;
		[AType, MType, MaxMag] = wpn.GetAmmoType();

		sb.DrawString(fnt, "Ammo", pos + (size.x - 4, size.y - 24), flags | sb.DI_TEXT_ALIGN_RIGHT, Font.CR_WHITE);
		string ChamberString = "";
		switch (wpn.ChamberedRound)
		{
			case FollowerWeapon.CRType_Chambered: ChamberString = "+"; break;
			case FollowerWeapon.CRType_Spent: ChamberString = "_"; break;
		}
		sb.DrawString(fnt, ChamberString..sb.FormatNumber(flw.GetAmount(MType ? MType : AType), 1, 4), pos + (size.x - 4, size.y - 15), flags | sb.DI_TEXT_ALIGN_RIGHT, Font.CR_WHITE);

		// [Ace] Magazine bar.
		sb.Fill(col, pos.x + 1, pos.y + (size.y - 4), size.x - 2, 1, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + (size.y - 3), size.x - 2, 2, flags);
		double AmPercent = clamp(wpn.Mag / double(MaxMag), 0, 1.0);
		sb.Fill(GetPercentColor(AmPercent), pos.x + 1, pos.y + (size.y - 3), (size.x - 2) * AmPercent, 2, flags);
	}

	private ui void DrawFollowerInventory(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int flags, HDFollower flw)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		for (int i = 0; i < HDFollower.SlotCount; ++i)
		{
			vector2 realPos = (SlotSize * (i % InvColumns) + (i % InvColumns), SlotSize * (i / InvColumns) + (i / InvColumns));

			Color col;
			switch (FSlotIndex[consoleplayer] == i ? (SlotFocused[consoleplayer] > 0 ? 2 : 1) : 0)
			{
				case 0: col = Color(64, 128, 192, 255); break;
				case 1: col = Color(128, 255, 255, 128); break;
				case 2: col = Color(96, 96, 255, 96); break;
			}
			sb.Fill(col, pos.x + 1 + realPos.x, pos.y + 1 + realPos.y, SlotSize, SlotSize, flags);
			sb.Fill(Color(128, 0, 0, 0), pos.x + 2 + realPos.x, pos.y + 2 + realPos.y, SlotSize - 2, SlotSize - 2, flags);

			let item = flw.Slots[i];
			if (item)
			{
				sb.DrawImage(item.Icon, pos + (1, 1) + (SlotSize, SlotSize) / 2 + realPos, flags | sb.DI_ITEM_CENTER, 1.0, (SlotSize, SlotSize) - (6, 6), (3.0, 3.0));
				if (item.Amount > int(!item.Multipickup))
				{
					sb.DrawString(sb.mAmountFont, sb.FormatNumber(item.Amount, 1, 4), pos + (3, SlotSize - 8) + realPos, flags, Font.CR_GOLD);
				}
			}
		}
	}

	// [Ace] Contrary to what the function is called, it only draws the *valid* items.
	private ui void DrawPlayerInventory(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int flags)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);

		for (int i = 0; i < HDFollower.SlotCount; ++i)
		{
			vector2 realPos = (SlotSize * (i % InvColumns) + (i % InvColumns), SlotSize * (i / InvColumns) + (i / InvColumns));

			Color col;
			switch (PSlotSubIndex[consoleplayer] == i ? (SlotFocused[consoleplayer] > 1 ? 2 : 1) : 0)
			{
				case 0: col = Color(64, 128, 192, 255); break;
				case 1: col = Color(128, 255, 255, 128); break;
				case 2: col = Color(96, 96, 255, 96); break;
			}
			sb.Fill(col, pos.x + 1 + RealPos.x, pos.y + 1 + RealPos.y, SlotSize, SlotSize, flags);
			sb.Fill(Color(128, 0, 0, 0), pos.x + 2 + RealPos.x, pos.y + 2 + RealPos.y, SlotSize - 2, SlotSize - 2, flags);
		}

		int vSize = ValidItems[consoleplayer].Items.Size();
		HDPickup item = vSize > 0 && PSlotIndex[consoleplayer] < vSize ? ValidItems[consoleplayer].Items[PSlotIndex[consoleplayer]] : null;
		if (!item)
		{
			return;
		}

		int count = item is 'HDMagAmmo' ? HDMagAmmo(item).Mags.Size() : (!item.bMULTIPICKUP ? item.Amount : 1);
		for (int i = 0; i < min(count, HDFollower.SlotCount); ++i)
		{
			vector2 realPos = (SlotSize * (i % InvColumns) + (i % InvColumns), SlotSize * (i / InvColumns) + (i / InvColumns));
			int amt = item.Amount;
			if (item is 'HDMagAmmo')
			{
				HDMagAmmo mag = HDMagAmmo(item);
				amt = mag.Mags[i];
			}
			string icon = AceCore.GetIcon(item, amt);
			sb.DrawImage(icon, pos + (1, 1) + (SlotSize, SlotSize) / 2 + RealPos, flags | sb.DI_ITEM_CENTER, 1.0, (SlotSize, SlotSize) - (6, 6), (3.0, 3.0));
			if (item is 'HDMagAmmo' && !(item is 'HDInjectorMaker') || item.bMULTIPICKUP && item.Amount > 0)
			{
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(amt, 1, 4), pos + (3, SlotSize - 8) + realPos, flags, Font.CR_GOLD);
			}
		}

		if (SlotFocused[consoleplayer] == 2)
		{
			int RectangleHeight = MainFont.mFont.GetHeight() + 4;
			DrawAmountRectangle(sb, pos + (0, size.y + 1), (size.x, RectangleHeight), fnt, TransferAmount[consoleplayer], 1000, flags, Font.CR_CREAM);
		}
	}

	private ui void DrawAmountRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, int amt, int maxAmt, int flags, int col = Font.CR_WHITE)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);
		double percent = amt / double(maxAmt);
		sb.Fill(Color(32, 255, 255, 128), pos.x + 1, pos.y + 1, (size.x - 2) * percent, size.y - 2, flags);
		sb.DrawString(fnt, "Amount:"..amt, pos + (2, 2), flags, col);
	}

	private ui void DrawRectangle(HDStatusBar sb, vector2 pos, vector2 size, HUDFont fnt, string command, int flags, int col = Font.CR_WHITE)
	{
		sb.Fill(Color(64, 128, 192, 255), pos.x, pos.y, size.x, size.y, flags);
		sb.Fill(Color(128, 0, 0, 0), pos.x + 1, pos.y + 1, size.x - 2, size.y - 2, flags);
		if (command != "")
		{
			sb.DrawString(fnt, command, (pos.x + 2, pos.y + (size.y - fnt.mFont.GetHeight()) / 2), flags, col); 
		}
	}

	// ----------------------------------------------------------------------
	//
	// INPUT PROCESS
	//
	// ----------------------------------------------------------------------

	override bool InputProcess(InputEvent e)
	{
		// [Ace] This exists so that your input isn't arbitrarily intercepted when it shouldn't be. Returning directly won't fly.
		bool ret = false;

		bool IsShift = e.KeyScan == InputEvent.Key_LShift || e.KeyScan == InputEvent.Key_RShift;
		bool IsCtrl = e.KeyScan == InputEvent.Key_LCtrl || e.KeyScan == InputEvent.Key_RCtrl;
		bool IsAlt = e.KeyScan == InputEvent.Key_LAlt || e.KeyScan == InputEvent.Key_RAlt;
		if (IsShift || IsCtrl || IsAlt)
		{
			if (e.Type == InputEvent.Type_KeyDown)
			{
				SendNetworkEvent("HDF_SetModifiers", 1, IsShift ? OpMod_Shift : (IsAlt ? OpMod_Alt : OpMod_Ctrl));
			}
			else if (e.Type == InputEvent.Type_KeyUp)
			{
				SendNetworkEvent("HDF_SetModifiers", 0, IsShift ? OpMod_Shift : (IsAlt ? OpMod_Alt : OpMod_Ctrl));
			}
		}

		if (e.Type == InputEvent.Type_KeyDown)
		{
			switch (e.KeyScan)
			{
				case InputEvent.Key_LeftArrow: ArrowKeysHeld[consoleplayer] |= HOLD_LEFT; break;
				case InputEvent.Key_RightArrow: ArrowKeysHeld[consoleplayer] |= HOLD_RIGHT; break;
				case InputEvent.Key_UpArrow: ArrowKeysHeld[consoleplayer] |= HOLD_UP; break;
				case InputEvent.Key_DownArrow: ArrowKeysHeld[consoleplayer] |= HOLD_DOWN; break;
			}
		}
		else if (e.Type == InputEvent.Type_KeyUp)
		{
			switch (e.KeyScan)
			{
				case InputEvent.Key_LeftArrow: ArrowKeysHeld[consoleplayer] &= ~HOLD_LEFT; break;
				case InputEvent.Key_RightArrow: ArrowKeysHeld[consoleplayer] &= ~HOLD_RIGHT; break;
				case InputEvent.Key_UpArrow: ArrowKeysHeld[consoleplayer] &= ~HOLD_UP; break;
				case InputEvent.Key_DownArrow: ArrowKeysHeld[consoleplayer] &= ~HOLD_DOWN; break;
			}
		}
		
		// --------------------------------------------------------------------------------
		// THIS IS WHERE THE REAL FUN BEGINS
		// --------------------------------------------------------------------------------

		if (FollowerMenuLevel[consoleplayer] > FMenu_Closed && e.Type == InputEvent.Type_KeyDown)
		{
			int NumKey = e.KeyChar - 48;
			if (NumKey == 0)
			{
				NumKey = 10;
			}

			switch (FollowerMenuLevel[consoleplayer])
			{
				case FMenu_Recruitment:
				{
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_ConfirmRecruitment"); break;
						case 2: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed); break;
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Followers:
				{
					if (e.KeyScan == InputEvent.Key_Enter)
					{
						SendNetworkEvent("HDF_ApplySelection");
						ret = true;
					}
					else if (Modifiers[consoleplayer] & OpMod_Ctrl)
					{
						int Page = Modifiers[consoleplayer] & OpMod_Alt ? FollowerPage[consoleplayer] : -1;
						switch (e.KeyChar)
						{
							// [Ace] A - Select (A)ll, (I)nvert, (D)eselect.
							case 65: case 97:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 0, Page);
								break;
							}
							case 73: case 105:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 1, Page);
								break;
							}
							case 68: case 100:
							{
								SendNetworkEvent("HDF_ManipulateSelection", 2, Page);
								break;
							}
						}
						ret = true;
					}
					else
					{
						int FSize = Followers.Size();
						int RelSize = min(FollowersPerPage, FSize - FollowersPerPage * FollowerPage[consoleplayer]);
						bool HasMorePages = FSize > FollowersPerPage * (FollowerPage[consoleplayer] + 1);
						int SelIndex = (NumKey + FollowersPerPage * FollowerPage[consoleplayer]) - 1;
						if (NumKey == RelSize + 1 && HasMorePages)
						{
							SendNetworkEvent("HDF_SetFollowerPage", 1);
						}
						else if (FollowerPage[consoleplayer] > 0 && NumKey == RelSize + (HasMorePages ? 2 : 1))
						{
							SendNetworkEvent("HDF_SetFollowerPage", 0);
						}
						else if (NumKey > 0 && (NumKey - 1) < RelSize)
						{
							if (Modifiers[consoleplayer] & OpMod_Shift)
							{
								SendNetworkEvent("HDF_ToggleSelection", SelIndex);
							}
							else
							{
								SendNetworkEvent("HDF_ToggleSelection", SelIndex, true);
								SendNetworkEvent("HDF_ApplySelection");
							}
						}
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Main:
				{
					HDFollower SFol = Selection[consoleplayer].GetLast();
					if (SFol.Health <= 0)
					{
						Array<FollowerCommand> Commands;
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						if (SFol.ResurrectType & HDFollower.RESF_BLUES)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 0));
						}
						if (SFol.ResurrectType & HDFollower.RESF_BLOOD)
						{
							Commands.Push(CreateCommand("HDF_TryRevive", 1));
						}
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Inventory));
						if (SFol.bCANDISMISS)
						{
							Commands.Push(CreateCommand("HDF_DismissFollower"));
						}
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}

						if (NumKey > 0 && NumKey - 1 < Commands.Size())
						{
							FollowerCommand cmd = Commands[NumKey - 1];
							SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
						}
					}
					else if (SFol.bFRIENDLY)
					{
						Array<FollowerCommand> Commands;
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Orders));
						Commands.Push(CreateCommand("HDF_CarryFollower"));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Inventory));
						Commands.Push(CreateCommand("HDF_TryArmor"));
						Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Miscellaneous));
						if (Followers.Size() > 1)
						{
							Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Followers));
						}
						
						if (NumKey > 0 && NumKey - 1 < Commands.Size())
						{
							FollowerCommand cmd = Commands[NumKey - 1];
							SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
						}
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------
					
				case FMenu_Orders:
				{
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_ChangeOrders", FOrder_Follow); break;
						case 2: SendNetworkEvent("HDF_ChangeOrders", FOrder_FollowIgnore); break;
						case 3: SendNetworkEvent("HDF_ChangeOrders", FOrder_Cover); break;
						case 4: SendNetworkEvent("HDF_ChangeOrders", FOrder_GoAndCover); break;
						case 5: SendNetworkEvent("HDF_ChangeOrders", FOrder_ComeAndHelp); break;
						case 6: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main); break;
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_OrdersMulti:
				{
					switch (NumKey)
					{
						case 1: SendNetworkEvent("HDF_ChangeOrdersMulti", FOrder_Follow); break;
						case 2: SendNetworkEvent("HDF_ChangeOrdersMulti", FOrder_FollowIgnore); break;
						case 3: SendNetworkEvent("HDF_ChangeOrdersMulti", FOrder_Cover); break;
						case 4: SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Followers); break;
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Inventory:
				{
					HDFollower SFol = Selection[consoleplayer].GetLast();
					if (NumKey > 0 && NumKey < 10)
					{
						SelWeaponIndex[consoleplayer] = min(NumKey - 1, SFol.Weapons.Size() - 1);
						ret = true;
					}

					// [Ace] Navigation.
					int maxSIndex = HDFollower.SlotCount - 1;
					switch (e.KeyScan)
					{
						case InputEvent.Key_Space:
						{
							SendNetworkEvent("HDF_TryReloadWeapon", SelWeaponIndex[consoleplayer]);
							ret = true;
							break;
						}
						case InputEvent.Key_Enter:
						{
							if (SlotFocused[consoleplayer] == 0)
							{
								UpdateValidItems(SFol);
								SlotFocused[consoleplayer]++;
								for (int i = 0; i < ValidItems[consoleplayer].Items.Size(); ++i)
								{
									class<HDAmmo> AType, MType; int MaxMag;
									[AType, MType, MaxMag] = SFol.Weapons[SelWeaponIndex[consoleplayer]].GetAmmoType();

									InventorySlot selSlot = SFol.Slots[FSlotIndex[consoleplayer]];
									class<HDPickup> itemcls = ValidItems[consoleplayer].Items[i].GetClass();
									if (SelSlot && SelSlot.ItemClass == itemcls || !SelSlot && itemcls == (MType ? MType : AType))
									{
										PSlotIndex[consoleplayer] = i;
										break;
									}
								}
							}
							else if (SlotFocused[consoleplayer] == 1)
							{
								int size = ValidItems[consoleplayer].Items.Size();
								if (size > 0 && PSlotIndex[consoleplayer] < size)
								{
									HDPickup item = ValidItems[consoleplayer].Items[PSlotIndex[consoleplayer]];
									if (IsValidIndex(item, PSlotSubIndex[consoleplayer]))
									{
										if (item is 'HDMagAmmo' || !item.bMULTIPICKUP)
										{
											if (item is 'HDMagAmmo')
											{
												SendNetworkEvent('hdf_transfermag:'..item.GetClassName(), PSlotSubIndex[consoleplayer], FSlotIndex[consoleplayer]);
											}
											else
											{
												SendNetworkEvent('hdf_transferitem:'..item.GetClassName(), 1, FSlotIndex[consoleplayer]);
											}
										}
										else
										{
											SlotFocused[consoleplayer]++;
										}
									}
									UpdateValidItems(SFol);
								}
								else
								{
									SlotFocused[consoleplayer]--;
								}
							}
							else if (SlotFocused[consoleplayer] == 2)
							{
								int size = ValidItems[consoleplayer].Items.Size();
								if (size > 0 && PSlotIndex[consoleplayer] < size)
								{
									HDPickup item = ValidItems[consoleplayer].Items[PSlotIndex[consoleplayer]];
									SendNetworkEvent('hdf_transferitem:'..item.GetClassName(), TransferAmount[consoleplayer], FSlotIndex[consoleplayer]);
									SlotFocused[consoleplayer] = 0;
								}
								else
								{
									SlotFocused[consoleplayer] = 0;
								}
							}
							ret = true;
							break;
						}
						case InputEvent.Key_Backspace:
						{
							if (SFol.Slots[FSlotIndex[consoleplayer]] && SlotFocused[consoleplayer] < 2)
							{
								SendNetworkEvent("HDF_TakeInvItem", FSlotIndex[consoleplayer]);
								ret = true;
							}
							break;
						}
					}

					if (e.KeyChar == 80 || e.KeyChar == 112)
					{
						SendNetworkEvent("HDF_TryWeapon");
						ret = true;
					}

					if (NumKey == 10)
					{
						if (SlotFocused[consoleplayer] > 0)
						{
							SlotFocused[consoleplayer]--;
						}
						else
						{
							SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main);
						}
						ret = true;
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_Miscellaneous:
				{
					Array<FollowerCommand> Commands;

					Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_ColorPicker));
					Commands.Push(CreateCommand("HDF_DismissFollower"));
					Commands.Push(CreateCommand("HDF_SetFollowerMenu", FMenu_Main));
					
					if (NumKey > 0 && NumKey - 1 < Commands.Size())
					{
						FollowerCommand cmd = Commands[NumKey - 1];
						SendNetworkEvent(cmd.EventName, cmd.Args[0], cmd.Args[1], cmd.Args[2]);
						ret = true;
					}
					break;
				}

				// --------------------------------------------------------------------------------
				//
				// --------------------------------------------------------------------------------

				case FMenu_ColorPicker:
				{
					if (e.KeyScan == InputEvent.Key_Enter)
					{
						SendNetworkEvent("HDF_ChangeColor", SelectedColorIndex[consoleplayer]);
						ret = true;
					}
					if (NumKey == 10)
					{
						SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Main);
						ret = true;
					}
					break;
				}
			}

			// [Ace] Block 0-9 keys from affecting the world.
			if (NumKey >= 0 && NumKey <= 10)
			{
				ret = true;
			}

			if (!(Modifiers[consoleplayer] & OpMod_Shift))
			{
				// [Ace] Exit.
				int Key1, Key2;
				[Key1, Key2] = Bindings.GetKeysForCommand("HDF_OpenMenu");
				if (e.KeyScan == Key1 || e.KeyScan == Key2)
				{
					SendNetworkEvent("HDF_SetFollowerMenu", FMenu_Closed);
					ret = true;
				}
			}
			else if (FollowerMenuLevel[consoleplayer] == FMenu_Followers) // [Ace] Used only with the 0-9 keys.
			{
				SendNetworkEvent("HDF_OpenMenu");
			}
		}
		return ret;
	}

	// ----------------------------------------------------------------------
	//
	// NETWORK PROCESS
	//
	// ----------------------------------------------------------------------

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "HDF_SetModifiers")
		{
			switch (e.Args[0])
			{
				case 0: Modifiers[e.Player] &= ~e.Args[1]; break;
				case 1: Modifiers[e.Player] |= e.Args[1]; break;
			}
			return;
		}

		if (e.Name ~== "HDF_SetFollowerPage")
		{
			switch (e.Args[0])
			{
				case 0: FollowerPage[e.Player]--; break;
				case 1: FollowerPage[e.Player]++; break;
			}
			return;
		}

		if (e.Name ~== "HDF_ResetFollower" && e.Args[0] > 0)
		{
			Array<class<HDFollower> > FollowerClasses;

			// [Ace] Find all follower classes first.
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				if (AllActorClasses[i] is 'HDFollower' && AllActorClasses[i].GetClassName() != 'HDFollower')
				{
					FollowerClasses.Push((class<HDFollower>)(AllActorClasses[i]));
				}
			}

			int FollowerIndex = e.Args[0];

			// [Ace; 23.03.2021]
			// The problem with FollowerIndex, in hindsight, is that if two followers share the same index, only the first one would get deleted.
			// I should have used class name for filtering. Unfortunately, it's too late. Not without breaking all of the existing follower sub-addons. Ah well.

			// [Ace] Destroy the class that is being reset, if applicable, then recreate it.
			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].Index == FollowerIndex)
				{
					RemoveFollower(Followers[i]);
					break;
				}
			}
			for (int i = 0; i < FollowerClasses.Size(); ++i)
			{
				if (GetDefaultByType(FollowerClasses[i]).Index == FollowerIndex)
				{
					CreateFollower(FollowerClasses[i], e.Player);
					break;
				}
			}
			return;
		}

		if (e.Name ~== "HDF_ConfirmRecruitment" && !e.IsManual)
		{
			CloseFollowerMenu(e.Player);
			RecruitMarine(SelMarine[e.Player], e.Player);
			return;
		}

		if (e.Name ~== "HDF_OpenMenu")
		{
			let plr = HDPlayerPawn(players[e.Player].mo);

			FLineTraceData TraceData;
			plr.LineTrace(plr.angle, 42 * 20, plr.pitch, TRF_NOSKY, plr.Height - HDCONST_CROWNTOSHOULDER, data: TraceData);
			Actor ATarget = TraceData.HitActor;

			if (ATarget is 'HDMarine' && ATarget.Health > 0 && TraceData.Distance < 42 * 2 && !IsPuppet(ATarget) && (ATarget.bFRIENDLY || ATarget.InStateSequence(ATarget.CurState, ATarget.FindState('Falldown')) && HDMarine(ATarget).Stunned > 70))
			{
				FollowerMenuLevel[e.Player] = FMenu_Recruitment;
				SelMarine[e.Player] = HDMarine(ATarget);
			}
			else
			{
				int FSize = Followers.Size();
				HDFollower flw = HDFollower(ATarget);
				if (flw && flw.CanInteractWith() && e.IsManual && CVar.GetCVar('hdf_quickaccess', players[e.Player]).GetBool())
				{
					if (FSize > 1 && Modifiers[e.Player] & OpMod_Shift)
					{
						ToggleSelection(e.Player, flw);
						FollowerMenuLevel[e.Player] = FMenu_Followers;
					}
					else if (!(Modifiers[e.Player] & OpMod_Shift))
					{
						ToggleSelection(e.Player, flw, true);
						FollowerMenuLevel[e.Player] = FMenu_Main;
						flw.ChangeLinkedPlayer(plr);
					}
				}
				else if (FSize == 1)
				{
					ToggleSelection(e.Player, Followers[0], true);
					FollowerMenuLevel[e.Player] = FMenu_Main;
					Followers[0].ChangeLinkedPlayer(plr);
				}
				else if (FSize > 0)
				{
					FollowerMenuLevel[e.Player] = FMenu_Followers;
				}
			}
			return;
		}

		// [Ace] Always allow to open the follower menu to the first page or close it.
		if (e.Name ~== "HDF_SetFollowerMenu")
		{
			if (e.Args[0] == FMenu_Closed)
			{
				CloseFollowerMenu(e.Player);
				return;
			}

			FollowerMenuLevel[e.Player] = e.Args[0];
			return;
		}

		if (Followers.Size() == 0)
		{
			return;
		}

		// [Ace] This is an obvious cheat, so don't use it unless you absolutely HAVE to.
		if (e.Name ~== "HDF_WarpToPlayer")
		{
			for (int i = 0; i < Followers.Size(); ++i)
			{
				if (Followers[i].Index == e.Args[0])
				{
					Followers[i].WarpToPlayer();
					break;
				}
			}
			return;
		}

		if (e.Name ~== "HDF_ApplySelection")
		{
			ApplySelection(e.Player);
			return;
		}

		if (e.Name ~== "HDF_ToggleSelection")
		{
			// [Ace] Select only that follower.
			if (e.Args[1])
			{
				Selection[e.Player].SelFollowers.Clear();
			}
			ToggleSelection(e.Player, Followers[e.Args[0]], true);
			return;
		}

		if (e.Name ~== "HDF_ManipulateSelection")
		{
			switch (e.Args[0])
			{
				case 0: SelectAll(e.Player, e.Args[1], false); break;
				case 1: SelectAll(e.Player, e.Args[1], true); break;
				case 2: DeselectAll(e.Player, e.Args[1]); break;
			}
			return;
		}

		HDFollower SFol = Selection[e.Player].GetLast();
		if (!SFol || !SFol.CanInteractWith())
		{
			return;
		}

		if (e.Name ~== "HDF_DismissFollower")
		{
			SFol.Dismiss();
			CloseFollowerMenu(e.Player);
			return;
		}

		// [Ace] These commands cannot be used if alive and hostile.
		if (e.Name ~== "HDF_CarryFollower")
		{
			if (SFol.PackFollower())
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_TryRevive")
		{
			if (SFol.TryRevive(e.Args[0]))
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_TryArmor")
		{
			SFol.TryUseArmor();
			return;
		}

		if (e.Name ~== "HDF_TryWeapon")
		{
			SFol.TryUseWeapon();
			return;
		}

		if (e.Name ~== "HDF_ChangeOrders")
		{
			if (SFol.ChangeOrders(e.Args[0]))
			{
				CloseFollowerMenu(e.Player);
			}
			return;
		}

		if (e.Name ~== "HDF_ChangeOrdersMulti")
		{
			for (int i = 0; i < Selection[e.Player].SelFollowers.Size(); ++i)
			{
				Selection[e.Player].SelFollowers[i].ChangeOrders(e.Args[0]);
			}
			CloseFollowerMenu(e.Player);
			return;
		}

		if (e.Name ~== "HDF_TryReloadWeapon" && SFol.CanInteractWith(false) && SFol.Weapons.Size() > 0)
		{
			FollowerWeapon wpn = SFol.Weapons[e.Args[0]];
			SFol.TryReloadWeapon(wpn, HDFollower.RLF_MANUAL);
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_transfermag") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");
			HDMagAmmo item = HDMagAmmo(players[e.Player].mo.FindInventory(split[1]));
			if (item)
			{
				SFol.AddMag(item, e.Args[0], e.Args[1]);
			}
			return;
		}

		if (e.Name.MakeLower().IndexOf("hdf_transferitem") != -1)
		{
			Array<string> split;
			e.Name.Split(split, ":");
			HDPickup item = HDPickup(players[e.Player].mo.FindInventory(split[1]));
			if (item)
			{
				SFol.AddItem(item, e.Args[0], item.bMULTIPICKUP ? HDFollower.MaxLooseAmmoAmount : 1, e.Args[1]);
			}
			return;
		}

		if (e.Name ~== "HDF_TakeInvItem")
		{
			SFol.TakeInvItem(SFol.Slots[e.Args[0]]);
			return;
		}

		if (e.Name ~== "HDF_ChangeColor")
		{
			SFol.A_SetTranslation("FollowerTranslation"..e.Args[0]);
			return;
		}
	}

	// ----------------------------------------------------------------------
	//
	// MISCELLANEOUS HELPER FUNCTIONS
	//
	// ----------------------------------------------------------------------

	// [Ace] The only reason this is used is to allow dynamic menus with a variable number of options. That's literally the only reason.
	private ui FollowerCommand CreateCommand(string evName, int arg1 = 0, int arg2 = 0, int arg3 = 0)
	{
		let Command = new('FollowerCommand');
		Command.EventName = evName;
		Command.Args[0] = arg1;
		Command.Args[1] = arg2;
		Command.Args[2] = arg3;
		return Command;
	}

	private ui void UpdateValidItems(HDFollower flw)
	{
		ValidItems[consoleplayer].Items.Clear();
		Actor plr = players[consoleplayer].mo;
		for (Inventory Next = plr.Inv; Next; Next = Next.Inv)
		{
			HDPickup item = HDPickup(Next);
			if (item && flw.IsValidItem(item.GetClass()))
			{
				ValidItems[consoleplayer].Items.Push(item);
			}
		}
	}

	private ui Color GetPercentColor(double percent)
	{
		if (percent >= 0.75)
		{
			return Color(128, 0, 255, 0);
		}	
		else if (percent >= 0.50)
		{
			return Color(128, 255, 255, 0);
		}
		else if (percent >= 0.25)
		{
			return Color(128, 255, 128, 0);
		}
		else
		{
			return Color(128, 255, 0, 0);
		}
	}

	private ui string GetTruncatedText(string text, int length)
	{
		if (text.Length() > length)
		{
			string TruncatedName = text.Mid(0, length);
			TruncatedName.DeleteLastCharacter();
			TruncatedName.DeleteLastCharacter();
			TruncatedName.DeleteLastCharacter();
			if (TruncatedName.ByteAt(TruncatedName.Length() - 1) == 32)
			{
				TruncatedName.DeleteLastCharacter();
			}
			text = TruncatedName.."...";
		}

		return text;
	}

	private ui bool IsValidIndex(HDPickup pkp, int index)
	{
		let mag = HDMagAmmo(pkp);
		if (mag)
		{
			int mSize =  mag.Mags.Size();
			return mSize > 0 && index < mSize;
		}
		if (pkp.bMULTIPICKUP)
		{
			return pkp.Amount > 0 && index == 0;
		}
		else
		{
			return pkp.Amount > 0 && index < pkp.Amount;
		}
	}

	private void CloseFollowerMenu(int plrNum)
	{
		Selection[plrNum].SelFollowers.Clear();
		FollowerMenuLevel[plrNum] = FMenu_Closed;
	}

	private void ApplySelection(int plrNum)
	{
		int Size = Selection[plrNum].SelFollowers.Size();
		if (Size == 0 || Modifiers[plrNum] != 0)
		{
			return;
		}

		FollowerMenuLevel[plrNum] = Size > 1 ? FMenu_OrdersMulti : FMenu_Main;
		for (int i = 0; i < Size; ++i)
		{
			Selection[plrNum].SelFollowers[i].ChangeLinkedPlayer(HDPlayerPawn(players[plrNum].mo));
		}
	}

	private void DeselectAll(int plrNum, int page)
	{
		if (page > -1)
		{
			for (int i = FollowersPerPage * page; i < min(FollowersPerPage * (page + 1), Followers.Size()); ++i)
			{
				if (Selection[plrNum].SelFollowers.Find(Followers[i]) != Selection[plrNum].SelFollowers.Size())
				{
					ToggleSelection(plrNum, Followers[i]);
				}
			}
		}
		else
		{
			Selection[plrNum].SelFollowers.Clear();
		}
	}

	private void SelectAll(int plrNum, int page, bool invert)
	{
		if (!invert)
		{
			DeselectAll(plrNum, page);
		}
		if (page > -1)
		{
			for (int i = FollowersPerPage * page; i < min(FollowersPerPage * (page + 1), Followers.Size()); ++i)
			{
				ToggleSelection(plrNum, Followers[i]);
			}
		}
		else
		{
			for (int i = 0; i < Followers.Size(); ++i)
			{
				ToggleSelection(plrNum, Followers[i]);
			}
		}
	}

	private void ToggleSelection(int plrNum, HDFollower flw, bool allowDead = false)
	{
		if (flw.CanInteractWith(allowDead))
		{
			int FoundIndex = Selection[plrNum].SelFollowers.Find(flw);
			if (FoundIndex == Selection[plrNum].SelFollowers.Size())
			{
				Selection[plrNum].SelFollowers.Push(flw);
			}
			else
			{
				Selection[plrNum].SelFollowers.Delete(FoundIndex);
			}
		}
	}
}
