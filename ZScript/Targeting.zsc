struct FollowerTarget
{
	Actor Actor;
	int Priority;
}

extend class HDFollower
{
	private void AcquireTargets()
	{
		if (!TargetUncountable)
		{
			TargetUncountable = CVar.GetCVar('hdf_targetuncountable');
		}

		if (!MaxRange)
		{
			MaxRange = CVar.GetCVar('hdf_maxrange');
		}

		double limit = HDCONST_ONEMETRE * MaxRange.GetInt();
		MaxTargetRange = limit > 0 ? min(limit, default.MaxTargetRange) : default.MaxTargetRange;

		let TheEye = BlockThingsIterator.Create(self, MaxTargetRange);

		while (TheEye.Next())
		{
			Actor next = TheEye.thing;
			HDPlayerPawn PTarget = HDPlayerPawn(TheEye.thing);

			// [Ace] Weapons are listed in descending priority.
			// If a weapon is missing from the list, the follower will never attack with that weapon.
			class<FollowerWeapon> W; // [Ace] I won't even bother giving it a full name. This is how much I care at this point.

			if (next && (bFRIENDLY && !next.bFRIENDLY || !bFRIENDLY && next.bFRIENDLY) && next.bISMONSTER && next.bSHOOTABLE && next != self && next.Health > 0 && CheckSight(next, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(next))
			{
				// [Ace] Sometimes resurrected troops can have a ridiculous body damage and won't get attacked, but one single shot will blow them to pieces.
				if (next is 'HERPBot' || next is 'DERPBot' || (!TargetUncountable.GetBool() && !next.bCOUNTKILL))
				{
					continue;
				}

				if (next is 'HDMobBase' && HDMobBase(next).BodyDamage > next.SpawnHealth() * 1.2 || !CanHitTarget(next))
				{
					continue;
				}

				HDMobBase hdmob = HDMobBase(next);
				bool alreadyTargeted = IsAttackedBySomeoneElse(next);
				int shields = next.CountInv('HDMagicShield');

				double noHealthFac = 1.0 - next.Health / double(next.SpawnHealth());
				double noShieldFac = hdmob && hdmob.MaxShields > 0 ? 1.0 - shields / double(hdmob.MaxShields) : 0;

				double priority = next.SpawnHealth() + next.Health * noHealthFac + (hdmob ? hdmob.MaxShields : 0) + shields * noShieldFac;
				if (next.bBOSS)
				{
					priority *= 2;
				}
				else if (next is 'Necromancer')
				{
					priority *= 1.5;
				}
				else if (alreadyTargeted)
				{
					priority *= 0.2;
				}

				if (!FTarget.Actor || FTarget.Actor != next && FTarget.Priority < priority)
				{
					if (hdf_debug & FDebug_Targeting)
					{
						Console.Printf("[%s] %s acquired %s with %i priority. Target has %i/%i health, %i/%i shields, and %i bodydamage.", GetTimestamp(), GetTag(), next.GetClassName(), priority, next.Health, next.SpawnHealth(), shields, hdmob ? hdmob.MaxShields : -1, hdmob ? hdmob.bodydamage : -1);
					}
					FTarget.Actor = next;
					FTarget.Priority = int(priority);
				}
			}
			else if (!bFRIENDLY && PTarget && PTarget.Health > 0 && CheckSight(PTarget, SF_SEEPASTSHOOTABLELINES))
			{
				FTarget.Actor = PTarget;
				FTarget.Priority = 10000;
			}
		}
	}

	protected virtual bool CheckTarget()
	{
		// [Ace] Don't target if:
		// - Follower is friendly and target is friendly or player;
		// - Follower is hostile and target is hostile (from player's POV);
		// - Follower has no sight of target;
		// - Target is dead;
		// - Target is incapped;

		if (!FTarget.Actor)
		{
			return false;
		}

		bool FriendlyCheck = bFRIENDLY && !FTarget.Actor.bFRIENDLY && FTarget.Actor != LinkedPlayer;
		bool HostileCheck = !bFRIENDLY && (FTarget.Actor == LinkedPlayer || FTarget.Actor.bFRIENDLY);
		return CanHitTarget(FTarget.Actor) && (FriendlyCheck || HostileCHeck) && FTarget.Actor.Health > 0 && CheckSight(FTarget.Actor, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(FTarget.Actor) && FTarget.Actor.bSHOOTABLE;
	}

	protected bool TargetIsIncapped(Actor other)
	{
		return other && other.InStateSequence(other.CurState, other.FindState('Falldown'));
	}

	private void ClearTarget()
	{
		if (FTarget.Actor)
		{
			if (hdf_debug & FDebug_Targeting)
			{
				Console.Printf("[%s] %s's target %s was nulled.", GetTimestamp(), GetTag(), FTarget.Actor.GetClassName());
			}
			FTarget.Actor = null;
			FTarget.Priority = 0;
		}
	}

	private bool IsAttackedBySomeoneElse(Actor a)
	{
		for (int i = 0; i < Handler.Followers.Size(); ++i)
		{
			if (Handler.Followers[i] != self && Handler.Followers[i].FTarget.Actor == a && Handler.Followers[i].Status != FStatus_InactiveOrDead)
			{
				return true;
			}
		}

		return false;
	}

	private bool CanHitTarget(Actor a)
	{
		double OldAngle = angle;
		double OldPitch = pitch;
		A_Face(a, 0, 0, flags: FAF_MIDDLE);

		FLineTraceData data;
		LineTrace(angle, MaxTargetRange, pitch, TRF_NOSKY, GetShotHeight(), data: data);
		angle = OldAngle;
		pitch = OldPitch;

		if (data.HitActor != a && hdf_debug & FDebug_Aiming)
		{
			Console.Printf("Failed to target %s. %s is blocking the line of fire.", a.GetClassName(), data.HitActor ? data.HitActor.GetClassName() : 'Nothing?????');
		}

		return data.HitActor == a || data.HitActor is 'HDPlayerPawn' || data.HitActor is 'HDFollower';
	}

	protected transient CVar TargetUncountable;
	protected transient CVar MaxRange;
}