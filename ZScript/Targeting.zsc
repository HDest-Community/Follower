extend class HDFollower
{
	protected virtual void LookForEnemies()
	{
		let TheEye = BlockThingsIterator.Create(self, MaxTargetRange);
		while (TheEye.Next())
		{
			// [Ace] To reiterate,
			// MTarget = MonsterTarget
			// PTarget = PlayerTarget
			// CTarget = CurrentTarget
			// Remember the prefixes.

			Actor MTarget = TheEye.thing;
			HDPlayerPawn PTarget = HDPlayerPawn(TheEye.thing);

			// [Ace] Weapons are listed in descending priority.
			// If a weapon is missing from the list, the follower will never attack with that weapon.
			Array<class<FollowerWeapon> > UsedWeapons;
			class<FollowerWeapon> W; // [Ace] I won't even bother giving it a full name. This is how much I care at this point.

			if (MTarget && (bFRIENDLY && !MTarget.bFRIENDLY || !bFRIENDLY && MTarget.bFRIENDLY) && MTarget.bISMONSTER && MTarget.bSHOOTABLE && MTarget != self && MTarget.Health > 0 && CheckSight(MTarget, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(MTarget))
			{
				// [Ace] Sometimes resurrected troops can have a ridiculous body damage and won't get attacked, but one single shot will blow them to pieces.
				if (MTarget is "HERPBot" || MTarget is "DERPBot" || (!hdf_targetuncountable && !MTarget.bCOUNTKILL) || MTarget is "HDMobBase" && HDMobBase(MTarget).BodyDamage > MTarget.SpawnHealth())
				{
					continue;
				}

				bool AlreadyTargeted = IsAttackedBySomeoneElse(MTarget);

				if (MTarget.bBOSS && (CheckTarget() && !CTarget.bBOSS || !CheckTarget()))
				{
					W = "FW_Bronto"; UsedWeapons.Push(W);
					W = "FW_RocketLauncher"; UsedWeapons.Push(W);
					W = "FW_Liberator"; UsedWeapons.Push(W);
					W = "FW_Boss"; UsedWeapons.Push(W);
					W = "FW_SMG"; UsedWeapons.Push(W);
					W = "FW_ZM66"; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is "Necromancer")
				{
					W = "FW_ZM66"; UsedWeapons.Push(W);
					W = "FW_Hunter"; UsedWeapons.Push(W);
					W = "FW_SMG"; UsedWeapons.Push(W);
					W = "FW_Boss"; UsedWeapons.Push(W);
					W = "FW_Liberator"; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is "PainLord" || MTarget is "PainBringer")
				{
					if (MTarget is "PainLord")
					{
						W = "FW_Bronto"; UsedWeapons.Push(W);
					}
					W = "FW_RocketLauncher"; UsedWeapons.Push(W);
					W = "FW_Liberator"; UsedWeapons.Push(W);
					W = "FW_Boss"; UsedWeapons.Push(W);
					if (HDMobBase(MTarget).Shields > 100)
					{
						W = "FW_SMG"; UsedWeapons.Push(W);
					}
					W = "FW_ZM66"; UsedWeapons.Push(W);
					W = "FW_Hunter"; UsedWeapons.Push(W);
					if (HDMobBase(MTarget).Shields <= 100)
					{
						W = "FW_SMG"; UsedWeapons.Push(W);
					}
					EngageTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is "HDMobBase" && HDMobBase(MTarget).Shields > 150)
				{
					W = "FW_RocketLauncher"; UsedWeapons.Push(W);
					W = "FW_Liberator"; UsedWeapons.Push(W);
					W = "FW_Boss"; UsedWeapons.Push(W);
					W = "FW_SMG"; UsedWeapons.Push(W);
					W = "FW_ZM66"; UsedWeapons.Push(W);
					W = "FW_Hunter"; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget.FindInventory("HDArmourWorn") && !AlreadyTargeted) // [Ace] Don't focus fire on trash.
				{
					W = "FW_Liberator"; UsedWeapons.Push(W);
					W = "FW_Boss"; UsedWeapons.Push(W);		
					W = "FW_ZM66"; UsedWeapons.Push(W);
					W = "FW_SMG"; UsedWeapons.Push(W);
					W = "FW_Hunter"; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
				}
				else if ((!CheckTarget() || !SelWeapon) && !AlreadyTargeted)
				{
					W = "FW_Hunter"; UsedWeapons.Push(W);
					W = "FW_ZM66"; UsedWeapons.Push(W);
					W = "FW_SMG"; UsedWeapons.Push(W);
					W = "FW_Boss"; UsedWeapons.Push(W);
					W = "FW_Liberator"; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
				}
				else if (SelWeapon) // [Ace] In case follower gets interrupted, re-engage old target.
				{
					UsedWeapons.Push(SelWeapon.GetClass());
					EngageTarget(UsedWeapons, CTarget);
				}
			}
			else if (!bFRIENDLY && PTarget && PTarget.Health > 0 && CheckSight(PTarget, SF_SEEPASTSHOOTABLELINES))
			{
				W = "FW_ZM66"; UsedWeapons.Push(W);
				W = "FW_SMG"; UsedWeapons.Push(W);
				EngageTarget(UsedWeapons, PTarget);
			}
		}
	}

	protected virtual bool CheckTarget() const
	{
		// [Ace] Don't target if:
		// - Follower is friendly and target is friendly or player;
		// - Follower is hostile and target is hostile (from player's POV);
		// - Follower has no sight of target;
		// - Target is dead;
		// - Target is incapped;

		if (!CTarget)
		{
			return false;
		}

		bool FriendlyCheck = bFRIENDLY && !CTarget.bFRIENDLY && CTarget != LinkedPlayer;
		bool HostileCheck = !bFRIENDLY && (CTarget == LinkedPlayer || CTarget.bFRIENDLY);
		return (FriendlyCheck || HostileCHeck) && CTarget.Health > 0 && CheckSight(CTarget, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(CTarget) && CTarget.bSHOOTABLE;
	}

	protected bool TargetIsIncapped(Actor other) const
	{
		return other && other.InStateSequence(other.CurState, other.FindState("Falldown"));
	}

	private void ClearTarget()
	{
		CTarget = null;
	}

	private bool IsAttackedBySomeoneElse(Actor a)
	{
		for (int i = 0; i < Handler.Followers.Size(); ++i)
		{
			if (Handler.Followers[i] != self && Handler.Followers[i].CTarget == a)
			{
				return true;
			}
		}

		return false;
	}
}