struct FollowerTarget
{
	Actor Actor;
	int Priority;
}

extend class HDFollower
{
	private void AcquireTargets()
	{
		if (!MaxRange)
		{
			MaxRange = CVar.GetCVar('hdf_maxrange');
		}

		if (++TargetRefreshTicker >= 35)
		{
			TargetList.Clear();
			TargetRefreshTicker = random(-5, 5);

			double limit = HDCONST_ONEMETRE * MaxRange.GetInt();
			MaxTargetRange = limit > 0 ? min(limit, default.MaxTargetRange) : default.MaxTargetRange;

			let TheEye = BlockThingsIterator.Create(self, MaxTargetRange);
			while (TheEye.Next())
			{
				Actor next = TheEye.thing;
				if (CheckTarget(next))
				{
					TargetList.Push(next);
				}
			}
		}

		int size = TargetList.Size();
		for (int i = 0; i < size; ++i)
		{
			Actor t = TargetList[i];
			if (!t || !CheckTarget(t))
			{
				continue;
			}

			HDPlayerPawn pTarget = HDPlayerPawn(t);
			if (pTarget)
			{
				FTarget.Actor = pTarget;
				FTarget.Priority = 10000;
			}
			else
			{
				HDMobBase hdmob = HDMobBase(t);
				bool alreadyTargeted = IsAttackedBySomeoneElse(t);
				int shields = t.CountInv('HDMagicShield');

				double noHealthFac = 1.0 - t.Health / double(t.SpawnHealth());
				double noShieldFac = hdmob && hdmob.MaxShields > 0 ? 1.0 - shields / double(hdmob.MaxShields) : 0;

				double priority = t.SpawnHealth() + t.Health * noHealthFac + (hdmob ? hdmob.MaxShields : 0) + shields * noShieldFac;
				if (t.bBOSS)
				{
					priority *= 2;
				}
				else if (t is 'Necromancer')
				{
					priority *= 1.5;
				}
				else if (alreadyTargeted)
				{
					priority *= 0.2;
				}

				if (!FTarget.Actor || FTarget.Actor != t && FTarget.Priority < priority)
				{
					if (hdf_debug & FDebug_Targeting)
					{
						Console.Printf("[%s] %s acquired %s with %i priority. Target has %i/%i health, %i/%i shields, and %i bodydamage.", GetTimestamp(), GetTag(), t.GetClassName(), priority, t.Health, t.SpawnHealth(), shields, hdmob ? hdmob.MaxShields : -1, hdmob ? hdmob.bodydamage : -1);
					}
					FTarget.Actor = t;
					FTarget.Priority = int(priority);
				}
			}
		}
	}

	protected virtual bool CheckTarget(Actor other = null)
	{
		// [Ace] Don't target if:
		// - Follower is friendly and target is friendly or player;
		// - Follower is hostile and target is hostile (from player's POV);
		// - Follower has no sight of target;
		// - Target is dead;
		// - Target is incapped;
		// - Target is too fucked up;
		// - Target is a bot.

		if (!TargetUncountable)
		{
			TargetUncountable = CVar.GetCVar('hdf_targetuncountable');
		}

		if (!other)
		{
			other = FTarget.Actor;
		}
		if (!other)
		{
			return false;
		}

		if (!other.bISMONSTER && !other.player || other.Health <= 0 || !other.bSHOOTABLE)
		{
			return false;
		}

		bool FriendlyCheck = bFRIENDLY && !other.bFRIENDLY && other != LinkedPlayer;
		bool HostileCheck = !bFRIENDLY && (other == LinkedPlayer || other.bFRIENDLY);
		bool bodyDamageCheck = !(other is 'HDMobBase') || HDMobBase(other).BodyDamage <= other.SpawnHealth() * 1.2;
		bool botCheck = !(other is 'HERPBot' || other is 'DERPBot');
		bool countableCheck = other.bCOUNTKILL || TargetUncountable.GetBool();
		return botCheck && countableCheck && bodyDamageCheck && CanHitTarget(other) && (FriendlyCheck || HostileCHeck) && CheckSight(other, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(other);
	}

	protected bool TargetIsIncapped(Actor other)
	{
		return other && other.InStateSequence(other.CurState, other.FindState('Falldown'));
	}

	private void ClearTarget()
	{
		if (FTarget.Actor)
		{
			if (hdf_debug & FDebug_Targeting)
			{
				Console.Printf("[%s] %s's target %s was nulled.", GetTimestamp(), GetTag(), FTarget.Actor.GetClassName());
			}
			FTarget.Actor = null;
			FTarget.Priority = 0;
		}
	}

	private bool IsAttackedBySomeoneElse(Actor a)
	{
		for (int i = 0; i < Handler.Followers.Size(); ++i)
		{
			if (Handler.Followers[i] != self && Handler.Followers[i].FTarget.Actor == a && Handler.Followers[i].Status != FStatus_InactiveOrDead)
			{
				return true;
			}
		}

		return false;
	}

	private bool CanHitTarget(Actor a)
	{
		double OldAngle = angle;
		double OldPitch = pitch;
		A_Face(a, 0, 0, flags: FAF_MIDDLE);

		FLineTraceData data;
		LineTrace(angle, MaxTargetRange, pitch, TRF_NOSKY, GetShotHeight(), data: data);
		angle = OldAngle;
		pitch = OldPitch;

		if (data.HitActor != a && hdf_debug & FDebug_Aiming)
		{
			Console.Printf("Failed to target %s. %s is blocking the line of fire.", a.GetClassName(), data.HitActor ? data.HitActor.GetClassName() : 'Nothing?????');
		}

		return data.HitActor == a || data.HitActor is 'HDPlayerPawn' || data.HitActor is 'HDFollower';
	}

	private int TargetRefreshTicker;
	private Array<Actor> TargetList;
	private transient CVar TargetUncountable;
	private transient CVar MaxRange;
}