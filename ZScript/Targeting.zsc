extend class HDFollower
{
	protected virtual void LookForEnemies()
	{
		if (!TargetUncountable)
		{
			TargetUncountable = CVar.GetCVar('hdf_targetuncountable');
		}

		Array<class<FollowerWeapon> > UsedWeapons;
		let TheEye = BlockThingsIterator.Create(self, MaxTargetRange);
		while (TheEye.Next())
		{
			// [Ace] To reiterate,
			// MTarget = MonsterTarget
			// PTarget = PlayerTarget
			// CTarget = CurrentTarget
			// Remember the prefixes.

			Actor MTarget = TheEye.thing;
			HDPlayerPawn PTarget = HDPlayerPawn(TheEye.thing);

			// [Ace] Weapons are listed in descending priority.
			// If a weapon is missing from the list, the follower will never attack with that weapon.
			class<FollowerWeapon> W; // [Ace] I won't even bother giving it a full name. This is how much I care at this point.

			if (MTarget && (bFRIENDLY && !MTarget.bFRIENDLY || !bFRIENDLY && MTarget.bFRIENDLY) && MTarget.bISMONSTER && MTarget.bSHOOTABLE && MTarget != self && MTarget.Health > 0 && CheckSight(MTarget, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(MTarget))
			{
				// [Ace] Sometimes resurrected troops can have a ridiculous body damage and won't get attacked, but one single shot will blow them to pieces.
				if (MTarget is "HERPBot" || MTarget is "DERPBot" || (!TargetUncountable.GetBool() && !MTarget.bCOUNTKILL) || MTarget is "HDMobBase" && HDMobBase(MTarget).BodyDamage > MTarget.SpawnHealth() * 1.2)
				{
					continue;
				}

				HDMobBase HDMon = HDMobBase(MTarget);
				bool AlreadyTargeted = IsAttackedBySomeoneElse(MTarget);
				let Shields = MTarget.FindInventory('HDMagicShield');

				if (hdf_debug == 1)
				{
					Console.Printf("%s is attempting to target %s with %i bodydamage and %i shields.", GetDisplayName(), MTarget.GetClassName(), HDMon ? HDMon.BodyDamage : -1, Shields ? Shields.Amount : 0);
				}

				if (!CanHitTarget(MTarget))
				{
					if (hdf_debug == 1)
					{
						Console.Printf("Failed to target %s.", MTarget.GetClassName());
					}
					continue;
				}

				if (MTarget.bBOSS && (CheckTarget() && !CTarget.bBOSS || !CheckTarget()))
				{
					if (!AlreadyTargeted)
					{
						W = 'FW_Bronto'; UsedWeapons.Push(W);
					}
					W = 'FW_RocketLauncher'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is 'Necromancer' && !AlreadyTargeted)
				{
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					W = 'FW_Hunter'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is 'PainLord' || MTarget is 'PainBringer')
				{
					if (!AlreadyTargeted)
					{
						if (MTarget is 'PainLord')
						{
							W = 'FW_Bronto'; UsedWeapons.Push(W);
						}
						W = 'FW_RocketLauncher'; UsedWeapons.Push(W);
					}
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					if (Shields && Shields.Amount > 300)
					{
						W = 'FW_SMG'; UsedWeapons.Push(W);
						W = 'FW_ZM66'; UsedWeapons.Push(W);
						W = 'FW_Hunter'; UsedWeapons.Push(W);
					}
					else
					{
						W = 'FW_ZM66'; UsedWeapons.Push(W);
						W = 'FW_SMG'; UsedWeapons.Push(W);
						W = 'FW_Hunter'; UsedWeapons.Push(W);
					}
					EngageTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is 'HDMobBase' && Shields && Shields.Amount > 150)
				{
					W = 'FW_RocketLauncher'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					if (Shields.Amount <= 350)
					{
						W = 'FW_Hunter'; UsedWeapons.Push(W);
					}
					EngageTarget(UsedWeapons, MTarget);
					break;
				}

				// [Ace] Intentionally don't break the loop in case one of the next monsters is a high priority one.
				else if (MTarget.FindInventory('HDArmourWorn') && !AlreadyTargeted) // [Ace] Don't focus fire on trash.
				{
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);		
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_Hunter'; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
				}
				else if ((!CheckTarget() || !SelWeapon) && !AlreadyTargeted)
				{
					W = 'FW_Hunter'; UsedWeapons.Push(W);
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					EngageTarget(UsedWeapons, MTarget);
				}
				else if (SelWeapon) // [Ace] In case follower gets interrupted, re-engage old target.
				{
					UsedWeapons.Push(SelWeapon.GetClass());
					EngageTarget(UsedWeapons, CTarget);
				}
			}
			else if (!bFRIENDLY && PTarget && PTarget.Health > 0 && CheckSight(PTarget, SF_SEEPASTSHOOTABLELINES))
			{
				W = 'FW_ZM66'; UsedWeapons.Push(W);
				W = 'FW_SMG'; UsedWeapons.Push(W);
				EngageTarget(UsedWeapons, PTarget);
			}
		}
	}

	protected virtual bool CheckTarget()
	{
		// [Ace] Don't target if:
		// - Follower is friendly and target is friendly or player;
		// - Follower is hostile and target is hostile (from player's POV);
		// - Follower has no sight of target;
		// - Target is dead;
		// - Target is incapped;

		if (!CTarget)
		{
			return false;
		}

		bool FriendlyCheck = bFRIENDLY && !CTarget.bFRIENDLY && CTarget != LinkedPlayer;
		bool HostileCheck = !bFRIENDLY && (CTarget == LinkedPlayer || CTarget.bFRIENDLY);
		return (FriendlyCheck || HostileCHeck) && CTarget.Health > 0 && CheckSight(CTarget, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(CTarget) && CTarget.bSHOOTABLE;
	}

	protected bool TargetIsIncapped(Actor other)
	{
		return other && other.InStateSequence(other.CurState, other.FindState('Falldown'));
	}

	private void ClearTarget()
	{
		CTarget = null;
	}

	private bool IsAttackedBySomeoneElse(Actor a)
	{
		for (int i = 0; i < Handler.Followers.Size(); ++i)
		{
			if (Handler.Followers[i] != self && Handler.Followers[i].CTarget == a)
			{
				return true;
			}
		}

		return false;
	}

	private bool CanHitTarget(Actor a)
	{
		double OldAngle = angle;
		double OldPitch = pitch;
		A_Face(a, 0, 0, flags: FAF_MIDDLE);

		FLineTraceData TraceData;
		LineTrace(angle, MaxTargetRange, pitch, TRF_NOSKY, Height - HDCONST_CROWNTOSHOULDER, data: TraceData);
		angle = OldAngle;
		pitch = OldPitch;

		return TraceData.HitActor == a;
	}

	protected void EngageTarget(Array<class<FollowerWeapon> > wpns, Actor other)
	{
		// [Ace] This is used so that FindWeapon() isn't copy-pasted numerous times in the targeting code.
		Array<FollowerWeapon> ActualWeapons;
		for (int i = 0; i < wpns.Size(); ++i)
		{
			FollowerWeapon w = FindWeapon(wpns[i]);
			if (w && w.Enabled)
			{
				ActualWeapons.Push(w);
			}
		}

		FollowerWeapon HighestWithSpare = null;
		FollowerWeapon HighestWithAmmo = null;
		SelWeapon = null;

		// [Ace] Find a weapon that has ammo in it. Start from the end and work backwards.
		for (int i = ActualWeapons.Size() - 1; i >= 0; --i)
		{
			// [Ace] Ignore weapons that don't fulfill the required condition. When it comes to, say, a rocket launcher, this is the check that makes sure you don't get blasted to bits by accident.
			if (!ActualWeapons[i].CheckWeaponCondition(self, other))
			{
				continue;
			}

			class<HDAmmo> AType, MType;
			[AType, MType] = ActualWeapons[i].GetAmmoType();
			if (MType && GetAmount(MType) > 0 || !MType && GetAmount(AType) > 0)
			{
				HighestWithSpare = ActualWeapons[i];
			}
			if (ActualWeapons[i].Mag > 0 || ActualWeapons[i].ChamberedRound == FollowerWeapon.CRType_Chambered)
			{
				HighestWithAmmo = ActualWeapons[i];
			}
		}

		if (hdf_debug == 1)
		{
			Console.Printf("Highest with spare is "..(HighestWithSpare ? HighestWithSpare.GetName() : "nothing")..".");
			Console.Printf("Highest with ammo is "..(HighestWithAmmo ? HighestWithAmmo.GetName() : "nothing")..".");
		}

		if (HighestWithAmmo)
		{
			SelWeapon = HighestWithAmmo;
		}
		else if (HighestWithSpare)
		{
			SelWeapon = HighestWithSpare;
			TryReloadWeapon(SelWeapon, RLF_FORCE | RLF_SILENT | RLF_NOJUMP);
			return;
		}
		
		if (other && SelWeapon)
		{
			CTarget = other;
			SetStateLabel('See');
		}
	}

	protected transient CVar TargetUncountable;
}