extend class HDFollower
{
	enum AcquireTargetFlags
	{
		ATF_NOSWITCH = 1 // [Ace] Don't switch to backup weapons. Instead, reload the top priority weapon, if available.
	}

	protected virtual void LookForEnemies()
	{
		if (!TargetUncountable)
		{
			TargetUncountable = CVar.GetCVar('hdf_targetuncountable');
		}

		Array<class<FollowerWeapon> > UsedWeapons;
		let TheEye = BlockThingsIterator.Create(self, MaxTargetRange);
		while (TheEye.Next())
		{
			// [Ace] To reiterate,
			// MTarget = MonsterTarget
			// PTarget = PlayerTarget
			// CTarget = CurrentTarget
			// Remember the prefixes.

			Actor MTarget = TheEye.thing;
			HDPlayerPawn PTarget = HDPlayerPawn(TheEye.thing);

			// [Ace] Weapons are listed in descending priority.
			// If a weapon is missing from the list, the follower will never attack with that weapon.
			class<FollowerWeapon> W; // [Ace] I won't even bother giving it a full name. This is how much I care at this point.

			if (MTarget && (bFRIENDLY && !MTarget.bFRIENDLY || !bFRIENDLY && MTarget.bFRIENDLY) && MTarget.bISMONSTER && MTarget.bSHOOTABLE && MTarget != self && MTarget.Health > 0 && CheckSight(MTarget, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(MTarget))
			{
				// [Ace] Sometimes resurrected troops can have a ridiculous body damage and won't get attacked, but one single shot will blow them to pieces.
				if (MTarget is "HERPBot" || MTarget is "DERPBot" || (!TargetUncountable.GetBool() && !MTarget.bCOUNTKILL))
				{
					continue;
				}

				HDMobBase HDMon = HDMobBase(MTarget);
				bool AlreadyTargeted = IsAttackedBySomeoneElse(MTarget);
				let Shields = MTarget.FindInventory('HDMagicShield');

				if (hdf_debug == 1)
				{
					Console.Printf("%s is attempting to target %s with %i bodydamage and %i shields.", GetTag(), MTarget.GetClassName(), HDMon ? HDMon.BodyDamage : -1, Shields ? Shields.Amount : 0);
				}

				if (MTarget is "HDMobBase" && HDMobBase(MTarget).BodyDamage > MTarget.SpawnHealth() * 1.2)
				{
					continue;
				}

				if (!CanHitTarget(MTarget))
				{
					continue;
				}

				if (MTarget.bBOSS && (CheckTarget() && !CTarget.bBOSS || !CheckTarget()))
				{
					if (!AlreadyTargeted)
					{
						W = 'FW_Bronto'; UsedWeapons.Push(W);
					}
					W = 'FW_RocketLauncher'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					AcquireTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is 'Necromancer' && !AlreadyTargeted)
				{
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					W = 'FW_Hunter'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					AcquireTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is 'PainLord' || MTarget is 'PainBringer')
				{
					if (!AlreadyTargeted)
					{
						if (MTarget is 'PainLord')
						{
							W = 'FW_Bronto'; UsedWeapons.Push(W);
						}
						W = 'FW_RocketLauncher'; UsedWeapons.Push(W);
					}
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					if (Shields && Shields.Amount > 300)
					{
						W = 'FW_SMG'; UsedWeapons.Push(W);
						W = 'FW_ZM66'; UsedWeapons.Push(W);
						W = 'FW_Hunter'; UsedWeapons.Push(W);
					}
					else
					{
						W = 'FW_ZM66'; UsedWeapons.Push(W);
						W = 'FW_SMG'; UsedWeapons.Push(W);
						W = 'FW_Hunter'; UsedWeapons.Push(W);
					}
					AcquireTarget(UsedWeapons, MTarget);
					break;
				}
				else if (MTarget is 'Trilobite')
				{
					if (!AlreadyTargeted)
					{
						if (MTarget.Health > MTarget.SpawnHealth() / 2)
						{
							W = 'FW_RocketLauncher'; UsedWeapons.Push(W);
						}
						W = 'FW_Liberator'; UsedWeapons.Push(W);
						W = 'FW_Boss'; UsedWeapons.Push(W);	
					}
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_Hunter'; UsedWeapons.Push(W);
					AcquireTarget(UsedWeapons, MTarget);
				}
				else if (MTarget is 'HDMobBase' && Shields && Shields.Amount > 150)
				{
					W = 'FW_RocketLauncher'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					if (Shields.Amount <= 300)
					{
						W = 'FW_Hunter'; UsedWeapons.Push(W);
					}
					AcquireTarget(UsedWeapons, MTarget);
					break;
				}

				// [Ace] Intentionally don't break the loop in case one of the next monsters is a high priority one.
				else if (MTarget.FindInventory('HDArmourWorn') && !AlreadyTargeted) // [Ace] Don't focus fire on trash.
				{
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);	
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					W = 'FW_Hunter'; UsedWeapons.Push(W);
					AcquireTarget(UsedWeapons, MTarget, ATF_NOSWITCH);
				}
				else if ((!CheckTarget() || !SelWeapon) && !AlreadyTargeted)
				{
					W = 'FW_Hunter'; UsedWeapons.Push(W);
					W = 'FW_ZM66'; UsedWeapons.Push(W);
					W = 'FW_Liberator'; UsedWeapons.Push(W);
					W = 'FW_Boss'; UsedWeapons.Push(W);
					W = 'FW_SMG'; UsedWeapons.Push(W);
					AcquireTarget(UsedWeapons, MTarget, ATF_NOSWITCH);
				}
				else if (SelWeapon) // [Ace] In case follower gets interrupted, re-engage old target.
				{
					UsedWeapons.Push(SelWeapon.GetClass());
					AcquireTarget(UsedWeapons, CTarget, ATF_NOSWITCH);
				}
			}
			else if (!bFRIENDLY && PTarget && PTarget.Health > 0 && CheckSight(PTarget, SF_SEEPASTSHOOTABLELINES))
			{
				W = 'FW_ZM66'; UsedWeapons.Push(W);
				W = 'FW_SMG'; UsedWeapons.Push(W);
				W = 'FW_Hunter'; UsedWeapons.Push(W);
				AcquireTarget(UsedWeapons, PTarget, ATF_NOSWITCH);
			}
		}
	}

	protected virtual bool CheckTarget()
	{
		// [Ace] Don't target if:
		// - Follower is friendly and target is friendly or player;
		// - Follower is hostile and target is hostile (from player's POV);
		// - Follower has no sight of target;
		// - Target is dead;
		// - Target is incapped;

		if (!CTarget)
		{
			return false;
		}

		bool FriendlyCheck = bFRIENDLY && !CTarget.bFRIENDLY && CTarget != LinkedPlayer;
		bool HostileCheck = !bFRIENDLY && (CTarget == LinkedPlayer || CTarget.bFRIENDLY);
		return CanHitTarget(CTarget) && (FriendlyCheck || HostileCHeck) && CTarget.Health > 0 && CheckSight(CTarget, SF_SEEPASTSHOOTABLELINES) && !TargetIsIncapped(CTarget) && CTarget.bSHOOTABLE;
	}

	protected bool TargetIsIncapped(Actor other)
	{
		return other && other.InStateSequence(other.CurState, other.FindState('Falldown'));
	}

	private void ClearTarget()
	{
		CTarget = null;
	}

	private bool IsAttackedBySomeoneElse(Actor a)
	{
		for (int i = 0; i < Handler.Followers.Size(); ++i)
		{
			if (Handler.Followers[i] != self && Handler.Followers[i].CTarget == a && Handler.Followers[i].Status != FStatus_InactiveOrDead)
			{
				return true;
			}
		}

		return false;
	}

	private bool CanHitTarget(Actor a)
	{
		double OldAngle = angle;
		double OldPitch = pitch;
		A_Face(a, 0, 0, flags: FAF_MIDDLE);

		FLineTraceData data;
		LineTrace(angle, MaxTargetRange, pitch, TRF_NOSKY, GetShotHeight(), data: data);
		angle = OldAngle;
		pitch = OldPitch;

		if (data.HitActor != a && hdf_debug == 1)
		{
			Console.Printf("Failed to target %s. %s is blocking the line of fire.", a.GetClassName(), data.HitActor ? data.HitActor.GetClassName() : 'Nothing?????');
		}

		return data.HitActor == a;
	}

	// [Ace] This only acquires the target. Actual aiming and engaging and all that jazz is done in AiThink().
	protected void AcquireTarget(Array<class<FollowerWeapon> > wpns, Actor other, int flags = 0)
	{
		// [Ace] This is used so that FindWeapon() isn't copy-pasted numerous times in the targeting code.
		Array<FollowerWeapon> ActualWeapons;
		for (int i = 0; i < wpns.Size(); ++i)
		{
			FollowerWeapon w = FindWeapon(wpns[i]);
			if (w && w.Enabled && w.CheckWeaponCondition(self, other))
			{
				ActualWeapons.Push(w);
			}
		}

		SelWeapon = null;
		
		// [Ace] First try to find the highest weapon in the priority list that has any ammo in it. If it doesn't and NOSWITCH is enabled, try to reload it.
		for (int i = 0; i < ActualWeapons.Size(); ++i)
		{
			if (ActualWeapons[i].HasAmmo())
			{
				SelWeapon = ActualWeapons[i];
				if (hdf_debug == 1)
				{
					Console.Printf("%s selected %s with %i rounds and %s spare ammo.", GetTag(), SelWeapon.GetName(), SelWeapon.Mag, SelWeapon.HasSpare() ? "some" : "no");
				}
				if (other)
				{
					CTarget = other;
				}
				break;
			}
			else if ((flags & ATF_NOSWITCH || ActualWeapons[i].GetFlags() & FollowerWeapon.FWF_NOSWITCH) && ActualWeapons[i].HasSpare())
			{
				SelWeapon = ActualWeapons[i];
				if (hdf_debug == 1)
				{
					Console.Printf("ATF_NOSWITCH is enabled. %s selected %s with %i rounds and %s spare ammo.", GetTag(), SelWeapon.GetName(), SelWeapon.Mag, SelWeapon.HasSpare() ? "some" : "no");
				}
				TryReloadWeapon(SelWeapon, RLF_FORCE | RLF_SILENT | RLF_NOJUMP);
				return;
			}
		}

		// [Ace] Still nothing? Reload the highest weapon.
		if (!SelWeapon)
		{
			for (int i = 0; i < ActualWeapons.Size(); ++i)
			{
				if (ActualWeapons[i].HasSpare())
				{
					SelWeapon = ActualWeapons[i];
					if (hdf_debug == 1)
					{
						Console.Printf("ATF_NOSWITCH is disabled. %s selected %s with %i rounds and %s spare ammo.", GetTag(), SelWeapon.GetName(), SelWeapon.Mag, SelWeapon.HasSpare() ? "some" : "no");
					}
					TryReloadWeapon(SelWeapon, RLF_FORCE | RLF_SILENT | RLF_NOJUMP);
					return;
				}
			}
		}
	}

	protected transient CVar TargetUncountable;
}