extend class HDFollower
{
	enum ResurrectionFlags
	{
		RESF_BLUES = 1 << 0,
		RESF_BLOOD = 1 << 1,
		RESF_MERCHANT = 1 << 2
	}

	// --------------------------------------------------
	// VIRTUALS
	// --------------------------------------------------

	virtual clearscope int GetRequiredBlood()
	{
		return min(BloodReviveTicker / (35 * 4), 60);
	}

	virtual clearscope int GetRequiredSips()
	{
		return clamp(BodyDamage / 200, 2, 12);
	}

	// --------------------------------------------------
	// ACTIONS
	// --------------------------------------------------

	private void SpawnReviveParticles(color col)
	{
		for (int i = 0; i < 3; ++i)
		{
			A_SpawnParticle(col, SPF_RELATIVE, random(15, 35), 4, random(0, 359), frandom(0, Radius), 0, 0, frandom(0.1, 1.0), 0, random(2, 4), 0, 0, -0.2);
		}
	}

	protected void CheckRevive()
	{
		if (ResurrectType & RESF_BLUES && Blues > 0)
		{
			SpawnReviveParticles("2222FF");
			if (++AbsorbedBlues >= 105 + GetRequiredSips() * 12 && level.time % 35 == 0)
			{
				if (!A_RaiseSelf())
				{
					ThinkMessage(LinkedPlayer, "$REVIVE_NOROOM_PLR");
				}
				else
				{
					if (FindState('Raise.Blues', true))
					{
						SetStateLabel('Raise.Blues');
					}
					bFRIENDLY = true;
					PrintMessage(GetResponse("REVIVE_BLUES_SUCCESS"), "Revive/Blues/Success", PMType_Important);
				}
			}
		}
		else if (ResurrectType & RESF_BLOOD && LinkedPlayer.woundcount > 0)
		{
			int RequiredBlood = GetRequiredBlood();
			if (CanReach(MaxReviveDistance) == 0 && LinkedPlayer.woundcount > min(RequiredBlood, 40) && PlayerIsCrouching())
			{
				AbsorbedBlood++;
				SpawnReviveParticles("FF1111");
			}
			else
			{
				BloodReviveTicker++;
			}

			if (AbsorbedBlood >= min(105 + RequiredBlood * 8, 350) && level.time % 70 == 0)
			{
				if (!A_RaiseSelf())
				{
					ThinkMessage(LinkedPlayer, "$REVIVE_NOROOM_PLR");
				}
				else
				{
					if (FindState('Raise.Blood', true))
					{
						SetStateLabel('Raise.Blood');
					}
					LinkedPlayer.AggravatedDamage += RequiredBlood;
					bFRIENDLY = true;
					PrintMessage(GetResponse("REVIVE_BLOOD_SUCCESS"), "Revive/Blood/Success", PMType_Important);
				}
			}
		}
		else if (ResurrectType & RESF_MERCHANT)
		{
			Name clsStr = 'HDMerchant';
			class<Actor> cls = clsStr;
			if (!cls)
			{
				return;
			}
			if (CountProximity(cls, HDCONST_ONEMETRE * 2, CPXF_CLOSEST | CPXF_ANCESTOR) > 0)
			{
				SpawnReviveParticles("8844FF");
				if (++MerchantReviveTicker >= 35 * 60 * 10 && level.time % 140 == 0)
				{
					if (!A_RaiseSelf())
					{
						ThinkMessage(LinkedPlayer, "$REVIVE_NOROOM_PLR");
					}
					else
					{
						if (FindState('Raise.Merchant', true))
						{
							SetStateLabel('Raise.Merchant');
						}
						bFRIENDLY = true;
						PrintMessage(GetResponse("REVIVE_MERCHANT_SUCCESS"), "Revive/Merchant/Success", PMType_Important);
					}
				}
			}
		}
	}

	// [Ace] This is technically cheating, but otherwise the follower can get absolutely assblasted and become useless.
	// It needs to be called directly after Raise so that the correct state is entered, if one actually exists.
	protected void OnRevive()
	{
		BodyDamage = 0;
		Blues = 0;
		AbsorbedBlues = 0;
		AbsorbedBlood = 0;
		BloodReviveTicker = 0;
		MerchantReviveTicker = 0;
		OhanaTicker = 0;
	}

	bool TryRevive(int type)
	{
		if (DistanceToPlayer > radius + MaxReviveDistance)
		{
			ThinkMessage(LinkedPlayer, "$TOOFAR_PLR");
			return false;
		}

		switch (type)
		{
			case 0:
			{
				if (!(ResurrectType & RESF_BLUES))
				{
					return false;
				}

				if (Blues > 0)
				{
					ThinkMessage(LinkedPlayer, "$REVIVE_BLUES_ALREADYWORKING_PLR");
					return true;
				}

				let Potion = BluePotion(LinkedPlayer.FindInventory("BluePotion"));
				if (!Potion)
				{
					ThinkMessage(LinkedPlayer, "$REVIVE_BLUES_NONE_PLR");
					return true;
				}

				int RequiredSips = GetRequiredSips();
				if (Potion.Mags[Potion.Mags.Size() - 1] < RequiredSips)
				{
					ThinkMessage(LinkedPlayer, StringTable.Localize("$REVIVE_BLUES_NOTENOUGH_PLR1").." "..RequiredSips.."/12 "..StringTable.Localize("$REVIVE_BLUES_NOTENOUGH_PLR2"));
					return false;
				}
				Potion.Mags[Potion.Mags.Size() - 1] -= RequiredSips;
				if (Potion.Mags[Potion.Mags.Size() - 1] == 0)
				{
					Potion.TakeMag(false);
					Actor a = LinkedPlayer.Spawn("SpentBottle",LinkedPlayer.pos + (0, 0, LinkedPlayer.Height - 4), ALLOW_REPLACE);
					a.angle = LinkedPlayer.angle + 2;
					a.vel = LinkedPlayer.vel;
					a.A_ChangeVelocity(3, 1, 4, CVF_RELATIVE);

					a = LinkedPlayer.spawn("SpentCork", LinkedPlayer.pos + (0, 0, LinkedPlayer.height - 4), ALLOW_REPLACE);
					a.angle=LinkedPlayer.angle + 3;
					a.vel=LinkedPlayer.vel;
					a.A_ChangeVelocity(5, 3, 4, CVF_RELATIVE);
				}
				Blues = RequiredSips * 12;
				break;
			}

			case 1:
			{
				if (!(ResurrectType & RESF_BLOOD))
				{
					return false;
				}

				LinkedPlayer.woundcount += ((GetRequiredBlood() - LinkedPlayer.woundcount) + 3) * (LinkedPlayer.regenblues > 20 ? 2 : 1);
				break;
			}
		}

		return true;
	}

	// --------------------------------------------------
	// CONSTANTS/VARIABLES	
	// --------------------------------------------------

	const MaxReviveDistance = 24;

	private int Blues;
	private int AbsorbedBlues;

	private int AbsorbedBlood;
	int BloodReviveTicker;

	private int MerchantReviveTicker;

	private int ReviveMethod;

}