extend class HDFollower
{
	enum HealSelfFlags
	{
		HSF_HEALTH = 1,
		HSF_BODYDAMAGE = 2,
		HSF_BLOOD = 3,
		HSF_ALL = HSF_HEALTH | HSF_BODYDAMAGE | HSF_BLOOD
	}

	// --------------------------------------------------
	// ACTIONS
	// --------------------------------------------------

	protected void StopHealing()
	{
		ClearGoal();
		Status = FStatus_None;
		Order = PrevOrder;
		SetStateLabel('Idle');
	}

	protected void HealSelf(int amt, int flags = HSF_ALL)
	{
		if (flags & HSF_HEALTH)
		{
			GiveBody(amt);
		}
		if (flags & HSF_BODYDAMAGE)
		{
			BodyDamage = max(0, BodyDamage - amt);
		}
		if (flags & HSF_BLOOD)
		{
			Bloodloss = max(0, Bloodloss - amt);
		}
	}

	protected void PatchPlayerWounds(int amt)
	{
		if (LinkedPlayer)
		{
			if (!targetWound || targetWound.bleeder != LinkedPlayer) targetWound = HDBleedingWound.findBiggest(LinkedPlayer, HDBW_FINDPATCHED);

			if (targetWound && targetWound.depth <= 0 && targetWound.patched <= 0)
			{
				targetWound = null;
				return;
			}

			if (targetWound && targetWound.patch(frandom(0.8, 1.2), true))
			{
				targetWound.depth += targetWound.patched;
				targetWound.patched = 0;
			}
		}
	}

	protected void PatchPlayerBurns(int amt)
	{
		if (LinkedPlayer && SuturesLeft >= max(MEDIKIT_FLESHGIVE, LinkedPlayer.burnCount))
		{
			int fleshGive = MEDIKIT_FLESHGIVE;
			SuturesLeft -= fleshGive;
	
			LinkedPlayer.A_StartSound("medikit/stopper", CHAN_WEAPON);
			LinkedPlayer.A_StartSound("misc/bulletflesh", CHAN_BODY, CHANF_OVERLAP);
			LinkedPlayer.A_StartSound("misc/smallslop", CHAN_BODY, CHANF_OVERLAP);

			Actor a = spawn("SecondFleshBeast", self. LinkedPlayer.pos, ALLOW_REPLACE);
			a.target = LinkedPlayer;
			a.stamina = fleshGive;
		}
	}

	protected bool TryUnwrapMedikit()
	{
		if (GetAmount('PortableMedikit') > 0)
		{
			// Give/Drop Stimpack
			let spawned = Inventory(Spawn('PortableStimpack', pos));
			if (!AddItem(spawned, 1, flags: FIF_FORCE))
			{
				spawned.Destroy();
				A_DropItem('PortableStimpack');
			}

			// Give/Drop SecondBlood
			spawned = Inventory(Spawn('SecondBlood', pos));
			if (!AddItem(spawned, 1, flags: FIF_FORCE))
			{
				spawned.Destroy();
				A_DropItem('PortableStimpack');
			}

			// Take Medikit & add sutures
			TakeInvItem(Find('PortableMedikit'), FIF_FORCE | FIF_REMOVE);
			SuturesLeft = MEDIKIT_MAXFLESH;

			return true;
		}

		return false;
	}

	// --------------------------------------------------
	// INFORMATION
	// --------------------------------------------------

	clearscope bool CanPatchWounds()
	{
		return GetAmount('PortableMedikit') > 0 || SuturesLeft > 0;
	}

	clearscope bool CanPatchBurns()
	{
		return GetAmount('PortableMedikit') > 0 || SuturesLeft > MEDIKIT_FLESHGIVE;
	}

	clearscope bool CanApplyBlood()
	{
		return LinkedPlayer && getAmount('SecondBlood') > 0 && !LinkedPlayer.countInv('BloodBagWorn');
	}

	clearscope bool CanApplyStim()
	{
		// [Ace] Don't stim player unless it's necessary.
		return LinkedPlayer && LinkedPlayer.CountInv('HDStim') <= HDStim.HDSTIM_MAX - HDStim.HDSTIM_DOSE && GetAmount('PortableStimpack') > 0 && LinkedPlayer.CountInv('HealingMagic') <= 15 && LinkedPlayer.Health < 40;
	}

	clearscope bool CanHealSelf()
	{
		return Health < default.Health || BodyDamage > 0;
	}
	
	clearscope bool NeedToHealSelf()
	{
		return Health <= default.Health * 0.8 || BodyDamage >= default.Health * 0.2;
	}

	clearscope bool PlayerIsIncapped()
	{
		// [Ace] Player can't get up if lying on the floor at < 15 health, even if timer is 0.
		return LinkedPlayer && LinkedPlayer.incapacitated >= 20 && (LinkedPlayer.incaptimer > MinIncap || LinkedPlayer.Health < 15);
	}

	clearscope bool PlayerNeedsMedic()
	{
		return LinkedPlayer
			&& (
				CanApplyStim()
				|| (PlayerHasBleedingWound() && CanPatchWounds())
				|| (PlayerHasBurns() && CanPatchBurns())
				|| (PlayerHasLostBlood() && CanApplyBlood())
			);
	}

	clearscope bool PlayerHasBleedingWound()
	{
		if (LinkedPlayer)
		{
			let wnd = HDBleedingWound.findBiggest(LinkedPlayer);
			return wnd && (wnd.depth > 0 || wnd.patched > 0);
		}

		return false;
	}

	clearscope bool PlayerHasLostBlood()
	{
		return LinkedPlayer && LinkedPlayer.bloodLoss > HDCONST_BLOODBAGAMOUNT * 4;
	}

	clearscope bool PlayerHasBurns()
	{
		return LinkedPlayer && LinkedPlayer.burncount > 0;
	}

	// --------------------------------------------------
	// CONSTANTS/VARIABLES
	// --------------------------------------------------

	const MinIncap = 40;

	HDBleedingWound targetWound;
	int SuturesLeft;
	const MaxSutures = 42;

	const MedicRange = 40;

	States
	{
		PullYouUp:
			#### J 1
			{
				if (!PNeedsHelp || DistanceToPlayer > HDCONST_ONEMETRE * 1.2 || Order != FOrder_ComeAndHelp)
				{
					StopHealing();
					return;
				}

				if (LinkedPlayer.incaptimer > MinIncap)
				{
					A_Face(LinkedPlayer);
					if (!random(0, 4))
					{
						LinkedPlayer.A_StartSound("weapons/pocket", 20, CHANF_NOSTOP);
					}
					LinkedPlayer.incaptimer -= 6;
				}
			}
			Loop;
		StapleHumptyDumptyBackTogetherAgain:
			#### JK 5;
			#### L 5
			{
				// If player is too far or is ordered to stop, stop.
				if (DistanceToPlayer > HDCONST_ONEMETRE * 1.2 || Order != FOrder_ComeAndHelp)
				{
					StopHealing();
					return;
				}

				// If player no longer requires medical attention, stop.
				if (!PNeedsMedic)
				{
					ClearGoal();
					SetStateLabel('PullYouUp');
					return;
				}

				// If player requires medical attention, attempt to unwrap a medikit.
				if (SuturesLeft == 0)
				{
					// If the follower can't, stop.
					if (!TryUnwrapMedikit())
					{
						StopHealing();
						return;
					}
				}

				// First, apply a stimpack if possible.
				if (CanApplyStim())
				{
					TakeInvItem(Find('PortableStimpack'), true);
					SetStateLabel('ApplyStim');
					return;
				}

				// Next, if the player has no immediately open wounds, but has burns, treat them.
				if (!PlayerHasBleedingWound() && PlayerHasBurns())
				{
					SetStateLabel('ApplySecondFlesh');
					return;
				}

				// Finally, if the player has lost a significant amount of blood, give them a bloodbag.
				if (PlayerHasLostBlood() && CanApplyBlood())
				{
					SetStateLabel('ApplyBlood');
					return;
				}

				// Otherwise, treat the open wounds
				A_Face(LinkedPlayer);
				A_StartSound("medikit/stopper", CHAN_WEAPON, CHANF_OVERLAP);
				A_StartSound("misc/bulletflesh", CHAN_BODY, CHANF_OVERLAP);
			}
			#### LLLLL 3
			{
				if (DistanceToPlayer > HDCONST_ONEMETRE * 1.2 || Order != FOrder_ComeAndHelp)
				{
					StopHealing();
					return;
				}

				A_StartSound("medikit/staple", CHAN_WEAPON);
				A_Face(LinkedPlayer);

				LinkedPlayer.A_StartSound("misc/smallslop", CHAN_BODY, CHANF_OVERLAP);
				if (!random(0, 6))
				{
					SetStateLabel('PatchUpEnd');
				}
				LinkedPlayer.GiveBody(1);
				LinkedPlayer.DamageMobj(invoker, null, 1, 'staples', DMG_FORCED);
				HDF.give(LinkedPlayer, 'SecondFlesh', 1);
			}
		PatchUpEnd:
			#### J 10
			{
				SuturesLeft--;
				PatchPlayerWounds(1);
			}
			Goto StapleHumptyDumptyBackTogetherAgain;

		StapleOwnAss:
			#### A 10;
			#### A 5
			{
				if (!CanHealSelf() || Order != FOrder_HealSelf)
				{
					StopHealing();
					return;
				}

				if (SuturesLeft == 0)
				{
					if (!TryUnwrapMedikit())
					{
						StopHealing();
						return;
					}
				}

				A_StartSound("medikit/stopper", CHAN_WEAPON, CHANF_OVERLAP);
				A_StartSound("misc/bulletflesh", CHAN_BODY, CHANF_OVERLAP);
			}
			#### GGGGG 3
			{
				if (Order != FOrder_HealSelf)
				{
					StopHealing();
					return;
				}

				A_StartSound("medikit/staple", CHAN_WEAPON);
				A_StartSound("misc/smallslop", CHAN_BODY, CHANF_OVERLAP);
				A_Vocalize(PainSound, CHANF_NOSTOP);
			}
		PatchUpSelfEnd:
			#### A 10
			{
				HealSelf(10, HSF_HEALTH | HSF_BODYDAMAGE);
				SuturesLeft--;
			}
			Goto StapleOwnAss;

		ApplyBlood:
			#### J 25 A_Face(LinkedPlayer);
			#### J 20
			{
				// if(patient)invoker.weaponstatus[SBS_INJECTCOUNTER]++;else{
				// 	invoker.weaponstatus[SBS_INJECTCOUNTER]=0;
				// 	return;
				// }
				// if(invoker.weaponstatus[SBS_INJECTCOUNTER]>30){
				HDF.give(LinkedPlayer, 'BloodBagWorn', 1);
				A_StartSound("bloodpack/inject", CHAN_WEAPON, CHANF_OVERLAP);
				LinkedPlayer.A_SetBlend("7a 3a 18", 0.1, 4);
				// LinkedPlayer.A_MuzzleClimb(0,2, wepdot: false);
				// invoker.weaponstatus[0]|=INJECTF_SPENT;
				// A_FistNope();
				// }
			}
			Goto StapleHumptyDumptyBackTogetherAgain;

		ApplyStim:
			#### J 25 A_Face(LinkedPlayer);
			#### J 20
			{
				A_Face(LinkedPlayer);
				LinkedPlayer.A_SetBlend("7a 3a 18", 0.1, 4);
				LinkedPlayer.A_SetPitch(pitch + 2, SPF_INTERPOLATE);
				LinkedPlayer.A_StartSound(LinkedPlayer.medsound, CHAN_VOICE);
				LinkedPlayer.A_StartSound("misc/bulletflesh", CHAN_WEAPON);

				Actor a = Spawn("InjectStimDummy", pos, ALLOW_REPLACE);
				a.Accuracy = 40;
				a.target = LinkedPlayer;

				Actor b = Spawn("SpentStim", pos + (0, 0, height - 8), ALLOW_REPLACE);
				b.A_ChangeVelocity(3, 1, 2, CVF_RELATIVE);
				b.A_StartSound("weapons/grenopen", 8);
			}
			#### J 0 PrintMessage(GetResponse("MEDIC_STIMMED"), "Medic/Stimmed", PMType_General);
			Goto StapleHumptyDumptyBackTogetherAgain;

		ApplySecondFlesh:
			#### J 25 A_Face(LinkedPlayer);
			#### J 20
			{

				PatchPlayerBurns(1);
			}
			Goto StapleHumptyDumptyBackTogetherAgain;
	}
}
