extend class HDFollower
{
	private bool PlayerNeedsMedic()
	{
		let plr = HDPlayerPawn(LinkedPlayer);
		return plr && plr.Health > 2 && PlayerIsIncapped() && (HasWounds() && (Medikits > 0 || SuturesLeft > 0) || CanApplyStim());
	}

	private bool PlayerIsIncapped()
	{
		let plr = HDPlayerPawn(LinkedPlayer);
		return plr && plr.incapacitated >= 20 && (plr.incaptimer > MinIncap || plr.Health < 15); // [Ace] Player can't get up if lying on the floor at < 15 health, even if timer is 0.
	}

	private bool HasWounds()
	{
		let plr = HDPlayerPawn(LinkedPlayer);
		return plr && (plr.woundcount > 0 || plr.unstablewoundcount > 0);
	}

	private bool CanApplyStim()
	{
		let plr = HDPlayerPawn(LinkedPlayer);
		return plr.stimcount < 4 && Stimpacks > 0 && plr.regenblues <= 2 && plr.Health < 30; // [Ace] Don't stim player unless it's necessary.
	}

	private void PatchWound(int amt, actor targ)
	{
		let plr = HDPlayerPawn(targ);
		if(plr)
		{
			int wound = max(plr.woundcount, 0);
			int unstablewound = max(plr.unstablewoundcount, 0);
			if (wound)
			{
				plr.woundcount = max(0, wound - amt);
			}
			else if (unstablewound)
			{
				plr.unstablewoundcount = max(0, unstablewound - amt);
			}
			else
			{
				amt = 0;
			}
			plr.oldwoundcount += amt;
		}
	}

	void TryGiveMedikit()
	{
		if (Status == FStatus_InactiveOrDead)
		{
			return;
		}

		string ATag = GetTag();

		if (DistanceToPlayer > radius + MaxInventoryDistance)
		{
			ThinkMessage(LinkedPlayer, "$MEDGIVE_FAR_PLR");
			return;
		}
		else if (Medikits >= MaxMedikits)
		{
			PrintMessage(GetResponse("$"..ATag.."_MEDGIVE_TOOMANY"), "Follower/"..ATag.."/MedGive/TooMany", PMType_Important);
			return;
		}
		else if (!LinkedPlayer.CheckInventory("PortableMedikit", 1))
		{
			ThinkMessage(LinkedPlayer, "$MEDGIVE_NOTENOUGH_PLR");
			return;
		}

		LinkedPlayer.A_TakeInventory("PortableMedikit", 1);
		LinkedPlayer.A_GiveInventory("SecondBlood", 1);
		PrintMessage(GetResponse("$"..ATag.."_MEDGIVE_SUCCESS"), "Follower/"..ATag.."/MedGive/Success", PMType_General);

		Medikits++;
		Stimpacks++;
	}

	void TryGiveStimpack()
	{
		if (Status == FStatus_InactiveOrDead)
		{
			return;
		}
		
		string ATag = GetTag();

		let PlayerStimpack = PortableStimpack(LinkedPlayer.FindInventory("PortableStimpack"));
		if (DistanceToPlayer > radius + MaxInventoryDistance)
		{
			ThinkMessage(LinkedPlayer, "$STIMGIVE_FAR_PLR");
			return;
		}
		else if (Stimpacks >= MaxStimpacks)
		{
			PrintMessage(GetResponse("$"..ATag.."_STIMGIVE_TOOMANY"), "Follower/"..ATag.."/StimGive/TooMany", PMType_Important);
			return;
		}
		else if (!PlayerStimpack)
		{
			ThinkMessage(LinkedPlayer, "$STIMGIVE_NOTENOUGH_PLR");
			return;
		}

		PlayerStimpack.TakeMag(false);
		PrintMessage(GetResponse("$"..ATag.."_STIMGIVE_SUCCESS"), "Follower/"..ATag.."/StimGive/Success", PMType_General);

		Stimpacks++;
	}

	private bool IsHelpingPlayer()
	{
		if (Order != FOrder_ComeAndHelp)
		{
			return false;
		}

		static const StateLabel HealingStates[] =
		{
			"StapleHumptyDumptyBackTogetherAgain", "PatchUpEnd", "ApplyStim", "PullYouUp"
		};

		for (int i = 0; i < HealingStates.Size(); ++i)
		{
			if (InStateSequence(CurState, FindState(HealingStates[i])))
			{
				return true;
			}
		}

		return false;
	}

	protected void DropAllSupplies()
	{
		for (int i = 0; i < Medikits; ++i)
		{
			A_SpawnItemEx('PortableMedikit', random(0, 16), 0, 0, frandom(1.0, 2.0), 0, frandom(2.0, 5.0), random(0, 359), SXF_NOCHECKPOSITION);
		}
		for (int i = 0; i < Stimpacks; ++i)
		{
			A_SpawnItemEx('PortableStimpack', random(0, 16), 0, 0, frandom(1.0, 2.0), 0, frandom(2.0, 5.0), random(0, 359), SXF_NOCHECKPOSITION);
		}
	}

	const MinIncap = 40;

	int SuturesLeft;
	const MaxSutures = 42;
	
	int Medikits;
	const MaxMedikits = 2;

	int Stimpacks;
	const MaxStimpacks = 4;

	const MedicRange = 40;

	States
	{
		PullYouUp:
			#### J 1
			{
				if (!PNeedsHelp)
				{
					ClearGoal();
					SetStateLabel('Idle');
					return;
				}

				let plr = HDPlayerPawn(LinkedPlayer);
				if (plr.incaptimer > MinIncap)
				{
					A_Face(plr);
					if (!random(0, 4))
					{
						plr.A_StartSound("weapons/pocket", 20, CHANF_NOSTOP);
					}
					plr.incaptimer -= 6;
				}
			}
			Loop;
		StapleHumptyDumptyBackTogetherAgain:
			#### JK 5;
			#### L 5
			{
				if (CanApplyStim())
				{
					Stimpacks--;
					SetStateLabel('ApplyStim');
					return;
				}
				if (!PNeedsMedic)
				{
					ClearGoal();
					SetStateLabel('PullYouUp');
					return;
				}

				if (SuturesLeft == 0)
				{
					Medikits--;
					SuturesLeft = MaxSutures;
				}

				A_Face(LinkedPlayer);
				A_StartSound("medikit/stopper", CHAN_WEAPON, CHANF_OVERLAP);
				A_StartSound("misc/bulletflesh", CHAN_BODY, CHANF_OVERLAP);
			}
			#### LLLLL 3
			{
				let plr = HDPlayerPawn(LinkedPlayer);
				A_StartSound("medikit/staple", CHAN_WEAPON);
				A_Face(plr);

				plr.A_StartSound("misc/smallslop", CHAN_BODY, CHANF_OVERLAP);
				if(!random(0, 6))
				{
					SetStateLabel('PatchUpEnd');
				}
				plr.GiveBody(1);
				plr.DamageMobj(invoker, null, 1, 'staples', DMG_FORCED);
				HDPlayerPawn(plr).secondflesh++;
			}
		PatchUpEnd:
			#### J 10
			{
				SuturesLeft--;
				PatchWound(1, LinkedPlayer);
			}
			Goto StapleHumptyDumptyBackTogetherAgain;
		ApplyStim:
			#### J 25 A_Face(LinkedPlayer);
			#### J 20
			{
				let plr = HDPlayerPawn(LinkedPlayer);
				A_Face(plr);
				plr.A_SetBlend("7a 3a 18", 0.1, 4);
				plr.A_SetPitch(pitch + 2, SPF_INTERPOLATE);
				plr.A_StartSound(plr.medsound, CHAN_VOICE);
				plr.A_StartSound("misc/bulletflesh", CHAN_WEAPON);

				Actor a = Spawn("InjectStimDummy", pos, ALLOW_REPLACE);
				a.Accuracy = 40;
				a.target = plr;

				Actor b = Spawn("SpentStim", pos + (0, 0, height - 8), ALLOW_REPLACE);
				b.A_ChangeVelocity(3, 1, 2, CVF_RELATIVE);
				b.A_StartSound("weapons/grenopen", 8);
			}
			#### J 0
			{
				string ATag = GetTag();
				PrintMessage(GetResponse("$"..ATag.."_MEDIC_STIMMED"), "Follower/"..ATag.."/Medic/Stimmed", PMType_General);
			}
			Goto StapleHumptyDumptyBackTogetherAgain;
	}
}