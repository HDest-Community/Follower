extend class HDFollower
{
	// --------------------------------------------------
	// ACTIONS
	// --------------------------------------------------

	protected void StopHealing()
	{
		ClearGoal();
		Status = FStatus_None;
		Order = PrevOrder;
		SetStateLabel('Idle');
	}

	protected void HealSelf(int amt)
	{
		GiveBody(amt);
		BodyDamage = max(0, BodyDamage - amt);
		Bloodloss = max(0, Bloodloss - amt);
	}

	protected void HealPlayer(int amt)
	{
		int wound = max(LinkedPlayer.woundcount, 0);
		int unstablewound = max(LinkedPlayer.unstablewoundcount, 0);
		if (wound)
		{
			LinkedPlayer.woundcount = max(0, wound - amt);
		}
		else if (unstablewound)
		{
			LinkedPlayer.unstablewoundcount = max(0, unstablewound - amt);
		}
		else
		{
			amt = 0;
		}
		LinkedPlayer.oldwoundcount += amt;
	}

	protected bool TryUnwrapMedikit()
	{
		if (GetAmount('PortableMedikit') > 0)
		{
			let stim = HDMagAmmo(GiveInventoryType('PortableStimpack'));
			stim.SyncAmount();
			if (!AddMag(stim, flags: FIF_FORCE))
			{
				A_DropInventory('PortableStimpack');
			}
			A_DropItem('SecondBlood');
			Find('PortableMedikit').Destroy();
			SuturesLeft = MaxSutures;
			return true;
		}
		return false;
	}

	// --------------------------------------------------
	// INFORMATION
	// --------------------------------------------------

	clearscope bool CanApplyStim()
	{
		return LinkedPlayer && LinkedPlayer.stimcount < 4 && GetAmount('PortableStimpack') > 0 && LinkedPlayer.regenblues <= 2 && LinkedPlayer.Health < 30; // [Ace] Don't stim player unless it's necessary.
	}

	clearscope bool PlayerHasWounds()
	{
		return LinkedPlayer && (LinkedPlayer.woundcount > 0 || LinkedPlayer.unstablewoundcount > 0);
	}

	clearscope bool PlayerIsIncapped()
	{
		return LinkedPlayer && LinkedPlayer.incapacitated >= 20 && (LinkedPlayer.incaptimer > MinIncap || LinkedPlayer.Health < 15); // [Ace] Player can't get up if lying on the floor at < 15 health, even if timer is 0.
	}

	clearscope bool PlayerNeedsMedic()
	{
		return LinkedPlayer && LinkedPlayer.Health > 2 && (PlayerHasWounds() && !LinkedPlayer.FindInventory('HDArmourWorn') && (GetAmount('PortableMedikit') > 0 || SuturesLeft > 0) || CanApplyStim());
	}

	// --------------------------------------------------
	// CONSTANTS/VARIABLES
	// --------------------------------------------------

	const MinIncap = 40;

	int SuturesLeft;
	const MaxSutures = 42;

	const MedicRange = 40;

	const MinSelfHealPercent = 0.9;

	States
	{
		PullYouUp:
			#### J 1
			{
				if (!PNeedsHelp)
				{
					StopHealing();
					return;
				}

				if (LinkedPlayer.incaptimer > MinIncap)
				{
					A_Face(LinkedPlayer);
					if (!random(0, 4))
					{
						LinkedPlayer.A_StartSound("weapons/pocket", 20, CHANF_NOSTOP);
					}
					LinkedPlayer.incaptimer -= 6;
				}
			}
			Loop;
		StapleHumptyDumptyBackTogetherAgain:
			#### JK 5;
			#### L 5
			{
				if (DistanceToPlayer > HDCONST_ONEMETRE * 1.2)
				{
					StopHealing();
					return;
				}

				if (CanApplyStim())
				{
					Find('PortableStimpack').Destroy();
					SetStateLabel('ApplyStim');
					return;
				}

				if (!PNeedsMedic)
				{
					ClearGoal();
					SetStateLabel('PullYouUp');
					return;
				}

				if (SuturesLeft == 0)
				{
					if (!TryUnwrapMedikit())
					{
						StopHealing();
						return;
					}
				}

				A_Face(LinkedPlayer);
				A_StartSound("medikit/stopper", CHAN_WEAPON, CHANF_OVERLAP);
				A_StartSound("misc/bulletflesh", CHAN_BODY, CHANF_OVERLAP);
			}
			#### LLLLL 3
			{
				if (DistanceToPlayer > HDCONST_ONEMETRE * 1.2)
				{
					StopHealing();
					return;
				}

				A_StartSound("medikit/staple", CHAN_WEAPON);
				A_Face(LinkedPlayer);

				LinkedPlayer.A_StartSound("misc/smallslop", CHAN_BODY, CHANF_OVERLAP);
				if (!random(0, 6))
				{
					SetStateLabel('PatchUpEnd');
				}
				LinkedPlayer.GiveBody(1);
				LinkedPlayer.DamageMobj(invoker, null, 1, 'staples', DMG_FORCED);
				LinkedPlayer.secondflesh++;
			}
		PatchUpEnd:
			#### J 10
			{
				SuturesLeft--;
				HealPlayer(1);
			}
			Goto StapleHumptyDumptyBackTogetherAgain;

		StapleOwnAss:
			#### A 10;
			#### A 5
			{
				if (Health > default.Health * MinSelfHealPercent)
				{
					StopHealing();
					return;
				}

				if (SuturesLeft == 0)
				{
					if (!TryUnwrapMedikit())
					{
						StopHealing();
						return;
					}
				}

				A_StartSound("medikit/stopper", CHAN_WEAPON, CHANF_OVERLAP);
				A_StartSound("misc/bulletflesh", CHAN_BODY, CHANF_OVERLAP);
			}
			#### GGGGG 3
			{
				A_StartSound("medikit/staple", CHAN_WEAPON);
				A_StartSound("misc/smallslop", CHAN_BODY, CHANF_OVERLAP);
				A_StartSound(PainSound, CHAN_VOICE, CHANF_NOSTOP);
			}
		PatchUpSelfEnd:
			#### A 10
			{
				GiveBody(10);
				SuturesLeft--;
			}
			Goto StapleOwnAss;

		ApplyStim:
			#### J 25 A_Face(LinkedPlayer);
			#### J 20
			{
				A_Face(LinkedPlayer);
				LinkedPlayer.A_SetBlend("7a 3a 18", 0.1, 4);
				LinkedPlayer.A_SetPitch(pitch + 2, SPF_INTERPOLATE);
				LinkedPlayer.A_StartSound(LinkedPlayer.medsound, CHAN_VOICE);
				LinkedPlayer.A_StartSound("misc/bulletflesh", CHAN_WEAPON);

				Actor a = Spawn("InjectStimDummy", pos, ALLOW_REPLACE);
				a.Accuracy = 40;
				a.target = LinkedPlayer;

				Actor b = Spawn("SpentStim", pos + (0, 0, height - 8), ALLOW_REPLACE);
				b.A_ChangeVelocity(3, 1, 2, CVF_RELATIVE);
				b.A_StartSound("weapons/grenopen", 8);
			}
			#### J 0 PrintMessage(GetResponse("MEDIC_STIMMED"), "Medic/Stimmed", PMType_General);
			Goto StapleHumptyDumptyBackTogetherAgain;
	}
}
