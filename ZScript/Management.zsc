extend class FollowerHandler
{
	const InternalFollowers = 6;
	Array<HDFollower> Followers;

	void InsertFollower(HDFollower flw)
	{
		int InsIndex = 0;
		int FollowerCount = Followers.Size();
		if (FollowerCount > 0)
		{
			for (int i = 0; i < FollowerCount; ++i)
			{
				if (flw.Index >= Followers[i].Index)
				{
					InsIndex = i + 1;
				}
				else
				{
					InsIndex = i;
					break;
				}
			}
		}
		Followers.Insert(InsIndex, flw);
	}

	void RemoveFollower(HDFollower flw, bool permanent = false, bool noDestroy = false)
	{
		int Index = Followers.Find(flw);
		if (Index != Followers.Size())
		{
			if (permanent && flw.MissingClass && players[Net_Arbitrator].mo)
			{
				players[Net_Arbitrator].mo.A_GiveInventory(flw.MissingClass);
			}
			if (!noDestroy)
			{
				flw.Destroy();
			}
			Followers.Delete(Index);
		}
	}

	private HDFollower CreateFollower(class<HDFollower> flw, int playerNum, vector3 pos = (0, 0, 0))
	{
		let plr = players[playerNum].mo;
		if (plr)
		{
			let FollowerDef = GetDefaultByType(flw);

			// [Ace] New map who dis? Spawn a new follower.
			if (!FollowerDef.MissingClass || !plr.CheckInventory(FollowerDef.MissingClass, 1))
			{
				Actor a; bool success;
				if (pos == (0, 0, 0))
				{
					[success, a] = plr.A_SpawnItemEx(flw, random(16, 48), 0, random(0, 32), angle: random(0, 359), flags: SXF_NOCHECKPOSITION);
				}
				else
				{
					a = Actor.Spawn(flw, pos);
					success = true;
				}
				if (success)
				{
					let Follower = HDFollower(a);
					InsertFollower(Follower);
					
					Follower.ChangeLinkedPlayer(HDPlayerPawn(plr));

					// [Ace] These are here so that they are only called once when the follower is created.
					Follower.GiveStartingItems();
					Follower.InitWeapons();
					return Follower;
				}
			}
		}
		return null;
	}
}

extend class HDFollower
{
	virtual void Dismiss()
	{
		if (Health <= 0)
		{
			switch (CanReach(MaxInventoryDistance))
			{
				case 1: ThinkMessage(LinkedPlayer, "$TOOFAR_PLR"); return;
				case 2: ThinkMessage(LinkedPlayer, "$NOTFACING_PLR"); return;
			}
		}

		for (int i = 0; i < Weapons.Size(); ++i)
		{
			Weapons[i].EmptyWeapon();
		}
		for (int i = 0; i < SlotCount; ++i)
		{
			DropInvItem(Slots[i], true);
		}
		let WornArmor = FindInventory("HDArmourWorn");
		if (WornArmor)
		{
			A_DropInventory(WornArmor.GetClass());
		}
		for (int i = 0; i < 64; ++i)
		{
			vector3 POff = ((random() - 128) * Radius / 128, (random() - 128) * Radius / 128, random() * Height / 256);
			vector3 PVel = ((1.0 / 4096) * (random() - 128), (1.0 / 4096) * (random() - 128), (1.0 / 4096) * (random() - 128));
			vector3 PAcc = ((1.0 / 16384) * (random() - 128), (1.0 / 16384) * (random() - 128), (1.0 / 16384) * (random() - 128));
			A_SpawnParticle(random(0, 1) ? Color(154, 49, 49) : Color(125, 24, 24), 0, TICRATE * 2, 4, 0, POff.x, POff.y, POff.z, PVel.x, PVel.y, PVel.z, PAcc.x, PAcc.y, PAcc.z);
		}
		if (!random[dismissrand](0, 10))
		{
			Console.Printf("%s disconnected.", DisplayName);
		}
		Handler.RemoveFollower(self, true);
	}
}